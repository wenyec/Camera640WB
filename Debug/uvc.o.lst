   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 2
  10              		.eabi_attribute 18, 4
  11              		.file	"uvc.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.align	2
  22              		.global	I2cAppThread_Entry
  24              	I2cAppThread_Entry:
  25              	.LFB25:
  26              		.file 1 "../uvc.c"
   1:../uvc.c      **** /*
   2:../uvc.c      ****  ## Cypress FX3 Camera Kit Source file (uvc.c)
   3:../uvc.c      ****  ## ===========================
   4:../uvc.c      ****  ##
   5:../uvc.c      ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2012,
   6:../uvc.c      ****  ##  All Rights Reserved
   7:../uvc.c      ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../uvc.c      ****  ##
   9:../uvc.c      ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../uvc.c      ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../uvc.c      ****  ##
  12:../uvc.c      ****  ##  Use of this file is governed
  13:../uvc.c      ****  ##  by the license agreement included in the file
  14:../uvc.c      ****  ##
  15:../uvc.c      ****  ##     <install>/license/license.txt
  16:../uvc.c      ****  ##
  17:../uvc.c      ****  ##  where <install> is the Cypress software
  18:../uvc.c      ****  ##  installation root directory path.
  19:../uvc.c      ****  ##
  20:../uvc.c      ****  ## ===========================
  21:../uvc.c      **** */
  22:../uvc.c      **** 
  23:../uvc.c      **** /* This project implements a USB Video Class device that streams uncompressed video
  24:../uvc.c      ****    data from an image sensor to a USB host PC.
  25:../uvc.c      **** 
  26:../uvc.c      ****    Please refer to the Cypress Application Note: "AN75779: Interfacing an Image
  27:../uvc.c      ****    Sensor to EZ-USB FX3 in a USB video class (UVC) Framework" (http://www.cypress.com/?rID=62824)
  28:../uvc.c      ****    for a detailed design description of this application.
  29:../uvc.c      **** 
  30:../uvc.c      ****    As the UVC class driver on Windows hosts does not support burst enabled Isochronous
  31:../uvc.c      ****    endpoints on USB 3.0, this implementation makes use of Bulk endpoints for the video
  32:../uvc.c      ****    streaming.
  33:../uvc.c      ****  */
  34:../uvc.c      **** /*****************************************
  35:../uvc.c      ****  *
  36:../uvc.c      ****  * The code is modified at 1/2014
  37:../uvc.c      ****  * 1. add a thread for I2C commands handle
  38:../uvc.c      ****  * 2. add UVC Camera Terminal Requests handle
  39:../uvc.c      ****  * 3. add UVC Extension Unit Requests handle
  40:../uvc.c      ****  * 4. more UVC Processing Unit Requests added
  41:../uvc.c      ****  * 5. Support USB3.0 1080p 25/30fps and USB2.0 960x540p 25/30 fps
  42:../uvc.c      ****  *
  43:../uvc.c      ****  ****************************************/
  44:../uvc.c      **** 
  45:../uvc.c      **** #include <cyu3system.h>
  46:../uvc.c      **** #include <cyu3os.h>
  47:../uvc.c      **** #include <cyu3dma.h>
  48:../uvc.c      **** #include <cyu3error.h>
  49:../uvc.c      **** #include <cyu3usb.h>
  50:../uvc.c      **** #include <cyu3uart.h>
  51:../uvc.c      **** #include <cyu3gpif.h>
  52:../uvc.c      **** #include <cyu3i2c.h>
  53:../uvc.c      **** #include <cyu3gpio.h>
  54:../uvc.c      **** #include <cyu3pib.h>
  55:../uvc.c      **** #include <cyu3utils.h>
  56:../uvc.c      **** 
  57:../uvc.c      **** #include "uvc.h"
  58:../uvc.c      **** #include "sensor.h"
  59:../uvc.c      **** #include "camera_ptzcontrol.h"
  60:../uvc.c      **** #include "cyfxgpif2config.h"
  61:../uvc.c      **** 
  62:../uvc.c      **** #ifndef CAM720
  63:../uvc.c      **** #ifdef GPIFIIM
  64:../uvc.c      **** #include "cyfxgpif2config_usb2.h"//
  65:../uvc.c      **** #else
  66:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"//
  67:../uvc.c      **** #endif
  68:../uvc.c      **** #else
  69:../uvc.c      **** #include "cyfxgpif2config_usb2_720.h"
  70:../uvc.c      **** #endif
  71:../uvc.c      **** 
  72:../uvc.c      **** #include "cmdqu.h"
  73:../uvc.c      **** 
  74:../uvc.c      **** #define  NOQU    //for queue debug
  75:../uvc.c      **** #define  SPEED   1// for optical zoom speed setting: 1 no support
  76:../uvc.c      **** 
  77:../uvc.c      **** /*************************************************************************************************
  78:../uvc.c      ****                                          Global Variables
  79:../uvc.c      ****  *************************************************************************************************/
  80:../uvc.c      **** static CyU3PThread   uvcAppThread;                      /* UVC video streaming thread. */
  81:../uvc.c      **** static CyU3PThread   uvcAppEP0Thread;                   /* UVC control request handling thread. */
  82:../uvc.c      **** static CyU3PEvent    glFxUVCEvent;                      /* Event group used to signal threads. */
  83:../uvc.c      **** CyU3PDmaMultiChannel glChHandleUVCStream;               /* DMA multi-channel handle. */
  84:../uvc.c      **** CyU3PDmaMultiChannel glChHandleStillStream;             /* DMA multi-channel handle for still image
  85:../uvc.c      **** CyU3PDmaChannel glChHandleInterStat;                    /* DMA channel handle for interrupt status.
  86:../uvc.c      **** 
  87:../uvc.c      **** uint8_t     *glInterStaBuffer;                          /* Buffer used to send interrrupt status. *
  88:../uvc.c      **** uint8_t     snapButFlag = 1;							/* snap shot button flag: 0 = masked; 1 = unmasked;*/
  89:../uvc.c      **** uint8_t     testSnap = 0;				                /* used for debugging */	
  90:../uvc.c      **** /**************** variables relative to the command queue operation ****************/
  91:../uvc.c      **** static CyU3PThread   i2cAppThread;      //i2c control command handling thread
  92:../uvc.c      **** VdRingBuf        cmdQu;                 //the command queue
  93:../uvc.c      **** VdRingBuf        statQu;                //the state queue
  94:../uvc.c      **** CyU3PMutex       cmdQuMux;
  95:../uvc.c      **** CyU3PMutex       staQuMux;
  96:../uvc.c      **** CyU3PMutex       timMux;
  97:../uvc.c      **** 
  98:../uvc.c      **** /* Current UVC control request fields. See USB specification for definition. */
  99:../uvc.c      **** uint8_t  bmReqType, bRequest;                           /* bmReqType and bRequest fields. */
 100:../uvc.c      **** uint16_t wValue, wIndex, wLength;                       /* wValue, wIndex and wLength fields. */
 101:../uvc.c      **** 
 102:../uvc.c      **** uint16_t fb=0,pb=0,pbc=0;
 103:../uvc.c      **** uint16_t fbbak=0, pbbak=0, pbcbak=0, pbcpbak=0;
 104:../uvc.c      **** 
 105:../uvc.c      **** CyBool_t        isUsbConnected = CyFalse;               /* Whether USB connection is active. */
 106:../uvc.c      **** CyU3PUSBSpeed_t usbSpeed = CY_U3P_NOT_CONNECTED;        /* Current USB connection speed. */
 107:../uvc.c      **** CyBool_t        clearFeatureRqtReceived = CyFalse;      /* Whether a CLEAR_FEATURE (stop streaming)
 108:../uvc.c      ****                                                            received. */
 109:../uvc.c      **** CyBool_t        streamingStarted = CyFalse;             /* Whether USB host has started streaming d
 110:../uvc.c      **** #ifdef BACKFLOW_DETECT
 111:../uvc.c      **** uint8_t back_flow_detected = 0;                         /* Whether buffer overflow error is detecte
 112:../uvc.c      **** #endif
 113:../uvc.c      **** 
 114:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
 115:../uvc.c      **** CyU3PDmaChannel  glDebugCmdChannel;                     /* Channel to receive debug commands on. */
 116:../uvc.c      **** CyU3PDmaChannel  glDebugRspChannel;                     /* Channel to send debug responses on. */
 117:../uvc.c      **** uint8_t         *glDebugRspBuffer;                      /* Buffer used to send debug responses. */
 118:../uvc.c      **** #endif
 119:../uvc.c      **** 
 120:../uvc.c      **** /* UVC Probe Control Settings for a USB 3.0 connection. */
 121:../uvc.c      **** uint8_t glProbeCtrl[CY_FX_UVC_MAX_PROBE_SETTING] = {
 122:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 123:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 124:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 125:../uvc.c      ****     0x15, 0x16, 0x05, 0x00,     /* Desired frame interval in the unit of 100ns: 30 fps */
 126:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 127:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 128:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 129:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 130:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 131:../uvc.c      ****                                    with adjustable compression parameters */
 132:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 133:../uvc.c      ****                                    streaming with adjustable compression parameters */
 134:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 135:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 136:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 137:../uvc.c      **** };
 138:../uvc.c      **** 
 139:../uvc.c      **** /* UVC still image Protrol Settings for a USB 3.0 connection */
 140:../uvc.c      **** uint8_t glProbeStilCtrl[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 141:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 142:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 143:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 144:../uvc.c      ****     0x00, 0x48, 0x3F, 0x00,     /* Max video frame size in bytes */
 145:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 146:../uvc.c      **** };
 147:../uvc.c      **** 
 148:../uvc.c      **** 
 149:../uvc.c      **** /* UVC Probe Control Setting for a USB 2.0 connection. */
 150:../uvc.c      **** uint8_t glProbeCtrl20[CY_FX_UVC_MAX_PROBE_SETTING] = {
 151:../uvc.c      ****     0x00, 0x00,                 /* bmHint : no hit */
 152:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 153:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 154:../uvc.c      ****     0x80, 0x1a, 0x06, 0x00,     /* Desired frame interval in the unit of 100ns: 15 fps */
 155:../uvc.c      ****     0x00, 0x00,                 /* Key frame rate in key frame/video frame units: only applicable
 156:../uvc.c      ****                                    to video streaming with adjustable compression parameters */
 157:../uvc.c      ****     0x00, 0x00,                 /* PFrame rate in PFrame / key frame units: only applicable to
 158:../uvc.c      ****                                    video streaming with adjustable compression parameters */
 159:../uvc.c      ****     0x00, 0x00,                 /* Compression quality control: only applicable to video streaming
 160:../uvc.c      ****                                    with adjustable compression parameters */
 161:../uvc.c      ****     0x00, 0x00,                 /* Window size for average bit rate: only applicable to video
 162:../uvc.c      ****                                    streaming with adjustable compression parameters */
 163:../uvc.c      ****     0x00, 0x00,                 /* Internal video streaming i/f latency in ms */
 164:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 165:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 166:../uvc.c      **** };
 167:../uvc.c      **** 
 168:../uvc.c      **** /* UVC still image Protrol Settings for a USB 2.0 connection */
 169:../uvc.c      **** uint8_t glProbeStilCtrl20[11/*CY_FX_UVC_MAX_PROBE_SETTING*/] = {
 170:../uvc.c      ****     0x01,                       /* Use 1st Video format index */
 171:../uvc.c      ****     0x01,                       /* Use 1st Video frame index */
 172:../uvc.c      ****     0x00,						/* Compression index from a frame descriptor */
 173:../uvc.c      ****     0x00, 0xD2, 0x0F, 0x00,     /* Max video frame size in bytes */
 174:../uvc.c      ****     0x00, 0x40, 0x00, 0x00      /* No. of bytes device can rx in single payload = 16 KB */
 175:../uvc.c      **** };
 176:../uvc.c      **** 
 177:../uvc.c      **** 
 178:../uvc.c      **** /* Video Probe Commit Control. This array is filled out when the host sends down the SET_CUR reques
 179:../uvc.c      **** static uint8_t glCommitCtrl[CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED];
 180:../uvc.c      **** 
 181:../uvc.c      **** /* UVC Header to be prefixed at the top of each 16 KB video data buffer. */
 182:../uvc.c      **** uint8_t volatile glUVCHeader[CY_FX_UVC_MAX_HEADER] =
 183:../uvc.c      **** {
 184:../uvc.c      ****     0x0C,                               /* Header Length */
 185:../uvc.c      ****     0x8C,                               /* Bit field header field */
 186:../uvc.c      ****     0x00, 0x00, 0x00, 0x00,             /* Presentation time stamp field */
 187:../uvc.c      ****     0x00, 0x00, 0x00, 0x00, 0x00, 0x00  /* Source clock reference field */
 188:../uvc.c      **** };
 189:../uvc.c      **** 
 190:../uvc.c      **** volatile static CyBool_t hitFV = CyFalse;               /* Whether end of frame (FV) signal has bee
 191:../uvc.c      **** volatile static CyBool_t gpif_initialized = CyFalse;    /* Whether the GPIF init function has been 
 192:../uvc.c      **** volatile static uint16_t prodCount = 0, consCount = 0;  /* Count of buffers received and committed 
 193:../uvc.c      ****                                                            the current video frame. */
 194:../uvc.c      **** volatile static CyBool_t stiflag = CyFalse;             /* Whether the image is still image */
 195:../uvc.c      **** #define isWBMamu   0  // Is white balance control manual mode.
 196:../uvc.c      **** 
 197:../uvc.c      **** /************ control parameters array ***********
 198:../uvc.c      ****  *  the first D is the index of functionality, the second D is the index of parameters.
 199:../uvc.c      ****  *    e.g.
 200:../uvc.c      ****  *     1th D: brightness, contrast, hue, saturation, sharpness, gamma, WBT, ~, BLC, main freq, ...
 201:../uvc.c      ****  *     2ed D: RegAdd1, RegAdd2, length, Min1, Min2, Max1, Max2, Res1, Res2, InfoReq1, InfoReq2, Def
 202:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag
 203:../uvc.c      ****  **************************************************/
 204:../uvc.c      **** #define BLCIndex  0 // the back light compensation index
 205:../uvc.c      **** #define CamModeIndex 28 // the index of camera mode
 206:../uvc.c      **** static uint8_t CtrlParArry[32][24]={
 207:../uvc.c      **** 		{BLCModeReg          , BLCModeReg           , 2,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,   3,
 208:../uvc.c      **** 		{BrightnessReg1      , BrightnessReg0       , 2,    0,    0,  255,    0, 1, 0, 3, 0, 118, 0, 118,
 209:../uvc.c      **** 		{ContrastReg         , ContrastReg          , 2,    0,    0,  255,    0, 1, 0, 3, 0, 112, 0, 112,
 210:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 211:../uvc.c      **** 		{MainsFreqReg        , MainsFreqReg         , 2,    0,    0,    1,    0, 1, 0, 3, 0,   1, 0,   1,
 212:../uvc.c      **** 		{HuectrlRegGr        , HuectrlRegBlu        , 2,    0,    0,  255,    0, 1, 0, 3, 0, 128, 0,   0,
 213:../uvc.c      **** 		{SaturationRegR      , SaturationRegB       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  50, 0,  50,
 214:../uvc.c      **** 		{SharpnessReg        , SharpnessReg         , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 215:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 216:../uvc.c      **** 		{WBModeReg           , WBModeReg            , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 217:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,   0, 0,   0,
 218:../uvc.c      **** 		{ManuBWBReg          , ManuRWBReg           , 4,    0,    0,   64,    0, 1, 0, 3, 0,  32,56,  32,
 219:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 220:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 221:../uvc.c      **** 		{DigZoomReg          , DigZoomReg           , 2,    0,    0,   27,    0, 1, 0, 3, 0,   0, 0,   0,
 222:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 223:../uvc.c      **** 		{ShutterReg          , ShutterReg           , 2,    0,    0,   18,    0, 1, 0, 3, 0,   0, 0,   0,
 224:../uvc.c      **** 		{SenseUpReg          , SenseUpReg           , 2,    0,    0,    9,    0, 1, 0, 3, 0,   0, 0,   1,
 225:../uvc.c      **** 		{MirrModeReg         , MirrModeReg          , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   2,
 226:../uvc.c      **** 		{NoiRedu3DModReg     , NoiRedu3DModReg      , 2,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,   0,
 227:../uvc.c      **** 		{NoiRedu3DLevReg     , NoiRedu3DLevReg      , 1,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 228:../uvc.c      **** 		{DayNightModReg      , DayNightModReg       , 2,    0,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0,
 229:../uvc.c      **** 		{DayNightDlyReg      , DayNightDlyReg       , 2,    0,    0,   63,    0, 1, 0, 3, 0,   0, 0,   0,
 230:../uvc.c      **** 		{DayNightLevReg      , DayNightLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 231:../uvc.c      **** 		{NightDayLevReg      , NightDayLevReg       , 2,    0,    0,  100,    0, 1, 0, 3, 0,  16, 0,  16,
 232:../uvc.c      **** 		{AExModeReg          , AExAGCReg            , 4,    0,    0,  127,    0, 1, 0, 3, 0,   0,32,   0,
 233:../uvc.c      **** 		{AExReferleveReg     , AExReferleveReg      , 2,    0,    0,   64,    0, 1, 0, 3, 0,  32, 0,  32,
 234:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   25,    0, 1, 0, 3, 0,   0, 0,   0,
 235:../uvc.c      **** 		{SensorModeReg       , SensorModeReg        , 2,    0,    0,    6,    0, 1, 0, 3, 0,   3, 0,   3,
 236:../uvc.c      **** 		{0/*StillImg*/       , 0                    , 2,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 237:../uvc.c      **** 		{SeveParsReg         , SeveParsReg          , 1,    0,    0,    3,    0, 1, 0, 3, 0,   0, 0,   0,
 238:../uvc.c      **** 		/**********************************
 239:../uvc.c      **** 		 * the I2C commands control for generic I2C module control.
 240:../uvc.c      **** 		 * the data format: wLength 10 bytes, the first part is address. the significant length is presen
 241:../uvc.c      **** 		 * 					Maximum is 6. so the total length in this part is 7 bytes.
 242:../uvc.c      **** 		 * 					The second part is data. the significant length is presented by 8th byte.
 243:../uvc.c      **** 		 * 					Maximum is 2. so the total length of this part is 3.
 244:../uvc.c      **** 		 * 					Total length of the request is 10 bytes.
 245:../uvc.c      **** 		 *
 246:../uvc.c      **** 		 *********************************/
 247:../uvc.c      **** 		{0/*I2CCtrl*/        , 0                    ,11,    0,    0,  0xff, 0xff, 1, 0, 3, 0,   0, 0,   0
 248:../uvc.c      **** };
 249:../uvc.c      **** 
 250:../uvc.c      **** #ifndef CAM720
 251:../uvc.c      **** 	static uint8_t CamMode = 0; //0:1080p
 252:../uvc.c      **** #else
 253:../uvc.c      **** 	static uint8_t CamMode = 1; //1:720p
 254:../uvc.c      **** #endif
 255:../uvc.c      **** 
 256:../uvc.c      **** static uint8_t ExUCtrlParArry[16][24]={
 257:../uvc.c      **** 		{0x13/*Ext1BLCRangeCtlID0 position*/ , 0x14/*size*/ , 2,    1,    0,    3,    0, 1, 0, 3, 0, 0x23
 258:../uvc.c      **** 		{0x11/*Ext1BLCWeightCtlID1*/         , 0   , 2,    1,    0,    3,    0, 1, 0, 3, 0,   1, 0,   1, 
 259:../uvc.c      **** 		{0x17/*Ext1BLCGridCtlID2*/           , 0   , 1,    1,    0,    2,    0, 1, 0, 3, 0,   0, 0,   0, 
 260:../uvc.c      **** 		{0,                                     0   , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,0x4
 261:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,   0,
 262:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,   0,
 263:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,   0,
 264:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0xa,
 265:../uvc.c      **** 		{0,                                     0   , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,   0,
 266:../uvc.c      **** 		{0,                                     0   , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,   0,
 267:../uvc.c      **** 		{0,                                     0   , 3,    0,    0,   10,    0, 1, 0, 3, 0,   0, 0,   0,
 268:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 269:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 270:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 271:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 272:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 273:../uvc.c      **** };
 274:../uvc.c      **** 
 275:../uvc.c      **** /*      RegAdd1,             RegAdd2,              length, Min1,  Min2, Max1, Max2, Res1, Res2, Inf
 276:../uvc.c      ****  *            curVal1, curVal2 (index:14th), device address, checked flag, command available flag*/
 277:../uvc.c      **** static uint8_t CTCtrlParArry[16][24]={
 278:../uvc.c      **** 		{ScanMCtlID0            , 0                    , 1,    0,    0,    3,    0, 1, 0, 3, 0,   3, 0,  
 279:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 1,    1,    0,   15,    0,15, 0, 3, 0,   2, 0,  
 280:../uvc.c      **** 		{AutoExPCtlID2          , 0                    , 1,    0,    0,    1,    0, 1, 0, 3, 0,   0, 0,  
 281:../uvc.c      **** 		{ShutterReg             , ShutterReg           , 4,    0x1,    0, 0x38, 0x01, 1, 0, 3, 0,0x4e, 0,
 282:../uvc.c      **** 		{ExTmRCtlID4            , 0                    , 1,    0,    0,    0,    0, 1, 0, 3, 0,   0, 0,  
 283:../uvc.c      **** 		{FocACtlID5             , 0                    , 2,    0,    0,  255,    0, 1, 0, 3, 0,   1, 0,  
 284:../uvc.c      **** 		{FocRCtlID6             , 0                    , 2,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 285:../uvc.c      **** 		{IrisAFReg              , 0                    , 2,    0,    0,   48,    0, 1, 0, 3, 0x0a,0, 0, 0
 286:../uvc.c      **** 		{IriRCtlID8             , 0                    , 1,    0,    0,  127,    0, 1, 0, 3, 0,   0, 0,  
 287:../uvc.c      **** 		{ZmOpACtlID9            , 0                    , 2,    0,    0,    5,    0, 1, 0, 3, 0,   0, 0,  
 288:../uvc.c      **** 		{OpZoomReg              , 0                    , 3,    0,    0,    0,    0, 0, 0, 3, 0,   0, 0,  
 289:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,   64,    0, 1, 0, 3, 0,  15, 17,  0,
 290:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 291:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 292:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 293:../uvc.c      **** 		{0                   , 0                    , 2,    0,    0,  100,    0, 1, 0, 3, 0,   0, 0,   0,
 294:../uvc.c      **** };
 295:../uvc.c      **** static uint16_t ShutValueArry[8]={200, 100, 39, 20, 10, 5, 2, 1};
 296:../uvc.c      **** static uint8_t ExTime[8][2]={{0x9c, 0x00}, {0x4e, 0x00}, {0x27, 0x00}, {0x14, 0x00}, {0x0a, 0x00}, 
 297:../uvc.c      **** /*
 298:../uvc.c      ****  * WBMenuCmpArry is set for white storing balance component requests values.
 299:../uvc.c      ****  * first two bytes represent blue and last two are for red. The defaults are set to 0.
 300:../uvc.c      ****  */
 301:../uvc.c      **** static uint8_t WBMenuCmpArry[4]={
 302:../uvc.c      **** 		0x20, 0x0f, 0x38, 0xf0
 303:../uvc.c      **** };
 304:../uvc.c      **** static uint8_t I2CCMDArry[12]={//the index 12 points to data available; 0: no used; 0xf: unavailabl
 305:../uvc.c      **** 		0
 306:../uvc.c      **** };
 307:../uvc.c      **** 
 308:../uvc.c      **** //static uint32_t  isFlag = 0x0; /*set current value flag*/
 309:../uvc.c      **** 
 310:../uvc.c      **** void I2CCmdHandler(){
 311:../uvc.c      **** 	uint8_t buf[2];
 312:../uvc.c      **** 	uint8_t CmdType, CmdRegLen, CmdDataLen;
 313:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 314:../uvc.c      **** 	CmdRegLen = I2CCMDArry[1];
 315:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 316:../uvc.c      **** 	VdRingBuf *cmdQuptr = &cmdQu;
 317:../uvc.c      **** 
 318:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 319:../uvc.c      **** 			I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 320:../uvc.c      **** 			I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 321:../uvc.c      **** 
 322:../uvc.c      **** 	if(CmdType == 0)//I2C read
 323:../uvc.c      **** 	{
 324:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 325:../uvc.c      **** #if 0 //for debugging
 326:../uvc.c      **** 		/* test still image operation */
 327:../uvc.c      **** 		if(I2CCMDArry[2] == 0xff){
 328:../uvc.c      **** 			snapButFlag = 0; //press
 329:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 330:../uvc.c      **** 		}else if(I2CCMDArry[2] == 0x0){
 331:../uvc.c      **** 			snapButFlag = 0xf; //release
 332:../uvc.c      **** 			//CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt st
 333:../uvc.c      **** 		}
 334:../uvc.c      **** 
 335:../uvc.c      **** 		/* end of the test */
 336:../uvc.c      **** #endif
 337:../uvc.c      **** 		if(1||(CmdRegLen == 4)){
 338:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 339:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 340:../uvc.c      **** 			if(CmdDataLen == 2){
 341:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 342:../uvc.c      **** 			}
 343:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 344:../uvc.c      **** 		}else{//not support currently
 345:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 346:../uvc.c      **** 		}
 347:../uvc.c      **** 	}else if(CmdType == 1){
 348:../uvc.c      **** 		if(1||(CmdRegLen == 4)){//TODO cmdque mutual
 349:../uvc.c      **** 			if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 350:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 351:../uvc.c      **** 				cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 352:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 353:../uvc.c      **** 			}
 354:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 355:../uvc.c      **** 		}else{//not support currently
 356:../uvc.c      **** 			CyU3PDebugPrint (4, "The I2C command length is not supported. value %d\r\n", CmdRegLen);
 357:../uvc.c      **** 		}
 358:../uvc.c      **** 
 359:../uvc.c      **** 	}
 360:../uvc.c      **** }
 361:../uvc.c      **** 
 362:../uvc.c      **** /************************************
 363:../uvc.c      ****  * set Iris mode
 364:../uvc.c      ****  * input isAuto: 0: set manual; 1: set auto
 365:../uvc.c      ****  */
 366:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 367:../uvc.c      **** 	uint8_t dataIdx;
 368:../uvc.c      **** 	  dataIdx = 0;
 369:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 370:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 372:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 373:../uvc.c      **** }
 374:../uvc.c      **** 
 375:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 376:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 377:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 378:../uvc.c      ****     uint16_t readCount;
 379:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len, idx, locCtrlID;
 380:../uvc.c      ****     uint8_t devAdd;
 381:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 382:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 383:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 384:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 385:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 386:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 387:../uvc.c      ****     }else{
 388:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 389:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 390:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 391:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 392:../uvc.c      ****     }
 393:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 394:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 395:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value %d 0x%x 0x%x\r\n", CtrlID, CtrlParArry[CtrlID][13], C
 396:../uvc.c      **** #endif
 397:../uvc.c      ****     reqData = bRequest;
 398:../uvc.c      ****     /*
 399:../uvc.c      ****      * Ext manual mode is not supported in 1080p camera
 400:../uvc.c      ****      */
 401:../uvc.c      ****     if (0 && (CtrlID == ExtAexModCtlID9)){
 402:../uvc.c      ****     	//CyU3PDebugPrint (4, "The Aex manual mode and AGC level are not support with 1080p camera.\r\
 403:../uvc.c      ****     	goto EndofSet;
 404:../uvc.c      ****     }
 405:../uvc.c      ****     switch (bRequest)
 406:../uvc.c      **** 		 {
 407:../uvc.c      **** 
 408:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 409:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 410:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 411:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 412:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 413:../uvc.c      **** 			  break;
 414:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 415:../uvc.c      **** 
 416:../uvc.c      **** 			 switch(CtrlID)
 417:../uvc.c      **** 			 {
 418:../uvc.c      **** 			 	 if(CtrlID >= EXUAOFFSET){
 419:../uvc.c      **** 			 	 	 case Ext1BLCRangeCtlID0:
 420:../uvc.c      **** 			 	 	 case Ext1BLCWeightCtlID1:
 421:../uvc.c      **** 			 	 	 case Ext1BLCGridCtlID2:
 422:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 423:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 424:../uvc.c      **** 						 sendData = glEp0Buffer[0];
 425:../uvc.c      **** 						 sendData1 = glEp0Buffer[1];
 426:../uvc.c      **** 			 	 		 break;
 427:../uvc.c      **** 			 	 }
 428:../uvc.c      **** 			 	 case ExtCamMCtlID12:
 429:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 430:../uvc.c      **** 					 if(CamMode == 1){//720p
 431:../uvc.c      **** 						if(sendData >= 3){
 432:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 433:../uvc.c      **** 							sendData = 0; //set back to default
 434:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 435:../uvc.c      **** 						}
 436:../uvc.c      **** 						sendData += 4;
 437:../uvc.c      **** 					 }
 438:../uvc.c      **** 					//CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 439:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 440:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 441:../uvc.c      **** 					 break;
 442:../uvc.c      **** 			 	 case ExtI2CCtlID15:
 443:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 444:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 445:../uvc.c      **** 			 		 }
 446:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 447:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 448:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 449:../uvc.c      **** 			 		CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%
 450:../uvc.c      **** 			 				I2CCMDArry[0], I2CCMDArry[1], I2CCMDArry[2], I2CCMDArry[3], I2CCMDArry[4], I2CCMDArry[5],
 451:../uvc.c      **** 			 				I2CCMDArry[6], I2CCMDArry[7], I2CCMDArry[8], I2CCMDArry[9], I2CCMDArry[10]);
 452:../uvc.c      **** #endif
 453:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 454:../uvc.c      **** 			 		 {
 455:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 456:../uvc.c      **** 			 		 }
 457:../uvc.c      **** 			 		 break;
 458:../uvc.c      **** 				 case ExtAexModCtlID9:
 459:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 461:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 462:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 463:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 464:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 465:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 466:../uvc.c      **** 					 break;
 467:../uvc.c      **** 
 468:../uvc.c      **** 			 	 case BrgtCtlID1:
 469:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 470:../uvc.c      **** 					 Data1 = CtrlParArry[CtrlID][14];  //SensorGetControl(RegAdd1, devAdd);
 471:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 472:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 473:../uvc.c      **** 					 }else{
 474:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 475:../uvc.c      **** 					 }
 476:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 477:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 478:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 479:../uvc.c      **** 					 break;
 480:../uvc.c      **** 				 case HueCtlID5:
 481:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(HuectrlRegRed, devAdd);
 482:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 483:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 484:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 485:../uvc.c      **** 					 break;
 486:../uvc.c      **** 				 case WBTLevCtlID11:
 487:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 488:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 489:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 490:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 491:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 492:../uvc.c      **** 					 sendData1 = glEp0Buffer[2];
 493:../uvc.c      **** 					 break;
 494:../uvc.c      **** 				 case SaturCtlID6:
 495:../uvc.c      **** 				 default:
 496:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 497:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 498:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 499:../uvc.c      **** 					 break;
 500:../uvc.c      **** 			 }
 501:../uvc.c      **** 
 502:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 503:../uvc.c      **** 
 504:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 505:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value %d 0x%x 0x%x, %d\r\n", CtrlID, CtrlParArry[CtrlID][1
 506:../uvc.c      **** #endif
 507:../uvc.c      **** 			  break;
 508:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum BLC = 0. */
 509:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 510:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 511:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 512:../uvc.c      **** 		 	 }
 513:../uvc.c      **** 
 514:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 515:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 516:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 517:../uvc.c      **** 				 glEp0Buffer[2] = 1;//WBMenuCmpArry[2];//using for red part
 518:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 519:../uvc.c      **** 			 }else
 520:../uvc.c      **** 			 {
 521:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 522:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 523:../uvc.c      **** 			 }
 524:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 525:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 526:../uvc.c      **** 			  break;
 527:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 528:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 529:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 530:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 531:../uvc.c      **** 		 	 }
 532:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 533:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 534:../uvc.c      **** 				 glEp0Buffer[1] = 0;
 535:../uvc.c      **** 				 glEp0Buffer[2] = 0xff;//WBMenuCmpArry[2];//using for red part
 536:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 537:../uvc.c      **** 			 }else
 538:../uvc.c      **** 			 {
 539:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 540:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 541:../uvc.c      **** 			 }
 542:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 543:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 544:../uvc.c      **** 			  break;
 545:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 546:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 548:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 549:../uvc.c      **** 				 glEp0Buffer[2] = 0;
 550:../uvc.c      **** 				 glEp0Buffer[3] = 0;
 551:../uvc.c      **** 		 	 }
 552:../uvc.c      **** 		 	 else{
 553:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 554:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 555:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 556:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 557:../uvc.c      **** 		 	 }
 558:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 559:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 560:../uvc.c      **** 			  break;
 561:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 562:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 563:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 564:../uvc.c      **** 		 	 }
 565:../uvc.c      **** 		 	 else{
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 567:../uvc.c      **** 		 	 }
 568:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 569:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 570:../uvc.c      **** 			  Len = 1;
 571:../uvc.c      **** 			  break;
 572:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 573:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 574:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 575:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 576:../uvc.c      **** 		 	 }
 577:../uvc.c      **** 
 578:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 579:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 580:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 581:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 582:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 583:../uvc.c      **** 			 }else{
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 585:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 586:../uvc.c      **** 			 }
 587:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 588:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 589:../uvc.c      **** 			  break;
 590:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 591:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 592:../uvc.c      **** 				  glEp0Buffer, &readCount);
 593:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 594:../uvc.c      **** 			   {
 595:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 596:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 597:../uvc.c      **** 				  getData = glEp0Buffer[0];
 598:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 599:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 600:../uvc.c      **** 				  CyU3PDebugPrint (4, "The setup sensor value (0) %d 0x%x 0x%x 0x%x\r\n", CtrlID, readCount, gl
 601:../uvc.c      **** #endif
 602:../uvc.c      **** 				  switch(CtrlID)
 603:../uvc.c      **** 					 {
 604:../uvc.c      **** 						 case ExtShutCtlID0:
 605:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 606:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 607:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 608:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 609:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 610:../uvc.c      **** 									 }else{
 611:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 612:../uvc.c      **** 									 }
 613:../uvc.c      **** 								 }
 614:../uvc.c      **** 							 }else{
 615:../uvc.c      **** 								 Data1 = Data0 - 1;
 616:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 617:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 618:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 619:../uvc.c      **** 									 }else{
 620:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 621:../uvc.c      **** 									 }
 622:../uvc.c      **** 								 }
 623:../uvc.c      **** 								 if(Data1 < 8){
 624:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 625:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 626:../uvc.c      **** 								 }else{
 627:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 628:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 629:../uvc.c      **** 								 }
 630:../uvc.c      **** 							 }
 631:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 632:../uvc.c      **** 							 dataIdx = 0;
 633:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 634:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 635:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 636:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The shutter&exposure 0x%x 0x%x 0x%x ox%x\r\n", Data1, Data0, CTCtrlP
 637:../uvc.c      **** 							 break;
 638:../uvc.c      **** 						 case ExtAexModCtlID9://exposure&AGC
 639:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 640:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 641:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 642:../uvc.c      **** 							 dataIdx = 0;
 643:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 644:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 645:../uvc.c      **** 							 if(getData != 0){
 646:../uvc.c      **** 								 dataIdx++;
 647:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 648:../uvc.c      **** 							 }
 649:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 650:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 651:../uvc.c      **** 							 break;
 652:../uvc.c      **** 						 case ExtCamMCtlID12:
 653:../uvc.c      **** 							 dataIdx = 0;
 654:../uvc.c      **** 							 if(Data0 <= 3){
 655:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 656:../uvc.c      **** 								 Data1 = Data0;
 657:../uvc.c      **** 							 }else{
 658:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 659:../uvc.c      **** 								 Data1 = Data0-4;
 660:../uvc.c      **** 							 }
 661:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 662:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 663:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 664:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 665:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 666:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 667:../uvc.c      **** 							 //CyU3PDebugPrint (4, "The CamMode value %d %d %d %d\r\n", Data1, Data0, CamMode, CtrlParAr
 668:../uvc.c      **** 							 break;
 669:../uvc.c      **** 						 case ExtSensorParCtlID14://TODO
 670:../uvc.c      **** 							 dataIdx = 0;
 671:../uvc.c      **** 							 if(Data0 == 0){ //set default sensor parameters.
 672:../uvc.c      **** 								 Data0 = 1;
 673:../uvc.c      **** 							 }else{ //save current sensor parameters.
 674:../uvc.c      **** 								 Data0 = 0;
 675:../uvc.c      **** 							 }
 676:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 677:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 678:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 679:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 680:../uvc.c      **** 							 break;
 681:../uvc.c      **** 						 case ExtI2CCtlID15:
 682:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 683:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 684:../uvc.c      **** 					 		 }
 685:../uvc.c      **** 					 		I2CCmdHandler();
 686:../uvc.c      **** 							 break;
 687:../uvc.c      **** 						 case Ext1BLCRangeCtlID0: //registers value BLD window enable (0x17); position (0x13); size (
 688:../uvc.c      **** 							 dataIdx = 0;
 689:../uvc.c      **** #if 0 //seperate version
 690:../uvc.c      **** 							 getData = Data0&0xF; //get LSB H-Pos.
 691:../uvc.c      **** 							 getData1 = Data0>>4; //get MSB V-Pos.
 692:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 693:../uvc.c      **** 							 if(getData1&0x8){//enable BLD window
 694:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 1, dataIdx); //show BLC window
 695:../uvc.c      **** 							 }else{ //disable BLD window
 696:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, 0x17, devAdd, 0, dataIdx); //close BLC window
 697:../uvc.c      **** 							 }
 698:../uvc.c      **** 							 getData1 = getData1&0x7; //mask bit7 ~ bit3/
 699:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //set H-Pos
 700:../uvc.c      **** 							 dataIdx++;
 701:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData1, dataIdx);  //set V-Pos
 702:../uvc.c      **** 							 dataIdx++;
 703:../uvc.c      **** 							 getData = Data1&0xf; //get LSB H-size.
 704:../uvc.c      **** 							 getData1 = Data1>>4; //get MSB V-size.
 705:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData, dataIdx);  //set H-size
 706:../uvc.c      **** 							 dataIdx++;
 707:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //set V-size
 708:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 709:../uvc.c      **** #else //combination version
 710:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 711:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 712:../uvc.c      **** 						     /* end test */
 713:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 714:../uvc.c      **** 							 dataIdx++;
 715:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 716:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 717:../uvc.c      **** 							 getData1 = Data1;
 718:../uvc.c      **** #endif
 719:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 720:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 721:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 722:../uvc.c      **** 							 break;
 723:../uvc.c      **** 						 case Ext1BLCWeightCtlID1: //register value 0x11 (need check).
 724:../uvc.c      **** 							 dataIdx = 0;
 725:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 726:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 727:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 728:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 729:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 730:../uvc.c      **** 							 break;
 731:../uvc.c      **** 						 case Ext1BLCGridCtlID2:
 732:../uvc.c      **** 							 dataIdx = 0;
 733:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 734:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 735:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 736:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 737:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 738:../uvc.c      **** 							 break;
 739:../uvc.c      **** 				  	  	 case BrgtCtlID1:
 740:../uvc.c      **** 							 dataIdx = 0;
 741:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 742:../uvc.c      **** 							  /****** double check the register0 Data1 ******/
 743:../uvc.c      **** 							  if(Data0&0x80){
 744:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 745:../uvc.c      **** 							  }else{
 746:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 747:../uvc.c      **** 							  }
 748:../uvc.c      **** 							 Data1 |= ~0x03;
 749:../uvc.c      **** 							 Data1 &= 0xC7;
 750:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 751:../uvc.c      **** 						  	 dataIdx++;
 752:../uvc.c      **** 
 753:../uvc.c      **** 							 Data0 = (Data0 << 2);
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 755:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 756:../uvc.c      **** 
 757:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 758:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 759:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 760:../uvc.c      **** 
 761:../uvc.c      **** 							 break;
 762:../uvc.c      **** 						 case HueCtlID5:  //mapping to hue control registers
 763:../uvc.c      **** 							 dataIdx = 0;
 764:../uvc.c      **** 
 765:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 766:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 767:../uvc.c      **** 							 dataIdx++;
 768:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 769:../uvc.c      **** 							 dataIdx++;
 770:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 771:../uvc.c      **** 							 dataIdx++;
 772:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 773:../uvc.c      **** 							 dataIdx++;
 774:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 775:../uvc.c      **** 							 dataIdx++;
 776:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 777:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 778:../uvc.c      **** 
 779:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 780:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 781:../uvc.c      **** 							 break;
 782:../uvc.c      **** 						 case SaturCtlID6:
 783:../uvc.c      **** 							 dataIdx = 0;
 784:../uvc.c      **** 							 Data1 = Data0 = glEp0Buffer[0]; //red and blue set the same value.
 785:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 786:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 787:../uvc.c      **** 							 dataIdx++;
 788:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 789:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 791:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 792:../uvc.c      **** 							 break;
 793:../uvc.c      **** 
 794:../uvc.c      **** 						 case WBTLevCtlID11:
 795:../uvc.c      **** 							 Data0 = glEp0Buffer[0]; //blue
 796:../uvc.c      **** 							 Data1 = glEp0Buffer[2]; //red
 797:../uvc.c      **** 							 dataIdx = 0;
 798:../uvc.c      **** 
 799:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 801:../uvc.c      **** 							 dataIdx++;
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 803:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 804:../uvc.c      **** 
 805:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 806:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 808:../uvc.c      **** 							 break;
 809:../uvc.c      **** 						 case MFreqCtlID4:
 810:../uvc.c      **** 							 dataIdx = 0;
 811:../uvc.c      **** 							 Data0 = Data0 - 1;
 812:../uvc.c      **** 							 if(Data0 < 0)  //for specific check. if it's minor value, set to 0.
 813:../uvc.c      **** 								 Data0 = 0;
 814:../uvc.c      **** 							 else if(Data0 >2)
 815:../uvc.c      **** 								 Data0 = 1;
 816:../uvc.c      **** 
 817:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 818:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 819:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 820:../uvc.c      **** 
 821:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 823:../uvc.c      **** 							 break;
 824:../uvc.c      **** 					 	 case BLCCtlID0:
 825:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 826:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 827:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 828:../uvc.c      **** 							 {
 829:../uvc.c      **** 								 if(Data0 < 3){
 830:../uvc.c      **** 					 				 Data0 += 4;
 831:../uvc.c      **** 					 			 }else{
 832:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 833:../uvc.c      **** 									Data0 = 4; //set to default.
 834:../uvc.c      **** 					 			 }
 835:../uvc.c      **** 					 		 }
 836:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 837:../uvc.c      **** 							 dataIdx = 0;
 838:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 839:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 840:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 841:../uvc.c      **** 
 842:../uvc.c      **** 					 		 break;
 843:../uvc.c      **** 						 default:
 844:../uvc.c      **** 							 dataIdx = 0;
 845:../uvc.c      **** 
 846:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 847:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 848:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 849:../uvc.c      **** 
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 852:../uvc.c      **** 							 break;
 853:../uvc.c      **** 					 }
 854:../uvc.c      **** 			   }else{
 855:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 856:../uvc.c      **** 			   }
 857:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 858:../uvc.c      **** 			  CyU3PDebugPrint (4, "The setup sensor value %d, 0x%x 0x%x 0x%x 0x%x %d\r\n", CtrlID, readCount
 859:../uvc.c      **** #endif
 860:../uvc.c      **** 
 861:../uvc.c      **** 			  break;
 862:../uvc.c      **** 		  default:
 863:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 864:../uvc.c      **** 			  break;
 865:../uvc.c      **** 		 }
 866:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 867:../uvc.c      **** }
 868:../uvc.c      **** /************** CT control requests handler *************************/
 869:../uvc.c      **** #define EXLIMIT  200  //shutter value limit in 30 fps
 870:../uvc.c      **** 
 871:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 872:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = !CY_U3P_SUCCESS;
 873:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
 874:../uvc.c      ****     uint16_t readCount;
 875:../uvc.c      ****     uint8_t RegAdd0, RegAdd1, Data0, Data1, Len;
 876:../uvc.c      ****     uint16_t diff, value, diffRd;
 877:../uvc.c      ****     uint8_t i, shutter, index;
 878:../uvc.c      ****     diff = 0xffff;
 879:../uvc.c      ****     shutter = 1;
 880:../uvc.c      ****     index = 1;
 881:../uvc.c      **** 
 882:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 883:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 884:../uvc.c      ****     RegAdd1 = CTCtrlParArry[CtrlID][1];
 885:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 886:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 887:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 888:../uvc.c      ****     CyU3PDebugPrint (4, "The cur sensor value(CT) %d 0x%x 0x%x\r\n", CtrlID, CTCtrlParArry[CtrlID][
 889:../uvc.c      **** #endif
 890:../uvc.c      ****     reqData = bRequest;
 891:../uvc.c      **** 
 892:../uvc.c      ****     switch (bRequest)
 893:../uvc.c      **** 		 {
 894:../uvc.c      **** 
 895:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_LEN_REQ: /* the length of get length request always setting to 2 */
 896:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 897:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 898:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 899:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 900:../uvc.c      **** 			  break;
 901:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current value. */
 902:../uvc.c      **** 
 903:../uvc.c      **** 			 switch(CtrlID)
 904:../uvc.c      **** 			 {
 905:../uvc.c      **** 				 default:
 906:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 907:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 908:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 909:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 910:../uvc.c      **** 					 sendData = glEp0Buffer[0];
 911:../uvc.c      **** 					 break;
 912:../uvc.c      **** 			 }
 913:../uvc.c      **** 
 914:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 915:../uvc.c      **** 
 916:../uvc.c      **** #ifdef USB_DEBUG_PRINT
 917:../uvc.c      **** 			  CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[
 918:../uvc.c      **** #endif
 919:../uvc.c      **** 			  break;
 920:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MIN_REQ:
 921:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 922:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 923:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 924:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 925:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 926:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 927:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 928:../uvc.c      **** 			  break;
 929:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_MAX_REQ:
 930:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 931:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 932:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 933:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 934:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 935:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 936:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 937:../uvc.c      **** 			  break;
 938:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_RES_REQ:
 939:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 940:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 941:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 942:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 943:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 944:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 945:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 946:../uvc.c      **** 			  break;
 947:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_INFO_REQ:
 948:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 949:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 950:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 951:../uvc.c      **** 			  Len = 1;
 952:../uvc.c      **** 			  break;
 953:../uvc.c      **** 		 case CY_FX_USB_UVC_GET_DEF_REQ:
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 957:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 958:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 960:../uvc.c      **** 			  sendData = glEp0Buffer[0];
 961:../uvc.c      **** 			  break;
 962:../uvc.c      **** 		 case CY_FX_USB_UVC_SET_CUR_REQ:
 963:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 964:../uvc.c      **** 			  glEp0Buffer, &readCount);
 965:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 966:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 967:../uvc.c      **** 			  value = Data1;
 968:../uvc.c      **** 
 969:../uvc.c      **** 			  switch(CtrlID)
 970:../uvc.c      **** 			  {
 971:../uvc.c      **** 		  	      case AutoExMCtlID1:
 972:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, gl
 973:../uvc.c      **** 
 974:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 975:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 976:../uvc.c      **** 				    getData = glEp0Buffer[0];
 977:../uvc.c      **** 		  		    //CyU3PDebugPrint (4, "The Ex Mode set value(CT) %d %d!\r\n", CtrlID, CTCtrlParArry[CtrlI
 978:../uvc.c      **** 		  		    switch (getData){
 979:../uvc.c      **** 						case 1:
 980:../uvc.c      **** 							setIrisauto(cmdQuptr, 0); //set Iris being manual.
 981:../uvc.c      **** 							break;
 982:../uvc.c      **** 						case 2:
 983:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 984:../uvc.c      **** 							dataIdx = 0;
 985:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 986:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 987:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 988:../uvc.c      **** 				  		    setIrisauto(cmdQuptr, 1); //set Iris being auto.
 989:../uvc.c      **** 
 990:../uvc.c      **** 							break;
 991:../uvc.c      **** 						case 4:
 992:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
 993:../uvc.c      **** 							break;
 994:../uvc.c      **** 						case 8:
 995:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 996:../uvc.c      **** 			  		    	dataIdx = 0;
 997:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 998:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 999:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1000:../uvc.c      **** 			  		    	setIrisauto(cmdQuptr, 0); //set Iris being manual.
1001:../uvc.c      **** 							break;
1002:../uvc.c      **** 		  		    }
1003:../uvc.c      **** #if 0
1004:../uvc.c      **** 				    if(getData == 2 || getData == 8){//if exposure mode is auto or aperture priority
1005:../uvc.c      **** 		  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
1006:../uvc.c      **** 						  dataIdx = 0;
1007:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1008:../uvc.c      **** 						  cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
1009:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1010:../uvc.c      **** 		  		    }
1011:../uvc.c      **** 		  		    if(getData == 2 || getData == 4){//if exposure mode is auto or exprosue priority
1012:../uvc.c      **** 		  		    	setIrisauto(cmdQuptr, 1); //set Iris being auto.
1013:../uvc.c      **** 		  		    }
1014:../uvc.c      **** #endif
1015:../uvc.c      **** 				    break;
1016:../uvc.c      **** 
1017:../uvc.c      **** 			  	  case ExTmACtlID3:
1018:../uvc.c      **** 			  		//CyU3PDebugPrint (4, "The Ex Time value(CT) %d 0x%x 0x%x 0x%x 0x%x, %d!\r\n", CtrlID, glEp0
1019:../uvc.c      **** 
1020:../uvc.c      **** 					  value = (value << 8)|Data0;
1021:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
1022:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
1023:../uvc.c      **** 					  {
1024:../uvc.c      **** 						  for(i = 0; i < 8; i++)//find closest shutter No.
1025:../uvc.c      **** 						  {
1026:../uvc.c      **** 							if(value > ShutValueArry[i]){
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
1028:../uvc.c      **** 							}else{
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
1030:../uvc.c      **** 							}
1031:../uvc.c      **** 							  if(diff > diffRd){
1032:../uvc.c      **** 								  diff = diffRd;
1033:../uvc.c      **** 								  index = i;
1034:../uvc.c      **** 							  }
1035:../uvc.c      **** 						  }
1036:../uvc.c      **** 						  shutter = shutter+index;
1037:../uvc.c      **** 
1038:../uvc.c      **** 						  dataIdx = 0;
1039:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1040:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
1041:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1042:../uvc.c      **** 						  //CyU3PDebugPrint (4, "The Ex Time shutter value(CT) %d %d %d %d!\r\n", shutter, index, Shu
1043:../uvc.c      **** 
1044:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
1045:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
1046:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
1047:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
1048:../uvc.c      **** 					  }else{
1049:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1050:../uvc.c      **** 					  }
1051:../uvc.c      **** 					  getData = glEp0Buffer[0];
1052:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1053:../uvc.c      **** 					  break;
1054:../uvc.c      **** 			  	  case IriACtlID7:
1055:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
1056:../uvc.c      **** 					  {
1057:../uvc.c      **** 							 dataIdx = 0;
1058:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1059:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
1060:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1061:../uvc.c      **** 							 //CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the com
1062:../uvc.c      **** 
1063:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
1064:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
1065:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
1066:../uvc.c      **** 					  }else{
1067:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
1068:../uvc.c      **** 					  }
1069:../uvc.c      **** 					  getData = glEp0Buffer[0];
1070:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1071:../uvc.c      **** 
1072:../uvc.c      **** 					  break;
1073:../uvc.c      **** 			  	  case ZmOpRCtlID10:
1074:../uvc.c      **** 					  getData = glEp0Buffer[0];
1075:../uvc.c      **** 					  getData1 = glEp0Buffer[1];
1076:../uvc.c      **** #if 1
1077:../uvc.c      **** 					  dataIdx = 0;
1078:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1079:../uvc.c      **** 					  if(getData == 1)
1080:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
1081:../uvc.c      **** 					  else if(getData == 0xff)
1082:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
1083:../uvc.c      **** 					  else
1084:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
1085:../uvc.c      **** 					  //dataIdx++;
1086:../uvc.c      **** 					  //cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx); //for temp implementation for stop z
1087:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1088:../uvc.c      **** #endif
1089:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
1090:../uvc.c      **** 					  break;
1091:../uvc.c      **** 
1092:../uvc.c      **** 			  	  default:
1093:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
1094:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
1095:../uvc.c      **** 			  		 break;
1096:../uvc.c      **** 			  }
1097:../uvc.c      **** 			  break;
1098:../uvc.c      **** 		  default:
1099:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
1100:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
1101:../uvc.c      **** 			  break;
1102:../uvc.c      **** 		 }
1103:../uvc.c      **** 	//CyU3PDebugPrint (4, "The get sensor value(CT) %d 0x%x 0x%x, %d %d\r\n", CtrlID, CTCtrlParArry[Ct
1104:../uvc.c      **** 
1105:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
1106:../uvc.c      **** }
1107:../uvc.c      **** 
1108:../uvc.c      **** /************** send default parameters to camera at the beginning **************/
1109:../uvc.c      **** void CamDefSet(void) //it's not called at anywhere right now
1110:../uvc.c      **** {
1111:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
1112:../uvc.c      ****     uint8_t RegAdd, devAdd, Data;
1113:../uvc.c      ****     uint8_t CtrlID, Data0, Data1;
1114:../uvc.c      **** 
1115:../uvc.c      ****     CtrlID = BrgtCtlID1;
1116:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
1117:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1118:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
1119:../uvc.c      ****     Data1 = Data0;
1120:../uvc.c      **** 
1121:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
1122:../uvc.c      ****     if(Data1&0x80){
1123:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
1124:../uvc.c      ****     }else{
1125:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
1126:../uvc.c      ****     }
1127:../uvc.c      ****     Data0 = (Data0 << 2);
1128:../uvc.c      **** 
1129:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
1130:../uvc.c      **** 
1131:../uvc.c      **** 	RegAdd = CtrlParArry[CtrlID][0];
1132:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
1133:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1134:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
1135:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
1136:../uvc.c      **** 
1137:../uvc.c      ****     CtrlID = ConsCtlID2;
1138:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1139:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1140:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1141:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
1142:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1143:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1144:../uvc.c      **** 
1145:../uvc.c      ****     CtrlID = HueCtlID5;
1146:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1147:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1148:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1149:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
1154:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
1155:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
1156:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
1157:../uvc.c      **** 			(Data-GREEN_BASE), (Data-MAGENTA_BASE), (Data-YELLOW_BASE), (Data-CYAN_BASE), (Data-RED_BASE), (
1158:../uvc.c      **** 
1159:../uvc.c      ****     CtrlID = SaturCtlID6;
1160:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1161:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
1164:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
1165:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1166:../uvc.c      **** 
1167:../uvc.c      ****     CtrlID = ShapCtlID7;
1168:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][0];
1169:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
1170:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
1171:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
1172:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
1173:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
1174:../uvc.c      **** 
1175:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
1176:../uvc.c      **** 	//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);//set event of the command av
1177:../uvc.c      **** 	return;
1178:../uvc.c      **** }
1179:../uvc.c      **** 
1180:../uvc.c      **** /* Add the UVC packet header to the top of the specified DMA buffer. */
1181:../uvc.c      **** void
1182:../uvc.c      **** CyFxUVCAddHeader (
1183:../uvc.c      ****         uint8_t *buffer_p,              /* Buffer pointer */
1184:../uvc.c      ****         uint8_t frameInd                /* EOF or normal frame indication */
1185:../uvc.c      ****         )
1186:../uvc.c      **** {
1187:../uvc.c      ****     /* Copy header to buffer */
1188:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
1189:../uvc.c      **** 
1190:../uvc.c      ****     /* The EOF flag needs to be set if this is the last packet for this video frame. */
1191:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
1192:../uvc.c      ****     {
1193:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
1194:../uvc.c      ****     }
1195:../uvc.c      **** }
1196:../uvc.c      **** 
1197:../uvc.c      **** 
1198:../uvc.c      **** /* Application Error Handler */
1199:../uvc.c      **** void
1200:../uvc.c      **** CyFxAppErrorHandler (
1201:../uvc.c      ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
1202:../uvc.c      ****         )
1203:../uvc.c      **** {
1204:../uvc.c      ****     /* This function is hit when we have hit a critical application error. This is not
1205:../uvc.c      ****        expected to happen, and the current implementation of this function does nothing
1206:../uvc.c      ****        except stay in a loop printing error messages through the UART port.
1207:../uvc.c      **** 
1208:../uvc.c      ****        This function can be modified to take additional error handling actions such
1209:../uvc.c      ****        as cycling the USB connection or performing a warm reset.
1210:../uvc.c      ****      */
1211:../uvc.c      ****     for (;;)
1212:../uvc.c      ****     {
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
1215:../uvc.c      ****     }
1216:../uvc.c      **** }
1217:../uvc.c      **** 
1218:../uvc.c      **** /* This function performs the operations for a Video Streaming Abort.
1219:../uvc.c      ****    This is called every time there is a USB reset, suspend or disconnect event.
1220:../uvc.c      ****  */
1221:../uvc.c      **** static void
1222:../uvc.c      **** CyFxUVCApplnAbortHandler (
1223:../uvc.c      ****         void)
1224:../uvc.c      **** {
1225:../uvc.c      **** 	uint32_t flag;
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
1227:../uvc.c      **** 	{
1228:../uvc.c      ****         /* Clear the Video Stream Request Event */
1229:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
1230:../uvc.c      **** 
1231:../uvc.c      ****         /* Set Video Stream Abort Event */
1232:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
1233:../uvc.c      **** 	}
1234:../uvc.c      **** }
1235:../uvc.c      **** 
1236:../uvc.c      **** /* This is the Callback function to handle the USB Events */
1237:../uvc.c      **** static void
1238:../uvc.c      **** CyFxUVCApplnUSBEventCB (
1239:../uvc.c      ****         CyU3PUsbEventType_t evtype,  /* Event type */
1240:../uvc.c      ****         uint16_t             evdata  /* Event data */
1241:../uvc.c      ****         )
1242:../uvc.c      **** {
1243:../uvc.c      ****     switch (evtype)
1244:../uvc.c      ****     {
1245:../uvc.c      ****         case CY_U3P_USB_EVENT_RESET:
1246:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
1247:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1248:../uvc.c      ****             gpif_initialized = 0;
1249:../uvc.c      ****             streamingStarted = CyFalse;
1250:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1251:../uvc.c      ****             break;
1252:../uvc.c      **** 
1253:../uvc.c      ****         case CY_U3P_USB_EVENT_SUSPEND:
1254:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
1255:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1256:../uvc.c      ****             gpif_initialized = 0;
1257:../uvc.c      ****             streamingStarted = CyFalse;
1258:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1259:../uvc.c      ****             break;
1260:../uvc.c      **** 
1261:../uvc.c      ****         case CY_U3P_USB_EVENT_DISCONNECT:
1262:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
1263:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
1264:../uvc.c      ****             gpif_initialized = 0;
1265:../uvc.c      ****             isUsbConnected = CyFalse;
1266:../uvc.c      ****             streamingStarted = CyFalse;
1267:../uvc.c      ****             CyFxUVCApplnAbortHandler ();
1268:../uvc.c      ****             break;
1269:../uvc.c      **** 
1270:../uvc.c      **** #ifdef BACKFLOW_DETECT
1271:../uvc.c      ****         case CY_U3P_USB_EVENT_EP_UNDERRUN:
1272:../uvc.c      ****             CyU3PDebugPrint (4, "CY_U3P_USB_EVENT_EP_UNDERRUN encountered...\r\n");
1273:../uvc.c      ****             break;
1274:../uvc.c      **** #endif
1275:../uvc.c      **** 
1276:../uvc.c      ****         default:
1277:../uvc.c      ****             break;
1278:../uvc.c      ****     }
1279:../uvc.c      **** }
1280:../uvc.c      **** 
1281:../uvc.c      **** /* Callback to handle the USB Setup Requests and UVC Class events */
1282:../uvc.c      **** static CyBool_t
1283:../uvc.c      **** CyFxUVCApplnUSBSetupCB (
1284:../uvc.c      ****         uint32_t setupdat0, /* SETUP Data 0 */
1285:../uvc.c      ****         uint32_t setupdat1  /* SETUP Data 1 */
1286:../uvc.c      ****         )
1287:../uvc.c      **** {
1288:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
1289:../uvc.c      ****     uint32_t status;
1290:../uvc.c      **** 
1291:../uvc.c      ****     /* Obtain Request Type and Request */
1292:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
1293:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
1294:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
1295:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
1296:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
1297:../uvc.c      **** 
1298:../uvc.c      ****     /* Check for UVC Class Requests */
1299:../uvc.c      ****     switch (bmReqType)
1300:../uvc.c      ****     {
1301:../uvc.c      ****         case CY_FX_USB_UVC_GET_REQ_TYPE:
1302:../uvc.c      ****         case CY_FX_USB_UVC_SET_REQ_TYPE:
1303:../uvc.c      ****             /* UVC Specific requests are handled in the EP0 thread. */
1304:../uvc.c      ****             switch (wIndex & 0xFF)
1305:../uvc.c      ****             {
1306:../uvc.c      ****                 case CY_FX_UVC_CONTROL_INTERFACE:
1307:../uvc.c      ****                     {
1308:../uvc.c      ****                         uvcHandleReq = CyTrue;
1309:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
1310:../uvc.c      ****                                 CYU3P_EVENT_OR);
1311:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1312:../uvc.c      ****                         {
1313:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
1314:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1315:../uvc.c      ****                         }
1316:../uvc.c      ****                     }
1317:../uvc.c      ****                     break;
1318:../uvc.c      **** 
1319:../uvc.c      ****                 case CY_FX_UVC_STREAM_INTERFACE:
1320:../uvc.c      ****                     {
1321:../uvc.c      ****                         uvcHandleReq = CyTrue;
1322:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
1323:../uvc.c      ****                                 CYU3P_EVENT_OR);
1324:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
1325:../uvc.c      ****                         {
1326:../uvc.c      ****                             /* Error handling */
1327:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
1328:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
1329:../uvc.c      ****                         }
1330:../uvc.c      ****                     }
1331:../uvc.c      ****                     break;
1332:../uvc.c      **** 
1333:../uvc.c      ****                 default:
1334:../uvc.c      ****                     break;
1335:../uvc.c      ****             }
1336:../uvc.c      ****             break;
1337:../uvc.c      **** 
1338:../uvc.c      ****         case CY_FX_USB_SET_INTF_REQ_TYPE:
1339:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
1340:../uvc.c      ****             {
1341:../uvc.c      ****             	/* MAC OS sends Set Interface Alternate Setting 0 command after
1342:../uvc.c      ****             	 * stopping to stream. This application needs to stop streaming. */
1343:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
1344:../uvc.c      ****                 {
1345:../uvc.c      ****                 	/* Stop GPIF state machine to stop data transfers through FX3 */
1346:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
1347:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
1348:../uvc.c      ****                     gpif_initialized = 0;
1349:../uvc.c      ****                     streamingStarted = CyFalse;
1350:../uvc.c      ****                     /* Place the EP in NAK mode before cleaning up the pipe. */
1351:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1352:../uvc.c      ****                     CyU3PBusyWait (100);
1353:../uvc.c      **** 
1354:../uvc.c      ****                     /* Reset and flush the endpoint pipe. */
1355:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1356:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1357:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1358:../uvc.c      ****                     CyU3PBusyWait (100);
1359:../uvc.c      **** 
1360:../uvc.c      ****                     /* Clear the stall condition and sequence numbers. */
1361:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1362:../uvc.c      ****                     uvcHandleReq = CyTrue;
1363:../uvc.c      ****                     /* Complete Control request handshake */
1364:../uvc.c      ****                     CyU3PUsbAckSetup ();
1365:../uvc.c      ****                     /* Indicate stop streaming to main thread */
1366:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
1367:../uvc.c      ****                     CyFxUVCApplnAbortHandler ();
1368:../uvc.c      **** 
1369:../uvc.c      ****                 }
1370:../uvc.c      ****             }
1371:../uvc.c      ****             break;
1372:../uvc.c      **** 
1373:../uvc.c      ****         case CY_U3P_USB_TARGET_ENDPT:
1374:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
1375:../uvc.c      ****             {
1376:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
1377:../uvc.c      ****                 {
1378:../uvc.c      ****                 	/* Windows OS sends Clear Feature Request after it stops streaming,
1379:../uvc.c      ****                 	 * however MAC OS sends clear feature request right after it sends a
1380:../uvc.c      ****                 	 * Commit -> SET_CUR request. Hence, stop streaming only of streaming
1381:../uvc.c      ****                 	 * has started. */
1382:../uvc.c      ****                     if (streamingStarted == CyTrue)
1383:../uvc.c      ****                     {
1384:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
1385:../uvc.c      **** 
1386:../uvc.c      ****                         /* Disable the GPIF state machine. */
1387:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
1388:../uvc.c      ****                         gpif_initialized = 0;
1389:../uvc.c      ****                         streamingStarted = CyFalse;
1390:../uvc.c      **** 
1391:../uvc.c      ****                         /* Place the EP in NAK mode before cleaning up the pipe. */
1392:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
1393:../uvc.c      ****                         CyU3PBusyWait (100);
1394:../uvc.c      **** 
1395:../uvc.c      ****                         /* Reset and flush the endpoint pipe. */
1396:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
1397:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
1398:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
1399:../uvc.c      ****                         CyU3PBusyWait (100);
1400:../uvc.c      **** 
1401:../uvc.c      ****                         /* Clear the stall condition and sequence numbers. */
1402:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
1403:../uvc.c      **** 
1404:../uvc.c      ****                         uvcHandleReq = CyTrue;
1405:../uvc.c      ****                         /* Complete Control request handshake */
1406:../uvc.c      ****                         CyU3PUsbAckSetup ();
1407:../uvc.c      ****                         /* Indicate stop streaming to main thread */
1408:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
1409:../uvc.c      ****                         CyFxUVCApplnAbortHandler ();
1410:../uvc.c      ****                     }
1411:../uvc.c      ****                     else
1412:../uvc.c      ****                     {
1413:../uvc.c      ****                         uvcHandleReq = CyTrue;
1414:../uvc.c      ****                         CyU3PUsbAckSetup ();
1415:../uvc.c      ****                     }
1416:../uvc.c      ****                 }
1417:../uvc.c      ****             }
1418:../uvc.c      ****             break;
1419:../uvc.c      **** 
1420:../uvc.c      ****         default:
1421:../uvc.c      ****             break;
1422:../uvc.c      ****     }
1423:../uvc.c      **** 
1424:../uvc.c      ****     /* Return status of request handling to the USB driver */
1425:../uvc.c      ****     return uvcHandleReq;
1426:../uvc.c      **** }
1427:../uvc.c      **** 
1428:../uvc.c      **** #define CyFxUvcAppInterInCallback 0  //no callback function of the interrupt status endpoint
1429:../uvc.c      **** 
1430:../uvc.c      **** /* DMA callback providing notification when each buffer has been sent out to the USB host.
1431:../uvc.c      ****  * This is used to track whether all of the data has been sent out.
1432:../uvc.c      ****  */
1433:../uvc.c      **** void
1434:../uvc.c      **** CyFxUvcApplnDmaCallback (
1435:../uvc.c      ****         CyU3PDmaMultiChannel *multiChHandle,
1436:../uvc.c      ****         CyU3PDmaCbType_t      type,
1437:../uvc.c      ****         CyU3PDmaCBInput_t    *input
1438:../uvc.c      ****         )
1439:../uvc.c      **** {
1440:../uvc.c      ****    // CyU3PDmaBuffer_t    produced_buffer;
1441:../uvc.c      **** #if 1
1442:../uvc.c      ****     CyU3PReturnStatus_t status;
1443:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1444:../uvc.c      ****     {
1445:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
1446:../uvc.c      ****             {
1447:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
1448:../uvc.c      ****                 fb++;
1449:../uvc.c      ****             }
1450:../uvc.c      ****             else
1451:../uvc.c      ****             {
1452:../uvc.c      ****                 /* If we have a partial buffer, this is guaranteed to be the end of the video frame
1453:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
1454:../uvc.c      ****                 pb++;
1455:../uvc.c      ****                 pbc = input->buffer_p.count;
1456:../uvc.c      ****                // hitFV = CyTrue;
1457:../uvc.c      ****             }
1458:../uvc.c      **** 
1459:../uvc.c      ****             /* Commit the updated DMA buffer to the USB endpoint. */
1460:../uvc.c      ****             prodCount++;
1461:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
1462:../uvc.c      ****             		input->buffer_p.count + CY_FX_UVC_MAX_HEADER, 0);
1463:../uvc.c      ****             //CyU3PDebugPrint(1,"\r\n %d",input->buffer_p.count);
1464:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
1465:../uvc.c      ****             {
1466:../uvc.c      ****                 prodCount--;
1467:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
1468:../uvc.c      ****                         status, input->buffer_p.count, prodCount - consCount);
1469:../uvc.c      ****             }
1470:../uvc.c      ****     }
1471:../uvc.c      **** #endif
1472:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
1473:../uvc.c      ****     {
1474:../uvc.c      ****         consCount++;
1475:../uvc.c      ****         streamingStarted = CyTrue;
1476:../uvc.c      ****     }
1477:../uvc.c      **** }
1478:../uvc.c      **** 
1479:../uvc.c      **** /*
1480:../uvc.c      ****  * This function is called from the GPIF callback when we have reached the end of a video frame.
1481:../uvc.c      ****  * The DMA buffer containing the last part of the frame may not have been committed, and need to
1482:../uvc.c      ****  * be manually wrapped up. This function uses the current GPIF state ID to identify the socket on
1483:../uvc.c      ****  * which this last buffer is pending, and then uses the CyU3PDmaMultiChannelSetWrapUp function
1484:../uvc.c      ****  * to commit the buffer.
1485:../uvc.c      ****  */
1486:../uvc.c      **** static uint8_t
1487:../uvc.c      **** CyFxUvcAppCommitEOF (
1488:../uvc.c      ****         CyU3PDmaMultiChannel *handle,           /* Handle to DMA channel. */
1489:../uvc.c      ****         uint8_t stateId                         /* Current GPIF state ID. */
1490:../uvc.c      ****         )
1491:../uvc.c      **** {
1492:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
1493:../uvc.c      ****     uint8_t socket = 0xFF;      /*  Invalid value. */
1494:../uvc.c      **** 
1495:../uvc.c      ****     /* Verify that the current state is a terminal state for the GPIF state machine. */
1496:../uvc.c      **** 
1497:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
1498:../uvc.c      ****     {
1499:../uvc.c      ****         switch (stateId)
1500:../uvc.c      ****         {
1501:../uvc.c      ****             case FULL_BUF_IN_SCK0:
1502:../uvc.c      ****             case FULL_BUF_IN_SCK1:
1503:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1504:../uvc.c      ****                 break;
1505:../uvc.c      **** 
1506:../uvc.c      ****             case PARTIAL_BUF_IN_SCK0:
1507:../uvc.c      ****                 socket = 0;
1508:../uvc.c      ****                 break;
1509:../uvc.c      **** 
1510:../uvc.c      ****             case PARTIAL_BUF_IN_SCK1:
1511:../uvc.c      ****                 socket = 1;
1512:../uvc.c      ****                 break;
1513:../uvc.c      **** 
1514:../uvc.c      ****             default:
1515:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1516:../uvc.c      ****                 /* Unexpected current state. Return error. */
1517:../uvc.c      ****                 return 1;
1518:../uvc.c      ****         }
1519:../uvc.c      ****     }
1520:../uvc.c      **** 
1521:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
1522:../uvc.c      ****     {
1523:../uvc.c      ****         switch (stateId)
1524:../uvc.c      ****         {
1525:../uvc.c      **** #ifndef CAM720
1526:../uvc.c      **** #ifdef GPIFIIM
1527:../uvc.c      ****             case 13:
1528:../uvc.c      ****             case 24:
1529:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1530:../uvc.c      ****                 break;
1531:../uvc.c      **** 
1532:../uvc.c      ****             case 8:
1533:../uvc.c      ****                 socket = 0;
1534:../uvc.c      ****                 break;
1535:../uvc.c      **** 
1536:../uvc.c      ****             case 20:
1537:../uvc.c      ****                 socket = 1;
1538:../uvc.c      ****                 break;
1539:../uvc.c      **** #else
1540:../uvc.c      ****             case 11:
1541:../uvc.c      ****             case 18:
1542:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1543:../uvc.c      ****                 break;
1544:../uvc.c      **** 
1545:../uvc.c      ****             case 8:
1546:../uvc.c      ****                 socket = 0;
1547:../uvc.c      ****                 break;
1548:../uvc.c      **** 
1549:../uvc.c      ****             case 15:
1550:../uvc.c      ****                 socket = 1;
1551:../uvc.c      ****                 break;
1552:../uvc.c      **** #endif
1553:../uvc.c      **** #else
1554:../uvc.c      ****             case 11:
1555:../uvc.c      ****             case 18:
1556:../uvc.c      ****                 /* Buffer is already full and would have been committed. Do nothing. */
1557:../uvc.c      ****                 break;
1558:../uvc.c      **** 
1559:../uvc.c      ****             case 8:
1560:../uvc.c      ****                 socket = 0;
1561:../uvc.c      ****                 break;
1562:../uvc.c      **** 
1563:../uvc.c      ****             case 15:
1564:../uvc.c      ****                 socket = 1;
1565:../uvc.c      ****                 break;
1566:../uvc.c      **** 
1567:../uvc.c      **** #endif
1568:../uvc.c      ****              default:
1569:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
1570:../uvc.c      ****                 /* Unexpected current state. Return error. */
1571:../uvc.c      ****                return 1;
1572:../uvc.c      ****         }
1573:../uvc.c      ****     }
1574:../uvc.c      **** 
1575:../uvc.c      ****     if (socket != 0xFF)
1576:../uvc.c      ****     {
1577:../uvc.c      ****         /* We have a partial buffer. Commit the buffer manually. The Wrap Up API, here, helps produ
1578:../uvc.c      ****            partially filled buffer on the producer side. This action will cause CyU3PDmaMultiChanne
1579:../uvc.c      ****            in the UVCAppThread_Entry function to succeed one more time with less than full producer
1580:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
1581:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
1582:../uvc.c      ****         {
1583:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
1584:../uvc.c      ****             CyFxAppErrorHandler (apiRetStatus);
1585:../uvc.c      ****         }
1586:../uvc.c      ****     }
1587:../uvc.c      **** 
1588:../uvc.c      ****     return 0;
1589:../uvc.c      **** }
1590:../uvc.c      **** 
1591:../uvc.c      **** /* GpifCB callback function is invoked when FV triggers GPIF interrupt */
1592:../uvc.c      **** void
1593:../uvc.c      **** CyFxGpifCB (
1594:../uvc.c      ****         CyU3PGpifEventType event,
1595:../uvc.c      ****         uint8_t currentState
1596:../uvc.c      ****         )
1597:../uvc.c      **** {
1598:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
1599:../uvc.c      ****     {
1600:../uvc.c      ****         hitFV = CyTrue;
1601:../uvc.c      ****         if (0||CyFxUvcAppCommitEOF (&glChHandleUVCStream, currentState) != CY_U3P_SUCCESS) //temp f
1602:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
1603:../uvc.c      ****     }
1604:../uvc.c      **** }
1605:../uvc.c      **** 
1606:../uvc.c      **** /* This function initializes the Debug Module for the UVC Application */
1607:../uvc.c      **** static void
1608:../uvc.c      **** CyFxUVCApplnDebugInit (
1609:../uvc.c      ****         void)
1610:../uvc.c      **** {
1611:../uvc.c      ****     CyU3PUartConfig_t uartConfig;
1612:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
1613:../uvc.c      **** 
1614:../uvc.c      ****     /* Initialize the UART for printing debug messages */
1615:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
1616:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1617:../uvc.c      ****     {
1618:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
1619:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1620:../uvc.c      ****     }
1621:../uvc.c      **** 
1622:../uvc.c      ****     /* Set UART Configuration */
1623:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
1624:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
1625:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
1626:../uvc.c      ****     uartConfig.txEnable = CyTrue;
1627:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
1628:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
1629:../uvc.c      ****     uartConfig.isDma    = CyTrue;
1630:../uvc.c      **** 
1631:../uvc.c      ****     /* Set the UART configuration */
1632:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
1633:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1634:../uvc.c      ****     {
1635:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1636:../uvc.c      ****     }
1637:../uvc.c      **** 
1638:../uvc.c      ****     /* Set the UART transfer */
1639:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
1640:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1641:../uvc.c      ****     {
1642:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1643:../uvc.c      ****     }
1644:../uvc.c      **** 
1645:../uvc.c      ****     /* Initialize the Debug logger module. */
1646:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
1647:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1648:../uvc.c      ****     {
1649:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1650:../uvc.c      ****     }
1651:../uvc.c      **** 
1652:../uvc.c      ****     /* Disable log message headers. */
1653:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
1654:../uvc.c      **** }
1655:../uvc.c      **** 
1656:../uvc.c      **** /* I2C initialization. */
1657:../uvc.c      **** static void
1658:../uvc.c      **** CyFxUVCApplnI2CInit (void)
1659:../uvc.c      **** {
1660:../uvc.c      ****     CyU3PI2cConfig_t i2cConfig;;
1661:../uvc.c      ****     CyU3PReturnStatus_t status;
1662:../uvc.c      **** 
1663:../uvc.c      ****     status = CyU3PI2cInit ();
1664:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
1665:../uvc.c      ****     {
1666:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
1667:../uvc.c      ****         CyFxAppErrorHandler (status);
1668:../uvc.c      ****     }
1669:../uvc.c      **** 
1670:../uvc.c      ****     /*  Set I2C Configuration */
1671:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
1672:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
1673:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
1674:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
1675:../uvc.c      **** 
1676:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
1677:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
1678:../uvc.c      ****     {
1679:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
1680:../uvc.c      ****         CyFxAppErrorHandler (status);
1681:../uvc.c      ****     }
1682:../uvc.c      **** }
1683:../uvc.c      **** 
1684:../uvc.c      **** #ifdef BACKFLOW_DETECT
1685:../uvc.c      **** static void CyFxUvcAppPibCallback (
1686:../uvc.c      ****         CyU3PPibIntrType cbType,
1687:../uvc.c      ****         uint16_t cbArg)
1688:../uvc.c      **** {
1689:../uvc.c      ****     if ((cbType == CYU3P_PIB_INTR_ERROR) && ((cbArg == 0x1005) || (cbArg == 0x1006)))
1690:../uvc.c      ****     {
1691:../uvc.c      ****         if (!back_flow_detected)
1692:../uvc.c      ****         {
1693:../uvc.c      ****             CyU3PDebugPrint (4, "Backflow detected...\r\n");
1694:../uvc.c      ****             back_flow_detected = 1;
1695:../uvc.c      ****         }
1696:../uvc.c      ****     }
1697:../uvc.c      **** }
1698:../uvc.c      **** #endif
1699:../uvc.c      **** 
1700:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1701:../uvc.c      **** static void
1702:../uvc.c      **** CyFxUvcAppDebugCallback (
1703:../uvc.c      ****         CyU3PDmaChannel   *handle,
1704:../uvc.c      ****         CyU3PDmaCbType_t   type,
1705:../uvc.c      ****         CyU3PDmaCBInput_t *input)
1706:../uvc.c      **** {
1707:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
1708:../uvc.c      ****     {
1709:../uvc.c      ****         /* Data has been received. Notify the EP0 thread which handles the debug commands as well. 
1710:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_USB_DEBUG_CMD_EVENT, CYU3P_EVENT_OR);
1711:../uvc.c      ****     }
1712:../uvc.c      **** }
1713:../uvc.c      **** #endif
1714:../uvc.c      **** 
1715:../uvc.c      **** #if 0
1716:../uvc.c      **** static void CyFxAppIntEpCb(
1717:../uvc.c      **** 		CyU3PUsbEpEvtType evType,
1718:../uvc.c      **** 		CyU3PUSBSpeed_t  usbSpeed,
1719:../uvc.c      **** 		uint8_t  ebNum)
1720:../uvc.c      **** 		{
1721:../uvc.c      **** 			//CyBool_t value;
1722:../uvc.c      **** 			if((evType == 1)&&(ebNum == 0x82))
1723:../uvc.c      **** 				CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR); //set sending interrupt sta
1724:../uvc.c      **** 
1725:../uvc.c      **** 			//CyU3PDebugPrint (4, "Interrpt EP event 0x%x, %d, 0x%x\r\n", evType, usbSpeed, ebNum);
1726:../uvc.c      **** 		}
1727:../uvc.c      **** #endif
1728:../uvc.c      **** 
1729:../uvc.c      **** /* This function initializes the USB Module, creates event group,
1730:../uvc.c      ****    sets the enumeration descriptors, configures the Endpoints and
1731:../uvc.c      ****    configures the DMA module for the UVC Application */
1732:../uvc.c      **** static void
1733:../uvc.c      **** CyFxUVCApplnInit (void)
1734:../uvc.c      **** {
1735:../uvc.c      ****     CyU3PDmaMultiChannelConfig_t dmaMultiConfig;
1736:../uvc.c      ****     CyU3PEpConfig_t              endPointConfig;
1737:../uvc.c      ****     CyU3PReturnStatus_t          apiRetStatus;
1738:../uvc.c      ****     CyU3PGpioClock_t             gpioClock;
1739:../uvc.c      ****     CyU3PGpioSimpleConfig_t      gpioConfig;
1740:../uvc.c      ****     CyU3PPibClock_t              pibclock;
1741:../uvc.c      **** 
1742:../uvc.c      ****     CyU3PDmaChannelConfig_t dmaInterConfig; 			//for interrupt endpoint
1743:../uvc.c      ****     //CyU3PDmaMultiChannelConfig_t dmaMultiStillConfig;   //for still image channel
1744:../uvc.c      **** 
1745:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1746:../uvc.c      ****     CyU3PDmaChannelConfig_t channelConfig;
1747:../uvc.c      **** #endif
1748:../uvc.c      **** 
1749:../uvc.c      ****     /* Create UVC event group */
1750:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
1751:../uvc.c      ****     if (apiRetStatus != 0)
1752:../uvc.c      ****     {
1753:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
1754:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1755:../uvc.c      ****     }
1756:../uvc.c      **** 
1757:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
1758:../uvc.c      ****     CyFxUvcAppPTZInit ();
1759:../uvc.c      **** #endif
1760:../uvc.c      **** 
1761:../uvc.c      ****     isUsbConnected = CyFalse;
1762:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
1763:../uvc.c      **** 
1764:../uvc.c      ****     /* Init the GPIO module */
1765:../uvc.c      ****     gpioClock.fastClkDiv = 2;
1766:../uvc.c      ****     gpioClock.slowClkDiv = 2;
1767:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
1768:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
1769:../uvc.c      ****     gpioClock.halfDiv    = 0;
1770:../uvc.c      **** 
1771:../uvc.c      ****     /* Initialize Gpio interface */
1772:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
1773:../uvc.c      ****     if (apiRetStatus != 0)
1774:../uvc.c      ****     {
1775:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
1776:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1777:../uvc.c      ****     }
1778:../uvc.c      **** 
1779:../uvc.c      ****     /* CTL pins are restricted and cannot be configured using I/O matrix configuration function,
1780:../uvc.c      ****      * must use GpioOverride to configure it */
1781:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
1782:../uvc.c      ****     if (apiRetStatus != 0)
1783:../uvc.c      ****     {
1784:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
1785:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1786:../uvc.c      ****     }
1787:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
1788:../uvc.c      ****     if (apiRetStatus != 0)
1789:../uvc.c      ****     {
1790:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
1791:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1792:../uvc.c      ****     }
1793:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
1794:../uvc.c      ****     if (apiRetStatus != 0)
1795:../uvc.c      ****     {
1796:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
1797:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1798:../uvc.c      ****     }
1799:../uvc.c      **** 
1800:../uvc.c      ****     /* SENSOR_RESET_GPIO is the Sensor reset pin */
1801:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1802:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1803:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1804:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1805:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1806:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
1807:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1808:../uvc.c      ****     {
1809:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
1810:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1811:../uvc.c      ****     }
1812:../uvc.c      **** 
1813:../uvc.c      ****     /* SENSOR_POWER_GPIO is the Sensor power on/off pin */
1814:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1815:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
1816:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
1817:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
1818:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
1819:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1820:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
1821:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1822:../uvc.c      ****     {
1823:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
1824:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1825:../uvc.c      ****     }
1826:../uvc.c      **** 
1827:../uvc.c      ****     /* SENSOR_SNAPSHOT_GPIO is the Sensor snap shot button detecting pin */
1828:../uvc.c      **** //    gpioConfig.outValue    = CyFalse; /* set output value is low and the rest of the setting is t
1829:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
1830:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
1831:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
1832:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
1833:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
1834:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
1835:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1836:../uvc.c      ****     {
1837:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
1838:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1839:../uvc.c      ****     }
1840:../uvc.c      **** 
1841:../uvc.c      ****     /* Initialize the P-port. */
1842:../uvc.c      ****     pibclock.clkDiv      = 2;
1843:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
1844:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
1845:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
1846:../uvc.c      **** 
1847:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
1848:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1849:../uvc.c      ****     {
1850:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1851:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1852:../uvc.c      ****     }
1853:../uvc.c      **** 
1854:../uvc.c      ****     /* Setup the Callback to Handle the GPIF INTR event */
1855:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
1856:../uvc.c      **** 
1857:../uvc.c      **** #ifdef BACKFLOW_DETECT
1858:../uvc.c      ****     back_flow_detected = 0;
1859:../uvc.c      ****     CyU3PPibRegisterCallback (CyFxUvcAppPibCallback, CYU3P_PIB_INTR_ERROR);
1860:../uvc.c      **** #endif
1861:../uvc.c      **** 
1862:../uvc.c      ****     /* Image sensor initialization. Reset and then initialize with appropriate configuration. */
1863:../uvc.c      ****     SensorReset ();
1864:../uvc.c      ****     SensorInit ();
1865:../uvc.c      **** 
1866:../uvc.c      ****     /* USB initialization. */
1867:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
1868:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1869:../uvc.c      ****     {
1870:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
1871:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1872:../uvc.c      ****     }
1873:../uvc.c      ****     /* Setup the Callback to Handle the USB Setup Requests */
1874:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
1875:../uvc.c      **** 
1876:../uvc.c      ****     /* Setup the Callback to Handle the USB Events */
1877:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
1878:../uvc.c      **** 
1879:../uvc.c      ****     /* setup the callback to handle the interrupt endpoint events */
1880:../uvc.c      ****     //CyU3PUsbRegisterEpEvtCallback(CyFxAppIntEpCb, 0x000000FF, 0, 0xFF); //0x04 for interrupt endp
1881:../uvc.c      **** 
1882:../uvc.c      ****     /* Register the USB device descriptors with the driver. */
1883:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
1884:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
1885:../uvc.c      **** 
1886:../uvc.c      ****     /* BOS and Device qualifier descriptors. */
1887:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
1888:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
1889:../uvc.c      **** 
1890:../uvc.c      ****     /* Configuration descriptors. */
1891:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
1892:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
1893:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
1894:../uvc.c      **** 
1895:../uvc.c      ****     /* String Descriptors */
1896:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
1897:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
1898:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
1899:../uvc.c      **** 
1900:../uvc.c      ****     /* Configure the status interrupt endpoint.
1901:../uvc.c      ****        Note: This endpoint is not being used by the application as of now. This can be used in case
1902:../uvc.c      ****        UVC device needs to notify the host about any error conditions. A MANUAL_OUT DMA channel
1903:../uvc.c      ****        can be associated with this endpoint and used to send these data packets.
1904:../uvc.c      ****      */
1905:../uvc.c      ****     endPointConfig.enable   = 1;
1906:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
1907:../uvc.c      ****     endPointConfig.pcktSize = 64;
1908:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1909:../uvc.c      ****     endPointConfig.streams  = 0;
1910:../uvc.c      ****     endPointConfig.burstLen = 1;
1911:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
1912:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1913:../uvc.c      ****     {
1914:../uvc.c      ****         /* Error Handling */
1915:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
1916:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1917:../uvc.c      ****     }
1918:../uvc.c      **** 
1919:../uvc.c      ****     /* create a DMA for interrupt endpoint */
1920:../uvc.c      ****     dmaInterConfig.size           = 1024;
1921:../uvc.c      ****     dmaInterConfig.count          = 1;
1922:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
1923:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
1924:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
1925:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
1926:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
1927:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
1928:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1929:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
1930:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
1931:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
1932:../uvc.c      ****             &dmaInterConfig);
1933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1934:../uvc.c      ****     {
1935:../uvc.c      ****         /* Error handling */
1936:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
1937:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1938:../uvc.c      ****     }
1939:../uvc.c      **** 
1940:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
1941:../uvc.c      ****     if (glInterStaBuffer == 0)
1942:../uvc.c      ****     {
1943:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
1944:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
1945:../uvc.c      ****     }
1946:../uvc.c      **** 
1947:../uvc.c      ****     /* Create a DMA Manual channel for sending the video data to the USB host. */
1948:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
1949:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
1950:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
1951:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
1952:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
1953:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
1954:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
1955:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
1956:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
1957:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
1958:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
1959:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
1960:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
1961:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
1962:../uvc.c      ****             &dmaMultiConfig);
1963:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1964:../uvc.c      ****     {
1965:../uvc.c      ****         /* Error handling */
1966:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
1967:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1968:../uvc.c      ****     }
1969:../uvc.c      **** 
1970:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
1971:../uvc.c      ****     /* Configure the endpoints and create DMA channels used by the USB debug interface.
1972:../uvc.c      ****        The command (OUT) endpoint is configured in packet mode and enabled to receive data.
1973:../uvc.c      ****        Once the CY_U3P_DMA_CB_PROD_EVENT callback is received, the received data packet is
1974:../uvc.c      ****        processed and the data is returned through the CyU3PDmaChannelSetupSendBuffer API call.
1975:../uvc.c      ****      */
1976:../uvc.c      **** 
1977:../uvc.c      ****     endPointConfig.enable   = 1;
1978:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
1979:../uvc.c      ****     endPointConfig.pcktSize = 1024;                     /* Use SuperSpeed settings here. */
1980:../uvc.c      ****     endPointConfig.isoPkts  = 0;
1981:../uvc.c      ****     endPointConfig.streams  = 0;
1982:../uvc.c      ****     endPointConfig.burstLen = 1;
1983:../uvc.c      **** 
1984:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_CMD, &endPointConfig);
1985:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1986:../uvc.c      ****     {
1987:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command endpoint config failed, Error code = %d\n", apiRetStatus
1988:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1989:../uvc.c      ****     }
1990:../uvc.c      **** 
1991:../uvc.c      ****     CyU3PUsbSetEpPktMode (CY_FX_EP_DEBUG_CMD, CyTrue);
1992:../uvc.c      **** 
1993:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_DEBUG_RSP, &endPointConfig);
1994:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
1995:../uvc.c      ****     {
1996:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response endpoint config failed, Error code = %d\n", apiRetStatu
1997:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
1998:../uvc.c      ****     }
1999:../uvc.c      **** 
2000:../uvc.c      ****     channelConfig.size           = 1024;
2001:../uvc.c      ****     channelConfig.count          = 1;
2002:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_UIB_SOCKET_PROD_0 | CY_FX_EP_DEBUG_CMD_SOCKET;
2003:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_CPU_SOCKET_CONS;
2004:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2005:../uvc.c      ****     channelConfig.prodHeader     = 0;
2006:../uvc.c      ****     channelConfig.prodFooter     = 0;
2007:../uvc.c      ****     channelConfig.consHeader     = 0;
2008:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2009:../uvc.c      ****     channelConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT;
2010:../uvc.c      ****     channelConfig.cb             = CyFxUvcAppDebugCallback;
2011:../uvc.c      **** 
2012:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugCmdChannel, CY_U3P_DMA_TYPE_MANUAL_IN, &channelCo
2013:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2014:../uvc.c      ****     {
2015:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Command channel create failed, Error code = %d\n", apiRetStatus)
2016:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2017:../uvc.c      ****     }
2018:../uvc.c      **** 
2019:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glDebugCmdChannel, 0);
2020:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2021:../uvc.c      ****     {
2022:../uvc.c      ****         CyU3PDebugPrint (4, "Debug channel SetXfer failed, Error code = %d\n", apiRetStatus);
2023:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2024:../uvc.c      ****     }
2025:../uvc.c      **** 
2026:../uvc.c      ****     channelConfig.size           = 1024;
2027:../uvc.c      ****     channelConfig.count          = 0;           /* No buffers allocated. We will only use the Setup
2028:../uvc.c      ****     channelConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
2029:../uvc.c      ****     channelConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_DEBUG_RSP_SOCKET;
2030:../uvc.c      ****     channelConfig.prodAvailCount = 0;
2031:../uvc.c      ****     channelConfig.prodHeader     = 0;
2032:../uvc.c      ****     channelConfig.prodFooter     = 0;
2033:../uvc.c      ****     channelConfig.consHeader     = 0;
2034:../uvc.c      ****     channelConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
2035:../uvc.c      ****     channelConfig.notification   = 0;
2036:../uvc.c      ****     channelConfig.cb             = 0;
2037:../uvc.c      **** 
2038:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glDebugRspChannel, CY_U3P_DMA_TYPE_MANUAL_OUT, &channelC
2039:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2040:../uvc.c      ****     {
2041:../uvc.c      ****         CyU3PDebugPrint (4, "Debug Response channel create failed, Error code = %d\n", apiRetStatus
2042:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2043:../uvc.c      ****     }
2044:../uvc.c      **** 
2045:../uvc.c      ****     glDebugRspBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
2046:../uvc.c      ****     if (glDebugRspBuffer == 0)
2047:../uvc.c      ****     {
2048:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for debug buffer\r\n");
2049:../uvc.c      ****         CyFxAppErrorHandler (CY_U3P_ERROR_MEMORY_ERROR);
2050:../uvc.c      ****     }
2051:../uvc.c      **** #endif
2052:../uvc.c      **** 
2053:../uvc.c      ****     /* Enable USB connection from the FX3 device, preferably at USB 3.0 speed. */
2054:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
2055:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2056:../uvc.c      ****     {
2057:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
2058:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2059:../uvc.c      ****     }
2060:../uvc.c      **** 
2061:../uvc.c      ****     CyU3PBusyWait(100);
2062:../uvc.c      **** 
2063:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
2064:../uvc.c      **** 
2065:../uvc.c      ****     endPointConfig.enable   = 1;
2066:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
2067:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
2068:../uvc.c      ****     {
2069:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
2070:../uvc.c      ****     	endPointConfig.burstLen = 16;
2071:../uvc.c      ****     }
2072:../uvc.c      ****     else		/* for usb2.0 high-speed mode */
2073:../uvc.c      ****     {
2074:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
2075:../uvc.c      ****     	endPointConfig.burstLen = 1;
2076:../uvc.c      ****     }
2077:../uvc.c      ****     endPointConfig.streams  = 0;
2078:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
2079:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2080:../uvc.c      ****     {
2081:../uvc.c      ****         /* Error Handling */
2082:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
2083:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2084:../uvc.c      ****     }
2085:../uvc.c      **** #if 0    //for still image method 3 using
2086:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (0x87, &endPointConfig); //configure still image endpoint
2087:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2088:../uvc.c      ****     {
2089:../uvc.c      ****         /* Error Handling */
2090:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed(0x87), Error Code = %d\n", apiRetStatus
2091:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2092:../uvc.c      ****     }
2093:../uvc.c      **** #endif
2094:../uvc.c      **** 
2095:../uvc.c      **** }
2096:../uvc.c      **** 
2097:../uvc.c      **** /*
2098:../uvc.c      ****  * Load the GPIF configuration on the GPIF-II engine. This operation is performed whenever a new vi
2099:../uvc.c      ****  * streaming session is started.
2100:../uvc.c      ****  */
2101:../uvc.c      **** static void
2102:../uvc.c      **** CyFxUvcAppGpifInit (
2103:../uvc.c      ****         void)
2104:../uvc.c      **** {
2105:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus=0;
2106:../uvc.c      **** 
2107:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2108:../uvc.c      ****     {
2109:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
2110:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
2111:../uvc.c      ****     }
2112:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
2113:../uvc.c      ****     {
2114:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
2115:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
2116:../uvc.c      ****     }
2117:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2118:../uvc.c      ****     {
2119:../uvc.c      ****         /* Error Handling */
2120:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
2121:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2122:../uvc.c      ****     }
2123:../uvc.c      **** 
2124:../uvc.c      ****     /* Start the state machine from the designated start state. */
2125:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
2126:../uvc.c      ****     {
2127:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START, ALPHA_START);
2128:../uvc.c      ****     }
2129:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
2130:../uvc.c      ****     {
2131:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
2132:../uvc.c      ****     }
2133:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
2134:../uvc.c      ****     {
2135:../uvc.c      ****         /* Error Handling */
2136:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
2137:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
2138:../uvc.c      ****     }
2139:../uvc.c      **** }
2140:../uvc.c      **** 
2141:../uvc.c      **** /*
2142:../uvc.c      ****  * Entry function for the UVC Application Thread
2143:../uvc.c      ****  */
2144:../uvc.c      **** 
2145:../uvc.c      **** uint32_t posTick;
2146:../uvc.c      **** CyU3PTimer I2CCmdTimer;
2147:../uvc.c      **** 
2148:../uvc.c      **** void  I2CCmdCb(uint32_t input){
2149:../uvc.c      **** 	//CyU3PDebugPrint (4, "I2C pos-timer %d %d\r\n", posTick, input);
2150:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
2151:../uvc.c      **** }
2152:../uvc.c      **** 
2153:../uvc.c      **** 
2154:../uvc.c      **** void
2155:../uvc.c      **** UVCAppThread_Entry (
2156:../uvc.c      ****         uint32_t input)
2157:../uvc.c      **** {
2158:../uvc.c      ****     //CyU3PDmaBuffer_t    produced_buffer; //for streaming header handle here
2159:../uvc.c      ****     //CyU3PDmaBuffer_t    interStabuf; for sencond interrupt status schem
2160:../uvc.c      **** 	CyU3PReturnStatus_t apiRetStatus;
2161:../uvc.c      ****     uint8_t i = 0;
2162:../uvc.c      ****     uint32_t flag;
2163:../uvc.c      ****     uint32_t prinflag = 0;
2164:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT
2165:../uvc.c      ****     uint32_t frameCnt = 0;
2166:../uvc.c      **** #endif
2167:../uvc.c      ****     /* Initialize the Uart Debug Module */
2168:../uvc.c      ****     CyFxUVCApplnDebugInit ();
2169:../uvc.c      **** 
2170:../uvc.c      ****     /* Initialize the I2C interface */
2171:../uvc.c      **** 	while (i++ < 6){
2172:../uvc.c      **** 		CyU3PThreadSleep(500);
2173:../uvc.c      **** 	}
2174:../uvc.c      **** 
2175:../uvc.c      ****     CyFxUVCApplnI2CInit ();
2176:../uvc.c      **** 
2177:../uvc.c      ****     /* Initialize the UVC Application */
2178:../uvc.c      ****     CyFxUVCApplnInit ();
2179:../uvc.c      **** 
2180:../uvc.c      ****     /*
2181:../uvc.c      ****        This thread continually checks whether video streaming is enabled, and commits video data if
2182:../uvc.c      **** 
2183:../uvc.c      ****        The CY_FX_UVC_STREAM_EVENT and CY_FX_UVC_STREAM_ABORT_EVENT event flags are monitored by thi
2184:../uvc.c      ****        thread. The CY_FX_UVC_STREAM_EVENT event flag is enabled when the USB host sends a COMMIT co
2185:../uvc.c      ****        request to the video streaming interface, and stays ON as long as video streaming is enabled
2186:../uvc.c      **** 
2187:../uvc.c      ****        The CY_FX_UVC_STREAM_ABORT_EVENT event indicates that we need to abort the video streaming. 
2188:../uvc.c      ****        only happens when we receive a CLEAR_FEATURE request indicating that streaming is to be stop
2189:../uvc.c      ****        or when we have a critical error in the data path. In both of these cases, the CY_FX_UVC_STR
2190:../uvc.c      ****        event flag will be cleared before the CY_FX_UVC_STREAM_ABORT_EVENT event flag is enabled.
2191:../uvc.c      **** 
2192:../uvc.c      ****        This sequence ensures that we do not get stuck in a loop where we are trying to send data in
2193:../uvc.c      ****        of handling the abort request.
2194:../uvc.c      ****      */
2195:../uvc.c      **** 
2196:../uvc.c      ****     for (;;)
2197:../uvc.c      ****     {
2198:../uvc.c      ****         /* Waiting for the Video Stream Event */
2199:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
2200:../uvc.c      ****                     CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2201:../uvc.c      ****         {
2202:../uvc.c      **** #if 0 //test for new firmware no video bring up
2203:../uvc.c      ****         	//CyU3PDebugPrint(4,"\r\n gpif switch(2) 0x%x %d\r\n", apiRetStatus, curstate);// track th
2204:../uvc.c      ****         	/* Check if we have a buffer ready to go. */
2205:../uvc.c      ****             apiRetStatus = CyU3PDmaMultiChannelGetBuffer (&glChHandleUVCStream, &produced_buffer, C
2206:../uvc.c      ****             if (apiRetStatus == CY_U3P_SUCCESS)
2207:../uvc.c      ****             {
2208:../uvc.c      ****             	//CyU3PDebugPrint(4," gpif switch(3)\r\n");// track the low res
2209:../uvc.c      ****             	if (produced_buffer.count == CY_FX_UVC_BUF_FULL_SIZE)
2210:../uvc.c      ****                 {
2211:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2212:../uvc.c      **** #ifdef  USB_LOWRES_IMG
2213:../uvc.c      **** #ifdef  USB_DEBUG_PRINT
2214:../uvc.c      ****                     CyU3PDebugPrint(4," gpif switch(full) 0x%x\r\n", produced_buffer.count);// trac
2215:../uvc.c      **** #endif
2216:../uvc.c      **** #endif
2217:../uvc.c      ****                     }
2218:../uvc.c      ****                 else
2219:../uvc.c      ****                 {
2220:../uvc.c      ****                     /* If we have a partial buffer, this is guaranteed to be the end of the video f
2221:../uvc.c      ****                     CyFxUVCAddHeader (produced_buffer.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEAD
2222:../uvc.c      **** #ifdef USB_LOWRES_IMG
2223:../uvc.c      ****                     gotPartial = CyFalse; /* (low res)Flag is reset to indicate that the partial bu
2224:../uvc.c      **** #ifdef USB_DEBUG_PRINT
2225:../uvc.c      **** //                    CyU3PDebugPrint(4," gpif switch(partial) 0x%x %d %d\r\n", produced_buffer.cou
2226:../uvc.c      **** #endif
2227:../uvc.c      **** #endif
2228:../uvc.c      ****                 }
2229:../uvc.c      **** 
2230:../uvc.c      ****                 /* Commit the updated DMA buffer to the USB endpoint. */
2231:../uvc.c      ****                 prodCount++;
2232:../uvc.c      ****                 //CyU3PDebugPrint(1,"buffer count %d\r\n", produced_buffer.count);
2233:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
2234:../uvc.c      ****                         produced_buffer.count + CY_FX_UVC_MAX_HEADER, 0);
2235:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2236:../uvc.c      ****                 {
2237:../uvc.c      ****                     prodCount--;
2238:../uvc.c      ****                     CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, d
2239:../uvc.c      ****                             apiRetStatus, produced_buffer.count, prodCount - consCount);
2240:../uvc.c      ****                 }
2241:../uvc.c      ****             }
2242:../uvc.c      **** #endif
2243:../uvc.c      ****             /* If we have the end of frame signal and all of the committed data has been read by th
2244:../uvc.c      ****                we can reset the DMA channel and prepare for the next video frame. */
2245:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
2246:../uvc.c      ****             {
2247:../uvc.c      ****             	if(1&&(prinflag == 0)){
2248:../uvc.c      ****             		CyU3PDebugPrint (4, "\r\n(1) fb %d pb %d pbc %d\r\n", fb, pb, pbc);
2249:../uvc.c      ****             		//prinflag = 1;
2250:../uvc.c      ****             	}
2251:../uvc.c      ****             	//fbbak=fb; pbbak=pb; pbcbak=pbc;
2252:../uvc.c      ****             	fb=0;
2253:../uvc.c      ****             	pb=0;
2254:../uvc.c      ****             	pbc=0;
2255:../uvc.c      ****                 prodCount = 0;
2256:../uvc.c      ****                 consCount = 0;
2257:../uvc.c      ****                 hitFV     = CyFalse;
2258:../uvc.c      **** 
2259:../uvc.c      **** #ifdef BACKFLOW_DETECT
2260:../uvc.c      ****                 back_flow_detected = 0;
2261:../uvc.c      **** #endif
2262:../uvc.c      **** #ifdef DEBUG_PRINT_FRAME_COUNT //it should be enabled as the frameCnt is used as timer in this vers
2263:../uvc.c      ****                 frameCnt++;
2264:../uvc.c      **** #endif
2265:../uvc.c      ****                 /* set image ready flag isFlag and set default camera parameters */
2266:../uvc.c      ****                 //if(frameCnt%5 == 0){//2 frame interval
2267:../uvc.c      ****                 	//;//CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR); //each fr
2268:../uvc.c      ****                 //}
2269:../uvc.c      ****                 /* Toggle UVC header FRAME ID bit */
2270:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
2271:../uvc.c      ****                 if(stiflag){
2272:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
2273:../uvc.c      ****                 	stiflag = CyFalse;
2274:../uvc.c      ****                 }else{
2275:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
2276:../uvc.c      ****                 }
2277:../uvc.c      ****                 /* Reset the DMA channel. */
2278:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2279:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2280:../uvc.c      ****                 {
2281:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
2282:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2283:../uvc.c      ****                 }
2284:../uvc.c      **** 
2285:../uvc.c      ****                 /* Start Channel Immediately */
2286:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2287:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2288:../uvc.c      ****                 {
2289:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
2290:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2291:../uvc.c      ****                 }
2292:../uvc.c      **** 
2293:../uvc.c      ****                 /* Jump to the start state of the GPIF state machine. 257 is used as an
2294:../uvc.c      ****                    arbitrary invalid state (> 255) number. */
2295:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2296:../uvc.c      ****                 }
2297:../uvc.c      ****         }
2298:../uvc.c      ****         else
2299:../uvc.c      ****         {
2300:../uvc.c      ****             /* If we have a stream abort request pending. */
2301:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
2302:../uvc.c      ****                         &flag, CYU3P_NO_WAIT) == CY_U3P_SUCCESS)
2303:../uvc.c      ****             {
2304:../uvc.c      ****                 hitFV     = CyFalse;
2305:../uvc.c      ****                 prodCount = 0;
2306:../uvc.c      ****                 consCount = 0;
2307:../uvc.c      ****                 if(0&&(prinflag == 0)){
2308:../uvc.c      ****                 	CyU3PDebugPrint (4, "(0) fb %d pb %d pbc %d\n", fb, pb, pbc);
2309:../uvc.c      ****                 	prinflag = 1;
2310:../uvc.c      ****                 }
2311:../uvc.c      ****                 //fbbak=fb; pbbak=pb; pbcbak=pbc;
2312:../uvc.c      ****                 fb=0;
2313:../uvc.c      ****                 pb=0;
2314:../uvc.c      ****                 pbc=0;
2315:../uvc.c      **** 
2316:../uvc.c      ****                 if (!clearFeatureRqtReceived)
2317:../uvc.c      ****                 {
2318:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
2319:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
2320:../uvc.c      ****                     {
2321:../uvc.c      ****                         CyFxAppErrorHandler (apiRetStatus);
2322:../uvc.c      ****                     }
2323:../uvc.c      **** 
2324:../uvc.c      ****                     /* Flush the Endpoint memory */
2325:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
2326:../uvc.c      ****                 }
2327:../uvc.c      **** 
2328:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
2329:../uvc.c      ****             }
2330:../uvc.c      ****             else
2331:../uvc.c      ****             {
2332:../uvc.c      ****                 /* We are essentially idle at this point. Wait for the reception of a start streami
2333:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
2334:../uvc.c      ****                 //CyU3PTimerStart(&I2CCmdTimer); //start timer again.
2335:../uvc.c      ****                 //CyU3PDebugPrint (4, "start time tick  = %d\r\n", CyU3PGetTime());
2336:../uvc.c      ****                 /* Set DMA Channel transfer size, first producer socket */
2337:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
2338:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
2339:../uvc.c      ****                 {
2340:../uvc.c      ****                     /* Error handling */
2341:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
2342:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
2343:../uvc.c      ****                 }
2344:../uvc.c      **** 
2345:../uvc.c      ****                 /* Initialize gpif configuration and waveform descriptors */
2346:../uvc.c      ****                 if (gpif_initialized == CyFalse)
2347:../uvc.c      ****                 {
2348:../uvc.c      ****                     //for start up of the AF Lens
2349:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2350:../uvc.c      ****                     CyU3PThreadSleep(500);
2351:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2352:../uvc.c      ****                     CyU3PThreadSleep(500);
2353:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
2354:../uvc.c      ****                    	CyU3PThreadSleep(300);
2355:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
2356:../uvc.c      ****                     CyU3PThreadSleep(500);
2357:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
2358:../uvc.c      ****                     CyU3PThreadSleep(500);
2359:../uvc.c      ****                     CyFxUvcAppGpifInit ();
2360:../uvc.c      ****                     gpif_initialized = CyTrue;
2361:../uvc.c      ****                     CyU3PThreadSleep(200);
2362:../uvc.c      ****                     
2363:../uvc.c      ****                 }
2364:../uvc.c      ****                 else
2365:../uvc.c      ****                 {
2366:../uvc.c      ****                     /* Jump to the start state of the GPIF state machine. 257 is used as an
2367:../uvc.c      ****                        arbitrary invalid state (> 255) number. */
2368:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
2369:../uvc.c      ****                 }
2370:../uvc.c      ****             }
2371:../uvc.c      ****         }
2372:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
2373:../uvc.c      **** 
2374:../uvc.c      ****         /* Allow other ready threads to run before proceeding. */
2375:../uvc.c      ****         CyU3PThreadRelinquish ();
2376:../uvc.c      ****     }
2377:../uvc.c      **** }
2378:../uvc.c      **** 
2379:../uvc.c      **** /*
2380:../uvc.c      ****  * Handler for control requests addressed to the Processing Unit.
2381:../uvc.c      ****  */
2382:../uvc.c      **** 
2383:../uvc.c      **** static void
2384:../uvc.c      **** UVCHandleProcessingUnitRqts (
2385:../uvc.c      ****         void)
2386:../uvc.c      **** {
2387:../uvc.c      ****     uint8_t CtrlAdd;
2388:../uvc.c      **** #ifdef DbgInfo
2389:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2390:../uvc.c      **** #endif
2391:../uvc.c      ****     switch (wValue)
2392:../uvc.c      ****     {
2393:../uvc.c      ****     	case CY_FX_UVC_PU_BACKLIGHT_COMPENSATION_CONTROL:
2394:../uvc.c      ****     		CtrlAdd = CtrlParArry[BLCCtlID0][0];
2395:../uvc.c      ****     		ControlHandle(BLCCtlID0);
2396:../uvc.c      ****     		break;
2397:../uvc.c      ****         case CY_FX_UVC_PU_BRIGHTNESS_CONTROL:
2398:../uvc.c      ****         	CtrlAdd = CtrlParArry[BrgtCtlID1][0];
2399:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
2400:../uvc.c      ****     		break;
2401:../uvc.c      ****        case CY_FX_UVC_PU_CONTRAST_CONTROL:
2402:../uvc.c      ****     	    CtrlAdd = CtrlParArry[ConsCtlID2][0];
2403:../uvc.c      **** 			ControlHandle(ConsCtlID2);
2404:../uvc.c      **** 			break;
2405:../uvc.c      **** 
2406:../uvc.c      ****        case CY_FX_UVC_PU_GAIN_CONTROL: break;
2407:../uvc.c      **** 
2408:../uvc.c      ****        case CY_FX_UVC_PU_POWER_LINE_FREQUENCY_CONTROL:
2409:../uvc.c      ****      		CtrlAdd = CtrlParArry[MFreqCtlID4][0];
2410:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
2411:../uvc.c      ****       		break;
2412:../uvc.c      ****        case CY_FX_UVC_PU_HUE_CONTROL:
2413:../uvc.c      ****     		CtrlAdd = CtrlParArry[HueCtlID5][0];
2414:../uvc.c      ****      		ControlHandle(HueCtlID5);
2415:../uvc.c      ****      		break;
2416:../uvc.c      ****        case CY_FX_UVC_PU_SATURATION_CONTROL:
2417:../uvc.c      ****           		CtrlAdd = CtrlParArry[SaturCtlID6][0];
2418:../uvc.c      ****           		ControlHandle(SaturCtlID6);
2419:../uvc.c      ****           		break;
2420:../uvc.c      ****        case CY_FX_UVC_PU_SHARPNESS_CONTROL:
2421:../uvc.c      ****           		CtrlAdd = CtrlParArry[ShapCtlID7][0];
2422:../uvc.c      ****           		ControlHandle(ShapCtlID7);
2423:../uvc.c      ****           		break;
2424:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL://
2425:../uvc.c      ****        //case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL:
2426:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_TEMPERATURE_CONTROL:
2427:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTMdCtlID9][0];
2428:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
2429:../uvc.c      ****     		break;
2430:../uvc.c      ****        case CY_FX_UVC_PU_WHITE_BALANCE_COMPONENT_CONTROL:
2431:../uvc.c      ****     		CtrlAdd = CtrlParArry[WBTLevCtlID11][0];
2432:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
2433:../uvc.c      ****     		break;
2434:../uvc.c      ****        case CY_FX_UVC_PU_DIGITAL_MULTIPLIER_CONTROL:
2435:../uvc.c      ****     		CtrlAdd = CtrlParArry[DigZmCtlID14][0];
2436:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
2437:../uvc.c      ****     		break;
2438:../uvc.c      **** 
2439:../uvc.c      ****         default:
2440:../uvc.c      ****             /*
2441:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2442:../uvc.c      ****              * other controls.
2443:../uvc.c      ****              */
2444:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2445:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2446:../uvc.c      ****             break;
2447:../uvc.c      ****     }
2448:../uvc.c      **** }
2449:../uvc.c      **** 
2450:../uvc.c      **** /*
2451:../uvc.c      ****  * Handler for control requests addressed to the UVC Camera Terminal unit.
2452:../uvc.c      ****  */
2453:../uvc.c      **** static void
2454:../uvc.c      **** UVCHandleCameraTerminalRqts (
2455:../uvc.c      ****         void)
2456:../uvc.c      **** {
2457:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2458:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2459:../uvc.c      ****     uint16_t readCount;
2460:../uvc.c      ****     uint16_t zoomVal;
2461:../uvc.c      ****     int32_t  panVal, tiltVal;
2462:../uvc.c      ****     CyBool_t sendData = CyFalse;
2463:../uvc.c      **** #endif
2464:../uvc.c      ****     uint8_t CtrlAdd;
2465:../uvc.c      **** 
2466:../uvc.c      ****     switch (wValue)
2467:../uvc.c      ****     {
2468:../uvc.c      ****     	case CY_FX_UVC_CT_SCANNING_MODE_CONTROL:
2469:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ScanMCtlID0][0];
2470:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
2471:../uvc.c      ****     		break;
2472:../uvc.c      ****         case CY_FX_UVC_CT_AE_MODE_CONTROL:
2473:../uvc.c      ****         	CtrlAdd = CTCtrlParArry[AutoExMCtlID1][0];
2474:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
2475:../uvc.c      ****     		break;
2476:../uvc.c      ****        case CY_FX_UVC_CT_AE_PRIORITY_CONTROL:
2477:../uvc.c      ****     	    CtrlAdd = CTCtrlParArry[AutoExPCtlID2][0];
2478:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
2479:../uvc.c      **** 			break;
2480:../uvc.c      **** 
2481:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL:
2482:../uvc.c      **** 			CtrlAdd = CTCtrlParArry[ExTmACtlID3][0];
2483:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
2484:../uvc.c      **** 			break;
2485:../uvc.c      **** 
2486:../uvc.c      ****        case CY_FX_UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL:
2487:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[ExTmRCtlID4][0];
2488:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
2489:../uvc.c      ****       		break;
2490:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_ABSOLUTE_CONTROL:
2491:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[FocACtlID5][0];
2492:../uvc.c      ****      		CTControlHandle(FocACtlID5);
2493:../uvc.c      ****      		break;
2494:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_RELATIVE_CONTROL:
2495:../uvc.c      ****           		CtrlAdd = CTCtrlParArry[FocRCtlID6][0];
2496:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
2497:../uvc.c      ****           		break;
2498:../uvc.c      ****        case CY_FX_UVC_CT_FOCUS_AUTO_CONTROL:
2499:../uvc.c      ****           		break;
2500:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_ABSOLUTE_CONTROL://
2501:../uvc.c      ****      		CtrlAdd = CTCtrlParArry[IriACtlID7][0];
2502:../uvc.c      ****      		CTControlHandle(IriACtlID7);
2503:../uvc.c      ****      		break;
2504:../uvc.c      **** 
2505:../uvc.c      ****        case CY_FX_UVC_CT_IRIS_RELATIVE_CONTROL:
2506:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[IriRCtlID8][0];
2507:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
2508:../uvc.c      ****     		break;
2509:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2510:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpACtlID9][0];
2511:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
2512:../uvc.c      ****     		break;
2513:../uvc.c      ****        case CY_FX_UVC_CT_ZOOM_RELATIVE_CONTROL:
2514:../uvc.c      ****     		CtrlAdd = CTCtrlParArry[ZmOpRCtlID10][0];
2515:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
2516:../uvc.c      ****     		break;
2517:../uvc.c      **** 
2518:../uvc.c      ****         default:
2519:../uvc.c      ****             /*
2520:../uvc.c      ****              * Only the  control is supported as of now. Add additional code here to support
2521:../uvc.c      ****              * other controls.
2522:../uvc.c      ****              */
2523:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
2524:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
2525:../uvc.c      ****             break;
2526:../uvc.c      ****     }
2527:../uvc.c      **** 
2528:../uvc.c      **** #ifdef UVC_PTZ_SUPPORT
2529:../uvc.c      ****     switch (wValue)
2530:../uvc.c      ****     {
2531:../uvc.c      ****         case CY_FX_UVC_CT_ZOOM_ABSOLUTE_CONTROL:
2532:../uvc.c      ****             switch (bRequest)
2533:../uvc.c      ****             {
2534:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2535:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* Support GET/SET queries. */
2536:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2537:../uvc.c      ****                     break;
2538:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ: /* Current zoom control value. */
2539:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetCurrentZoom ();
2540:../uvc.c      ****                     sendData = CyTrue;
2541:../uvc.c      ****                     break;
2542:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ: /* Minimum zoom control value. */
2543:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMinimumZoom ();
2544:../uvc.c      ****                     sendData = CyTrue;
2545:../uvc.c      ****                     break;
2546:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ: /* Maximum zoom control value. */
2547:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetMaximumZoom ();
2548:../uvc.c      ****                     sendData = CyTrue;
2549:../uvc.c      ****                     break;
2550:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ: /* Resolution is one unit. */
2551:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetZoomResolution ();
2552:../uvc.c      ****                     sendData = CyTrue;
2553:../uvc.c      ****                     break;
2554:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: /* Default zoom setting. */
2555:../uvc.c      ****                     zoomVal  = CyFxUvcAppGetDefaultZoom ();
2556:../uvc.c      ****                     sendData = CyTrue;
2557:../uvc.c      ****                     break;
2558:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2559:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2560:../uvc.c      ****                             glEp0Buffer, &readCount);
2561:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2562:../uvc.c      ****                     {
2563:../uvc.c      ****                         zoomVal = (glEp0Buffer[0]) | (glEp0Buffer[1] << 8);
2564:../uvc.c      ****                         CyFxUvcAppModifyZoom (zoomVal);
2565:../uvc.c      ****                     }
2566:../uvc.c      ****                     break;
2567:../uvc.c      ****                 default:
2568:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2569:../uvc.c      ****                     break;
2570:../uvc.c      ****             }
2571:../uvc.c      **** 
2572:../uvc.c      ****             if (sendData)
2573:../uvc.c      ****             {
2574:../uvc.c      ****                 /* Send the 2-byte data in zoomVal back to the USB host. */
2575:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_GET_LSB (zoomVal);
2576:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_GET_MSB (zoomVal);
2577:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2578:../uvc.c      ****             }
2579:../uvc.c      ****             break;
2580:../uvc.c      **** 
2581:../uvc.c      ****         case CY_FX_UVC_CT_PANTILT_ABSOLUTE_CONTROL:
2582:../uvc.c      ****             switch (bRequest)
2583:../uvc.c      ****             {
2584:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2585:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests supported for this contr
2586:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2587:../uvc.c      ****                     break;
2588:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2589:../uvc.c      ****                     panVal   = CyFxUvcAppGetCurrentPan ();
2590:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetCurrentTilt ();
2591:../uvc.c      ****                     sendData = CyTrue;
2592:../uvc.c      ****                     break;
2593:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2594:../uvc.c      ****                     panVal   = CyFxUvcAppGetMinimumPan ();
2595:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMinimumTilt ();
2596:../uvc.c      ****                     sendData = CyTrue;
2597:../uvc.c      ****                     break;
2598:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2599:../uvc.c      ****                     panVal   = CyFxUvcAppGetMaximumPan ();
2600:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetMaximumTilt ();
2601:../uvc.c      ****                     sendData = CyTrue;
2602:../uvc.c      ****                     break;
2603:../uvc.c      ****                 case CY_FX_USB_UVC_GET_RES_REQ:
2604:../uvc.c      ****                     panVal   = CyFxUvcAppGetPanResolution ();
2605:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetTiltResolution ();
2606:../uvc.c      ****                     sendData = CyTrue;
2607:../uvc.c      ****                     break;
2608:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ:
2609:../uvc.c      ****                     panVal   = CyFxUvcAppGetDefaultPan ();
2610:../uvc.c      ****                     tiltVal  = CyFxUvcAppGetDefaultTilt ();
2611:../uvc.c      ****                     sendData = CyTrue;
2612:../uvc.c      ****                     break;
2613:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2614:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2615:../uvc.c      ****                             glEp0Buffer, &readCount);
2616:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2617:../uvc.c      ****                     {
2618:../uvc.c      ****                         panVal = (glEp0Buffer[0]) | (glEp0Buffer[1]<<8) |
2619:../uvc.c      ****                             (glEp0Buffer[2]<<16) | (glEp0Buffer[2]<<24);
2620:../uvc.c      ****                         tiltVal = (glEp0Buffer[4]) | (glEp0Buffer[5]<<8) |
2621:../uvc.c      ****                             (glEp0Buffer[6]<<16) | (glEp0Buffer[7]<<24);
2622:../uvc.c      **** 
2623:../uvc.c      ****                         CyFxUvcAppModifyPan (panVal);
2624:../uvc.c      ****                         CyFxUvcAppModifyTilt (tiltVal);
2625:../uvc.c      ****                     }
2626:../uvc.c      ****                     break;
2627:../uvc.c      ****                 default:
2628:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2629:../uvc.c      ****                     break;
2630:../uvc.c      ****             }
2631:../uvc.c      **** 
2632:../uvc.c      ****             if (sendData)
2633:../uvc.c      ****             {
2634:../uvc.c      ****                 /* Send the 8-byte PAN and TILT values back to the USB host. */
2635:../uvc.c      ****                 glEp0Buffer[0] = CY_U3P_DWORD_GET_BYTE0 (panVal);
2636:../uvc.c      ****                 glEp0Buffer[1] = CY_U3P_DWORD_GET_BYTE1 (panVal);
2637:../uvc.c      ****                 glEp0Buffer[2] = CY_U3P_DWORD_GET_BYTE2 (panVal);
2638:../uvc.c      ****                 glEp0Buffer[3] = CY_U3P_DWORD_GET_BYTE3 (panVal);
2639:../uvc.c      ****                 glEp0Buffer[4] = CY_U3P_DWORD_GET_BYTE0 (tiltVal);
2640:../uvc.c      ****                 glEp0Buffer[5] = CY_U3P_DWORD_GET_BYTE1 (tiltVal);
2641:../uvc.c      ****                 glEp0Buffer[6] = CY_U3P_DWORD_GET_BYTE2 (tiltVal);
2642:../uvc.c      ****                 glEp0Buffer[7] = CY_U3P_DWORD_GET_BYTE3 (tiltVal);
2643:../uvc.c      ****                 CyU3PUsbSendEP0Data (wLength, (uint8_t *)glEp0Buffer);
2644:../uvc.c      ****             }
2645:../uvc.c      ****             break;
2646:../uvc.c      ****             //CyU3PDebugPrint (4, "The camera request received 0x%x 0x%x\r\n", wValue, bRequest); /
2647:../uvc.c      ****         default:
2648:../uvc.c      ****             //CyU3PUsbStall (0, CyTrue, CyFalse);
2649:../uvc.c      ****             break;
2650:../uvc.c      ****     }
2651:../uvc.c      **** #endif
2652:../uvc.c      **** }
2653:../uvc.c      **** 
2654:../uvc.c      **** /*
2655:../uvc.c      ****  * Handler for UVC Interface control requests.
2656:../uvc.c      ****  */
2657:../uvc.c      **** static void
2658:../uvc.c      **** UVCHandleInterfaceCtrlRqts (
2659:../uvc.c      ****         void)
2660:../uvc.c      **** {
2661:../uvc.c      **** 
2662:../uvc.c      ****     switch (wValue)
2663:../uvc.c      ****     {
2664:../uvc.c      ****     	case CY_FX_UVC_POWER_MODE_CTRL: // shutter CONTROL1
2665:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2666:../uvc.c      ****     		break;
2667:../uvc.c      **** 		case CY_FX_UVC_ERROR_CODE_CTRL: // sense up mode CONTROL2
2668:../uvc.c      ****       		CyU3PUsbStall (0, CyTrue, CyFalse);
2669:../uvc.c      ****       		//ControlHandle(0xff);//for control interface error code control.
2670:../uvc.c      ****     		break;
2671:../uvc.c      ****     	default:
2672:../uvc.c      ****      		CyU3PUsbStall (0, CyTrue, CyFalse);
2673:../uvc.c      ****      		break;
2674:../uvc.c      ****     }
2675:../uvc.c      **** /* No requests supported as of now. Just stall EP0 to fail the request. */
2676:../uvc.c      **** 
2677:../uvc.c      **** }
2678:../uvc.c      **** 
2679:../uvc.c      **** /*
2680:../uvc.c      ****  * Handler for control requests addressed to the Extension Unit.
2681:../uvc.c      ****  */
2682:../uvc.c      **** static void
2683:../uvc.c      **** UVCHandleExtensionUnitRqts (
2684:../uvc.c      ****         void)
2685:../uvc.c      **** {
2686:../uvc.c      ****     uint8_t CtrlAdd;  //set control ID -add
2687:../uvc.c      **** 
2688:../uvc.c      **** #ifdef DbgInfo
2689:../uvc.c      ****     CyU3PDebugPrint (4, "The setup request value 0x%x 0x%x\r\n", wValue, bRequest); // additional d
2690:../uvc.c      **** #endif
2691:../uvc.c      ****     switch (wValue)
2692:../uvc.c      ****     {
2693:../uvc.c      ****     	case CY_FX_EXT_CONTROL_1SHUTTER: // shutter CONTROL1
2694:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtShutCtlID0][0];
2695:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
2696:../uvc.c      ****     		break;
2697:../uvc.c      **** 		case CY_FX_EXT_CONTROL_2SENUPMODE: // sense up mode CONTROL2
2698:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSenCtlID1][0];
2699:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
2700:../uvc.c      ****     		break;
2701:../uvc.c      **** 		case CY_FX_EXT_CONTROL_3MIRROR: // mirror mode CONTROL3
2702:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtMirrCtlID2][0];
2703:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
2704:../uvc.c      ****      		break;
2705:../uvc.c      ****     	case CY_FX_EXT_CONTROL_43DNOISEREDUC_MODE: //3D noise reduce control CONTROL4
2706:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduMCtlID3][0];
2707:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
2708:../uvc.c      ****     		break;
2709:../uvc.c      **** 		case CY_FX_EXT_CONTROL_53DNOISEREDUC_CTRL: //3D noise reduce level CONTROL5
2710:../uvc.c      ****     		CtrlAdd = CtrlParArry[Ext3DNReduLvCtlID4][0];
2711:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
2712:../uvc.c      ****     		break;
2713:../uvc.c      **** 		case CY_FX_EXT_CONTROL_6DAYNIGHT_MODE: // day night mode CONTROL6
2714:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNModCtlID5][0];
2715:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
2716:../uvc.c      ****      		break;
2717:../uvc.c      ****     	case CY_FX_EXT_CONTROL_7DAYNIGHT_DELAY: //day night switch delay CONTROL7
2718:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNDelytlID6][0];
2719:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
2720:../uvc.c      ****     		break;
2721:../uvc.c      **** 		case CY_FX_EXT_CONTROL_8DAYNIGHT_LEVEL: //day to night level CONTROL8
2722:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtDNlevCtlID7][0];
2723:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
2724:../uvc.c      ****     		break;
2725:../uvc.c      **** 		case CY_FX_EXT_CONTROL_9NIGHTDAY_LEVEL: //night to day level CONTROL9
2726:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtNDlevCtlID8][0];
2727:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
2728:../uvc.c      ****      		break;
2729:../uvc.c      ****     	case CY_FX_EXT_CONTROL_10EXPOSURE_MODE: //AEx mode CONTROL10
2730:../uvc.c      ****     		if(CamMode == 1){//only 720p support
2731:../uvc.c      **** 				CtrlAdd = CtrlParArry[ExtAexModCtlID9][0];
2732:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
2733:../uvc.c      ****     		}else/* no support for 1080p camera */
2734:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
2735:../uvc.c      ****     		break;
2736:../uvc.c      **** 		case CY_FX_EXT_CONTROL_11AEREFERENCE_LEVEL: //AEx reference level CONTROL11
2737:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtExRefCtlID10][0];
2738:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
2739:../uvc.c      ****     		break;
2740:../uvc.c      **** 		case CY_FX_EXT_CONTROL_13CAMERA_MODE: //Camera Mode CONTROL13
2741:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtCamMCtlID12][0];
2742:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
2743:../uvc.c      ****     		break;
2744:../uvc.c      **** 		//case CY_FX_EXT_CONTROL_14SNAP_SHOT: //Still image set CONTROL14
2745:../uvc.c      ****     		//CtrlAdd = CtrlParArry[ExtshotCtlID13][0];
2746:../uvc.c      ****       		//ControlHandle(ExtshotCtlID13);
2747:../uvc.c      ****     		//break;
2748:../uvc.c      **** 		case CY_FX_EXT_CONTROL_15SENSOR_PARS: //Sensor Parameters set CONTROL15
2749:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtSensorParCtlID14][0];
2750:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
2751:../uvc.c      ****     		break;
2752:../uvc.c      **** 		case CY_FX_EXT_CONTROL_16I2C_COMMAND: //I2C commands operation CONTROL16
2753:../uvc.c      ****     		CtrlAdd = CtrlParArry[ExtI2CCtlID15][0];
2754:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
2755:../uvc.c      ****     		break;
2756:../uvc.c      **** 		case CY_FX_EXT_CONTROL_17BLC_RANGE:   //BLD range CONTROL17
2757:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCRangeCtlID0-EXUAOFFSET][0];
2758:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
2759:../uvc.c      ****     		break;
2760:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_POSITION:   //BLD gain CONTROL18
2761:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCWeightCtlID1-EXUAOFFSET][0];
2762:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
2763:../uvc.c      ****     		break;
2764:../uvc.c      **** 		case CY_FX_EXT_CONTROL_18BLC_GRID:   //BLD gain CONTROL19
2765:../uvc.c      ****     		CtrlAdd = ExUCtrlParArry[Ext1BLCGridCtlID2-EXUAOFFSET][0];
2766:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
2767:../uvc.c      ****     		break;
2768:../uvc.c      ****    	default:
2769:../uvc.c      ****     		/* No requests supported as of now. Just stall EP0 to fail the request. */
2770:../uvc.c      ****     		CyU3PUsbStall (0, CyTrue, CyFalse);
2771:../uvc.c      ****     		break;
2772:../uvc.c      ****     }
2773:../uvc.c      **** 
2774:../uvc.c      **** }
2775:../uvc.c      **** 
2776:../uvc.c      **** /*
2777:../uvc.c      ****  * Handler for the video streaming control requests.
2778:../uvc.c      ****  */
2779:../uvc.c      **** static void
2780:../uvc.c      **** UVCHandleVideoStreamingRqts (
2781:../uvc.c      ****         void)
2782:../uvc.c      **** {
2783:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
2784:../uvc.c      ****     uint16_t readCount;
2785:../uvc.c      **** 
2786:../uvc.c      ****     switch (wValue)
2787:../uvc.c      ****     {
2788:../uvc.c      ****         case CY_FX_UVC_PROBE_CTRL:
2789:../uvc.c      ****             switch (bRequest)
2790:../uvc.c      ****             {
2791:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2792:../uvc.c      ****                     glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2793:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2794:../uvc.c      ****                     break;
2795:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2796:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2797:../uvc.c      ****                     glEp0Buffer[1] = 0;
2798:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2799:../uvc.c      ****                     break;
2800:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2801:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MIN_REQ:
2802:../uvc.c      ****                 case CY_FX_USB_UVC_GET_MAX_REQ:
2803:../uvc.c      ****                 case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2804:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2805:../uvc.c      ****                     {
2806:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2807:../uvc.c      ****                     }
2808:../uvc.c      ****                     else
2809:../uvc.c      ****                     {
2810:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2811:../uvc.c      ****                     }
2812:../uvc.c      ****                     break;
2813:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2814:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2815:../uvc.c      ****                             glCommitCtrl, &readCount);
2816:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2817:../uvc.c      ****                     {
2818:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2819:../uvc.c      ****                         {
2820:../uvc.c      ****                             /* Copy the relevant settings from the host provided data into the
2821:../uvc.c      ****                                active data structure. */
2822:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
2823:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
2824:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
2825:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
2826:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
2827:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
2828:../uvc.c      ****                         }
2829:../uvc.c      ****                     }
2830:../uvc.c      ****                     break;
2831:../uvc.c      ****                 default:
2832:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2833:../uvc.c      ****                     break;
2834:../uvc.c      ****             }
2835:../uvc.c      ****             break;
2836:../uvc.c      **** 
2837:../uvc.c      ****         case CY_FX_UVC_COMMIT_CTRL:
2838:../uvc.c      ****             switch (bRequest)
2839:../uvc.c      ****             {
2840:../uvc.c      ****                 case CY_FX_USB_UVC_GET_INFO_REQ:
2841:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
2842:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2843:../uvc.c      ****                     break;
2844:../uvc.c      ****                 case CY_FX_USB_UVC_GET_LEN_REQ:
2845:../uvc.c      ****                     glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2846:../uvc.c      ****                     glEp0Buffer[1] = 0;
2847:../uvc.c      ****                     CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2848:../uvc.c      ****                     break;
2849:../uvc.c      ****                 case CY_FX_USB_UVC_GET_CUR_REQ:
2850:../uvc.c      ****                     if (usbSpeed == CY_U3P_SUPER_SPEED)
2851:../uvc.c      ****                     {
2852:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl);
2853:../uvc.c      ****                     }
2854:../uvc.c      ****                     else
2855:../uvc.c      ****                     {
2856:../uvc.c      ****                         CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtrl20)
2857:../uvc.c      ****                     }
2858:../uvc.c      ****                     break;
2859:../uvc.c      ****                 case CY_FX_USB_UVC_SET_CUR_REQ:
2860:../uvc.c      ****                     /* The host has selected the parameters for the video stream. Check the desired
2861:../uvc.c      ****                        resolution settings, configure the sensor and start the video stream.
2862:../uvc.c      ****                        */
2863:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2864:../uvc.c      ****                             glCommitCtrl, &readCount);
2865:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
2866:../uvc.c      ****                     {
2867:../uvc.c      **** #if 0
2868:../uvc.c      ****                     	if (usbSpeed == CY_U3P_SUPER_SPEED)
2869:../uvc.c      ****                         {
2870:../uvc.c      ****                             SensorScaling_HD720p_30fps ();
2871:../uvc.c      ****                         }
2872:../uvc.c      ****                         else
2873:../uvc.c      ****                         {
2874:../uvc.c      ****                             SensorScaling_VGA ();
2875:../uvc.c      ****                         }
2876:../uvc.c      **** #endif
2877:../uvc.c      ****                         /* We can start streaming video now. */
2878:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
2879:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
2880:../uvc.c      ****                         {
2881:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRetSta
2882:../uvc.c      ****                         }
2883:../uvc.c      ****                     }
2884:../uvc.c      ****                     break;
2885:../uvc.c      **** 
2886:../uvc.c      ****                 default:
2887:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
2888:../uvc.c      ****                     break;
2889:../uvc.c      ****             }
2890:../uvc.c      ****             break;
2891:../uvc.c      **** 
2892:../uvc.c      **** /* still image streaming handler */
2893:../uvc.c      ****             case VD_FX_UVC_STILL_PROB_CTRL:
2894:../uvc.c      ****                 switch (bRequest)
2895:../uvc.c      ****                 {
2896:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2897:../uvc.c      ****                         glEp0Buffer[0] = 3;                /* GET/SET requests are supported. */
2898:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2899:../uvc.c      ****                         break;
2900:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2901:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2902:../uvc.c      ****                         glEp0Buffer[1] = 0;
2903:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2904:../uvc.c      ****                         break;
2905:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2906:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MIN_REQ:
2907:../uvc.c      ****                     case CY_FX_USB_UVC_GET_MAX_REQ:
2908:../uvc.c      ****                     case CY_FX_USB_UVC_GET_DEF_REQ: 	/* There is only one setting per USB speed. */
2909:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2910:../uvc.c      ****                         {
2911:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2912:../uvc.c      ****                         }
2913:../uvc.c      ****                         else
2914:../uvc.c      ****                         {
2915:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2916:../uvc.c      ****                         }
2917:../uvc.c      ****                         break;
2918:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2919:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2920:../uvc.c      ****                                 glCommitCtrl, &readCount);
2921:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2922:../uvc.c      ****                         {
2923:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
2924:../uvc.c      ****                             {
2925:../uvc.c      ****                                 /* Copy the relevant settings from the host provided data into the
2926:../uvc.c      ****                                    active data structure. */
2927:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
2928:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
2929:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
2930:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
2931:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
2932:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
2933:../uvc.c      ****                             }
2934:../uvc.c      ****                         }
2935:../uvc.c      ****                         break;
2936:../uvc.c      ****                     default:
2937:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2938:../uvc.c      ****                         break;
2939:../uvc.c      ****                 }
2940:../uvc.c      ****                 break;
2941:../uvc.c      **** 
2942:../uvc.c      ****             case VD_FX_UVC_STILL_COMIT_CTRL:
2943:../uvc.c      ****                 switch (bRequest)
2944:../uvc.c      ****                 {
2945:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
2946:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
2947:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
2948:../uvc.c      ****                         break;
2949:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
2950:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
2951:../uvc.c      ****                         glEp0Buffer[1] = 0;
2952:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
2953:../uvc.c      ****                         break;
2954:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ:
2955:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
2956:../uvc.c      ****                         {
2957:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2958:../uvc.c      ****                         }
2959:../uvc.c      ****                         else
2960:../uvc.c      ****                         {
2961:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
2962:../uvc.c      ****                         }
2963:../uvc.c      ****                         break;
2964:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
2965:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
2966:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
2967:../uvc.c      ****                            */
2968:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
2969:../uvc.c      ****                                 glCommitCtrl, &readCount);
2970:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
2971:../uvc.c      ****                         {
2972:../uvc.c      ****     #if 0
2973:../uvc.c      ****                         	if (usbSpeed == CY_U3P_SUPER_SPEED)
2974:../uvc.c      ****                             {
2975:../uvc.c      ****                                 SensorScaling_HD720p_30fps ();
2976:../uvc.c      ****                             }
2977:../uvc.c      ****                             else
2978:../uvc.c      ****                             {
2979:../uvc.c      ****                                 SensorScaling_VGA ();
2980:../uvc.c      ****                             }
2981:../uvc.c      ****     #endif
2982:../uvc.c      ****                             /* We can start streaming video now. */
2983:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
2984:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
2985:../uvc.c      ****                             {
2986:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
2987:../uvc.c      ****                             }
2988:../uvc.c      ****                         }
2989:../uvc.c      ****                         break;
2990:../uvc.c      **** 
2991:../uvc.c      ****                     default:
2992:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
2993:../uvc.c      ****                         break;
2994:../uvc.c      ****                 }
2995:../uvc.c      ****                 break;
2996:../uvc.c      **** 
2997:../uvc.c      ****             case VD_FX_UVC_STILL_TRIG_CTRL:
2998:../uvc.c      ****                 switch (bRequest)
2999:../uvc.c      ****                 {
3000:../uvc.c      ****                     case CY_FX_USB_UVC_GET_INFO_REQ:
3001:../uvc.c      ****                         glEp0Buffer[0] = 3;                        /* GET/SET requests are supporte
3002:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
3003:../uvc.c      ****                         break;
3004:../uvc.c      ****                     case CY_FX_USB_UVC_GET_LEN_REQ:
3005:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
3006:../uvc.c      ****                         glEp0Buffer[1] = 0;
3007:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
3008:../uvc.c      ****                         break;
3009:../uvc.c      ****                     case CY_FX_USB_UVC_GET_CUR_REQ://TODO for still trigger control
3010:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
3011:../uvc.c      ****                         {
3012:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3013:../uvc.c      ****                         }
3014:../uvc.c      ****                         else
3015:../uvc.c      ****                         {
3016:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
3017:../uvc.c      ****                         }
3018:../uvc.c      ****                         break;
3019:../uvc.c      ****                     case CY_FX_USB_UVC_SET_CUR_REQ:
3020:../uvc.c      ****                         /* The host has selected the parameters for the video stream. Check the des
3021:../uvc.c      ****                            resolution settings, configure the sensor and start the video stream.
3022:../uvc.c      ****                            */
3023:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
3024:../uvc.c      ****                                 glCommitCtrl, &readCount);
3025:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
3026:../uvc.c      ****                         {
3027:../uvc.c      ****     #if 0
3028:../uvc.c      ****                             /* We can start streaming video now. */
3029:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
3030:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
3031:../uvc.c      ****                             {
3032:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
3033:../uvc.c      ****                             }
3034:../uvc.c      ****     #endif
3035:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
3036:../uvc.c      ****                         }else{
3037:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
3038:../uvc.c      ****                         	CyU3PUsbStall (0, CyTrue, CyFalse);
3039:../uvc.c      ****                         }
3040:../uvc.c      ****                         break;
3041:../uvc.c      **** 
3042:../uvc.c      ****                     default:
3043:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3044:../uvc.c      ****                         break;
3045:../uvc.c      ****                 }
3046:../uvc.c      ****                 break;
3047:../uvc.c      **** 
3048:../uvc.c      ****         default:
3049:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
3050:../uvc.c      ****             break;
3051:../uvc.c      ****     }
3052:../uvc.c      **** }
3053:../uvc.c      **** 
3054:../uvc.c      **** /*
3055:../uvc.c      ****  * Entry function for the UVC control request processing thread.
3056:../uvc.c      ****  */
3057:../uvc.c      **** void
3058:../uvc.c      **** UVCAppEP0Thread_Entry (
3059:../uvc.c      ****         uint32_t input)
3060:../uvc.c      **** {
3061:../uvc.c      ****     uint32_t eventMask = (CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT | CY_FX_UVC_VIDEO_STREAM_REQUEST_EV
3062:../uvc.c      ****     uint32_t eventFlag;
3063:../uvc.c      **** 	CyBool_t value;
3064:../uvc.c      **** 	CyBool_t *valueptr = &value;
3065:../uvc.c      **** 
3066:../uvc.c      **** 
3067:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3068:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3069:../uvc.c      ****     CyU3PDmaBuffer_t    dmaInfo;
3070:../uvc.c      **** 
3071:../uvc.c      ****     eventMask |= CY_FX_USB_DEBUG_CMD_EVENT;
3072:../uvc.c      **** #endif
3073:../uvc.c      **** 
3074:../uvc.c      ****     /* for interrupt status test */
3075:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3076:../uvc.c      ****     eventMask |= VD_FX_INT_STA_EVENT;
3077:../uvc.c      ****     CyU3PDmaBuffer_t    interStabuf;
3078:../uvc.c      **** 
3079:../uvc.c      ****     for (;;)
3080:../uvc.c      ****     {
3081:../uvc.c      ****         /* Wait for a Video control or streaming related request on the control endpoint. */
3082:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
3083:../uvc.c      ****                     CYU3P_WAIT_FOREVER) == CY_U3P_SUCCESS)
3084:../uvc.c      ****         {
3085:../uvc.c      ****             /* If this is the first request received during this connection, query the connection s
3086:../uvc.c      ****             if (!isUsbConnected)
3087:../uvc.c      ****             {
3088:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
3089:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
3090:../uvc.c      ****                 {
3091:../uvc.c      ****                     isUsbConnected = CyTrue;
3092:../uvc.c      ****                 }
3093:../uvc.c      ****             }
3094:../uvc.c      **** //#ifdef DbgInfo
3095:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
3096:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
3097:../uvc.c      ****             		"bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLength = 0x%x isflag 0x%x\r\n",
3098:../uvc.c      ****             		usbSpeed, eventFlag, bmReqType, bRequest, wValue, wIndex, wLength, 0/*isFlag*/); /* a
3099:../uvc.c      ****             //CyU3PDebugPrint (4, "fb = %d pb = %d pbc = %d pbcp = %d\r\n", fbbak, pbbak, pbcbak, p
3100:../uvc.c      ****             //fbbak=0;pbbak=0;pbcbak=0;pbcpbak=0;
3101:../uvc.c      **** //#endif
3102:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
3103:../uvc.c      ****             {
3104:../uvc.c      ****             	switch ((wIndex >> 8))
3105:../uvc.c      ****                 {
3106:../uvc.c      **** 
3107:../uvc.c      ****                     case CY_FX_UVC_PROCESSING_UNIT_ID:
3108:../uvc.c      ****                         UVCHandleProcessingUnitRqts ();
3109:../uvc.c      ****                         break;
3110:../uvc.c      **** 
3111:../uvc.c      ****                     case CY_FX_UVC_CAMERA_TERMINAL_ID:
3112:../uvc.c      ****                         UVCHandleCameraTerminalRqts ();
3113:../uvc.c      ****                         break;
3114:../uvc.c      **** 
3115:../uvc.c      ****                     case CY_FX_UVC_INTERFACE_CTRL:
3116:../uvc.c      ****                         UVCHandleInterfaceCtrlRqts ();
3117:../uvc.c      ****                         break;
3118:../uvc.c      **** 
3119:../uvc.c      ****                     case CY_FX_UVC_EXTENSION_UNIT_ID:
3120:../uvc.c      ****                         UVCHandleExtensionUnitRqts ();
3121:../uvc.c      ****                         break;
3122:../uvc.c      **** 
3123:../uvc.c      ****                     default:
3124:../uvc.c      ****                         /* Unsupported request. Fail by stalling the control endpoint. */
3125:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
3126:../uvc.c      ****                         break;
3127:../uvc.c      ****                 }
3128:../uvc.c      ****             }
3129:../uvc.c      **** 
3130:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
3131:../uvc.c      ****             {
3132:../uvc.c      ****                 //CyU3PDebugPrint (4, "start a stream req. ctrl. wIndex 0x%x\r\n", wIndex);
3133:../uvc.c      **** 
3134:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
3135:../uvc.c      ****                 {
3136:../uvc.c      ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
3137:../uvc.c      ****                 }
3138:../uvc.c      ****                 else
3139:../uvc.c      ****                 {
3140:../uvc.c      ****                     UVCHandleVideoStreamingRqts ();
3141:../uvc.c      ****                 }
3142:../uvc.c      ****             }
3143:../uvc.c      **** 
3144:../uvc.c      ****             /* handle interrupt status event */
3145:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
3146:../uvc.c      ****             {
3147:../uvc.c      **** 
3148:../uvc.c      ****             	//CyU3PDebugPrint (4, "start a interrupt req. ctrl. snap flag 0x%x\r\n", snapButFlag);
3149:../uvc.c      ****             	/** preparing interrupt status data **/
3150:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
3151:../uvc.c      **** 
3152:../uvc.c      **** 				//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3153:../uvc.c      **** 
3154:../uvc.c      **** #if 1 //for real button
3155:../uvc.c      **** 				if(value&&(!snapButFlag)){
3156:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3157:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3158:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3159:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3160:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3161:../uvc.c      **** 
3162:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3163:../uvc.c      **** 					interStabuf.size   = 1024;
3164:../uvc.c      **** 					interStabuf.status = 0;
3165:../uvc.c      **** 
3166:../uvc.c      **** 					interStabuf.count = 4;
3167:../uvc.c      **** 
3168:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3169:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3170:../uvc.c      **** 
3171:../uvc.c      **** 					/** send a interrupt status data **/
3172:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3173:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3174:../uvc.c      **** 					{
3175:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3176:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3177:../uvc.c      **** 					}
3178:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
3179:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
3180:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3181:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3182:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3183:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3184:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3185:../uvc.c      **** 
3186:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3187:../uvc.c      **** 					interStabuf.size   = 1024;
3188:../uvc.c      **** 					interStabuf.status = 0;
3189:../uvc.c      **** 
3190:../uvc.c      **** 					interStabuf.count = 4;
3191:../uvc.c      **** 
3192:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3193:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3194:../uvc.c      **** 
3195:../uvc.c      **** 					/** send a interrupt status data **/
3196:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3197:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3198:../uvc.c      **** 					{
3199:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3200:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3201:../uvc.c      **** 					}
3202:../uvc.c      **** 
3203:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
3204:../uvc.c      **** 					stiflag = CyTrue;
3205:../uvc.c      **** 				}
3206:../uvc.c      **** #else			//for botton simulation
3207:../uvc.c      **** 				if(snapButFlag == 0x0f){
3208:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3209:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3210:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3211:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3212:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
3213:../uvc.c      **** 
3214:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3215:../uvc.c      **** 					interStabuf.size   = 1024;
3216:../uvc.c      **** 					interStabuf.status = 0;
3217:../uvc.c      **** 
3218:../uvc.c      **** 					interStabuf.count = 4;
3219:../uvc.c      **** 
3220:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3221:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3222:../uvc.c      **** 
3223:../uvc.c      **** 					/** send a interrupt status data **/
3224:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3225:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3226:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3227:../uvc.c      **** 					{
3228:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3229:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3230:../uvc.c      **** 					}
3231:../uvc.c      **** 						SensorSetControl(0x5, 0x30, 0); //mirror set to 0
3232:../uvc.c      **** 
3233:../uvc.c      **** 						snapButFlag = 1;//snap button is masked.
3234:../uvc.c      **** 				}else if(!snapButFlag){
3235:../uvc.c      **** 					//CyU3PDebugPrint (4, "The interrupt event %d %d\r\n", testSnap, snapButFlag);
3236:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
3237:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
3238:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
3239:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
3240:../uvc.c      **** 
3241:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
3242:../uvc.c      **** 					interStabuf.size   = 1024;
3243:../uvc.c      **** 					interStabuf.status = 0;
3244:../uvc.c      **** 
3245:../uvc.c      **** 					interStabuf.count = 4;
3246:../uvc.c      **** 
3247:../uvc.c      **** 					/** wait unitll the responses has gone out **/
3248:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
3249:../uvc.c      **** 
3250:../uvc.c      **** 					/** send a interrupt status data **/
3251:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
3252:../uvc.c      **** 					//CyU3PDebugPrint (4, "send interrupt status\r\n");
3253:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
3254:../uvc.c      **** 					{
3255:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
3256:../uvc.c      **** 						CyFxAppErrorHandler (apiRetStatus);
3257:../uvc.c      **** 					}
3258:../uvc.c      **** 
3259:../uvc.c      **** 					SensorSetControl(0x5, 0x30, 1); //mirror set to 1
3260:../uvc.c      **** 					snapButFlag = 1; //snap button is not masked.
3261:../uvc.c      **** 				}
3262:../uvc.c      **** #endif
3263:../uvc.c      **** 
3264:../uvc.c      ****             }
3265:../uvc.c      **** 
3266:../uvc.c      **** 
3267:../uvc.c      **** #ifdef USB_DEBUG_INTERFACE
3268:../uvc.c      ****             if (eventFlag & CY_FX_USB_DEBUG_CMD_EVENT)
3269:../uvc.c      ****             {
3270:../uvc.c      ****                 /* Get the command buffer */
3271:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelGetBuffer (&glDebugCmdChannel, &dmaInfo, CYU3P_WAIT_F
3272:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3273:../uvc.c      ****                 {
3274:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to receive debug command, Error code = %d\r\n", api
3275:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3276:../uvc.c      ****                 }
3277:../uvc.c      **** 
3278:../uvc.c      ****                 /* Decode the command from the command buffer, error checking is not implemented,
3279:../uvc.c      ****                  * so the command is expected to be correctly sent from the host application. First
3280:../uvc.c      ****                  * read (0x00) or write (0x01) command. Second and third bytes are register address
3281:../uvc.c      ****                  * register address low byte. For read commands the fourth byte (optional) can be N
3282:../uvc.c      ****                  * registers in sequence. Response first byte is status (0=Pass, !0=Fail) followed 
3283:../uvc.c      ****                  * register value high byte and register value low byte.
3284:../uvc.c      ****                  */
3285:../uvc.c      ****                 CyU3PDebugPrint (4, "Debug interface conut %d data %d %d %d\r\n", dmaInfo.count, dm
3286:../uvc.c      ****                 if (dmaInfo.buffer[0] == 0)
3287:../uvc.c      ****                 {
3288:../uvc.c      ****                     if (dmaInfo.count == 3)
3289:../uvc.c      ****                     {
3290:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead2B (SENSOR_ADDR_RD, dmaInfo.buffer[1], dm
3291:../uvc.c      ****                         		(glDebugRspBuffer+1));*/
3292:../uvc.c      ****                         dmaInfo.count = 3;
3293:../uvc.c      ****                     }
3294:../uvc.c      ****                     else if (dmaInfo.count == 4)
3295:../uvc.c      ****                     {
3296:../uvc.c      ****                         if (dmaInfo.buffer[3] > 0)
3297:../uvc.c      ****                         {
3298:../uvc.c      ****                                 glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1]
3299:../uvc.c      ****                                 		(dmaInfo.buffer[3]*2), (glDebugRspBuffer+1));
3300:../uvc.c      ****                         }
3301:../uvc.c      ****                         dmaInfo.count = dmaInfo.buffer[3]*2+1;
3302:../uvc.c      ****                     }
3303:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug responsR conut %d data %d %d %d\r\n", dmaInfo.count,
3304:../uvc.c      ****                 }
3305:../uvc.c      ****                 /*  For write commands, the register address is followed by N pairs (N>0) of regist
3306:../uvc.c      ****                  *  and register value low byte to write in sequence. Response first byte is status
3307:../uvc.c      ****                  *  followed by N pairs of register value high byte and register value low byte aft
3308:../uvc.c      ****                  */
3309:../uvc.c      ****                 else if (dmaInfo.buffer[0] == 1)
3310:../uvc.c      ****                 {
3311:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorWrite (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3312:../uvc.c      ****                         		(dmaInfo.count-3), (dmaInfo.buffer+3));  original one*/
3313:../uvc.c      ****                         glDebugRspBuffer[0] = SensorWrite2B (SENSOR_ADDR_WR, dmaInfo.buffer[1], dma
3314:../uvc.c      ****                                                 		0x00, dmaInfo.buffer[3]); //additional debug
3315:../uvc.c      ****                         CyU3PDebugPrint (4, "Debug write %d data %d %d %d\r\n", dmaInfo.count, dmaI
3316:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3317:../uvc.c      ****                         	break;
3318:../uvc.c      ****                         /*glDebugRspBuffer[0] = SensorRead (SENSOR_ADDR_RD, dmaInfo.buffer[1], dmaI
3319:../uvc.c      ****                         		(dmaInfo.count-3), (glDebugRspBuffer+1));
3320:../uvc.c      ****                         if (glDebugRspBuffer[0] != CY_U3P_SUCCESS)
3321:../uvc.c      ****                         	break;*/
3322:../uvc.c      ****                     dmaInfo.count -= 2;
3323:../uvc.c      ****                 }
3324:../uvc.c      ****                 /* Default case, prepare buffer for loop back command in response */
3325:../uvc.c      ****                 else
3326:../uvc.c      ****                 {
3327:../uvc.c      ****                    /* For now, we just copy the command into the response buffer; and send it back 
3328:../uvc.c      ****                       USB host. This can be expanded to include I2C transfers. */
3329:../uvc.c      ****                     CyU3PMemCopy (glDebugRspBuffer, dmaInfo.buffer, dmaInfo.count);
3330:../uvc.c      ****                     CyU3PDebugPrint (4, "Debug respons conut %d data %d %d %d\r\n", dmaInfo.count, 
3331:../uvc.c      ****                 }
3332:../uvc.c      **** 
3333:../uvc.c      ****                 dmaInfo.buffer = glDebugRspBuffer;
3334:../uvc.c      ****                 dmaInfo.size   = 1024;
3335:../uvc.c      ****                 dmaInfo.status = 0;
3336:../uvc.c      **** 
3337:../uvc.c      ****                 /* Free the command buffer to receive the next command. */
3338:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelDiscardBuffer (&glDebugCmdChannel);
3339:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3340:../uvc.c      ****                 {
3341:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to free up command OUT EP buffer, Error code = %d\r
3342:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3343:../uvc.c      ****                 }
3344:../uvc.c      **** 
3345:../uvc.c      ****                 /* Wait until the response has gone out. */
3346:../uvc.c      ****                 CyU3PDmaChannelWaitForCompletion (&glDebugRspChannel, CYU3P_WAIT_FOREVER);
3347:../uvc.c      **** 
3348:../uvc.c      ****                 apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glDebugRspChannel, &dmaInfo);
3349:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
3350:../uvc.c      ****                 {
3351:../uvc.c      ****                     CyU3PDebugPrint (4, "Failed to send debug response, Error code = %d\r\n", apiRe
3352:../uvc.c      ****                     CyFxAppErrorHandler (apiRetStatus);
3353:../uvc.c      ****                 }
3354:../uvc.c      ****             }
3355:../uvc.c      **** #endif
3356:../uvc.c      ****         }
3357:../uvc.c      ****         /* Allow other ready threads to run. */
3358:../uvc.c      ****         CyU3PThreadRelinquish ();
3359:../uvc.c      ****     }
3360:../uvc.c      **** }
3361:../uvc.c      **** 
3362:../uvc.c      **** /*
3363:../uvc.c      ****  * Entry function for the internal I2C control handler thread.
3364:../uvc.c      ****  * added 10/2013
3365:../uvc.c      ****  */
3366:../uvc.c      **** /*
3367:../uvc.c      **** static uint8_t timeDelay[64] = {
3368:../uvc.c      **** 
3369:../uvc.c      **** };
3370:../uvc.c      **** */
3371:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  27              		.loc 1 3371 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 36
3372:../uvc.c      **** 
3373:../uvc.c      **** 	//uint16_t count = 0, cmdCopyIdx = 0; //count1 = 0, cmdQuIdx = 0,
3374:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3375:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3376:../uvc.c      **** 	VdcmdDes  *lcCmdDes;
3377:../uvc.c      **** 	VdstateDes *lcStaDes;
3378:../uvc.c      **** 	uint32_t flag = 0;
3379:../uvc.c      **** 	uint8_t  cmdFlag = 0;
3380:../uvc.c      **** 	uint8_t regAdd, /*regAdd1,*/ devAdd, data;// data1;
3381:../uvc.c      **** 	uint8_t i;
3382:../uvc.c      **** 	uint16_t delaytime;
3383:../uvc.c      **** 	//CyBool_t trigger = CyFalse;
3384:../uvc.c      **** 
3385:../uvc.c      **** #if 0 //for test the command queue
3386:../uvc.c      **** 	lcCmdDes = cmdQuptr->startAdd;
3387:../uvc.c      **** 	for(cmdQuIdx = 0; cmdQuIdx < MAXCMD; cmdQuIdx++){
3388:../uvc.c      **** 		CyU3PDebugPrint (4, "Command Queue check cmdID %d CmdDes 0x%x previous 0x%x next 0x%x Idx %d\r\n"
3389:../uvc.c      **** 				lcCmdDes->CmdID, lcCmdDes,	lcCmdDes->cmdDesPrevious, lcCmdDes->cmdDesNext, cmdQuIdx);
3390:../uvc.c      **** 		lcCmdDes += 1;
3391:../uvc.c      **** 	}
3392:../uvc.c      **** #endif
3393:../uvc.c      **** /*** create a timer for I2C commands delay option ***/
3394:../uvc.c      **** 	CyU3PTimerCreate(&I2CCmdTimer, I2CCmdCb, 11, 1000, 0, CYU3P_NO_ACTIVATE);
  35              		.loc 1 3394 0
  36 0004 10229FE5 		ldr	r2, .L22
3378:../uvc.c      **** 	uint32_t flag = 0;
  37              		.loc 1 3378 0
  38 0008 0040A0E3 		mov	r4, #0
  39              		.cfi_offset 14, -4
  40              		.cfi_offset 11, -8
  41              		.cfi_offset 10, -12
  42              		.cfi_offset 9, -16
  43              		.cfi_offset 8, -20
  44              		.cfi_offset 7, -24
  45              		.cfi_offset 6, -28
  46              		.cfi_offset 5, -32
  47              		.cfi_offset 4, -36
3371:../uvc.c      **** void I2cAppThread_Entry(uint32_t input){
  48              		.loc 1 3371 0
  49 000c 1CD04DE2 		sub	sp, sp, #28
  50              	.LCFI1:
  51              		.cfi_def_cfa_offset 64
  52              		.loc 1 3394 0
  53 0010 FAEFA0E3 		mov	lr, #1000
  54 0014 2CC084E2 		add	ip, r4, #44
  55 0018 0B30A0E3 		mov	r3, #11
  56 001c 0410A0E1 		mov	r1, r4
  57 0020 F8019FE5 		ldr	r0, .L22+4
  58              	.LVL1:
  59 0024 00E08DE5 		str	lr, [sp, #0]
  60 0028 0CC08DE5 		str	ip, [sp, #12]
3378:../uvc.c      **** 	uint32_t flag = 0;
  61              		.loc 1 3378 0
  62 002c 14408DE5 		str	r4, [sp, #20]
  63              	.LVL2:
  64              		.loc 1 3394 0
  65 0030 04408DE5 		str	r4, [sp, #4]
  66 0034 08408DE5 		str	r4, [sp, #8]
  67 0038 FEFFFFEB 		bl	_txe_timer_create
3395:../uvc.c      **** 	CyU3PDebugPrint (4, "I2C per-timer %d\r\n", CyU3PGetTime());
  68              		.loc 1 3395 0
  69 003c FEFFFFEB 		bl	_tx_time_get
  70 0040 DC119FE5 		ldr	r1, .L22+8
  71 0044 DC519FE5 		ldr	r5, .L22+12
  72 0048 0020A0E1 		mov	r2, r0
  73 004c 0400A0E3 		mov	r0, #4
  74 0050 FEFFFFEB 		bl	CyU3PDebugPrint
3396:../uvc.c      **** 	CyU3PThreadSleep(50);
  75              		.loc 1 3396 0
  76 0054 3200A0E3 		mov	r0, #50
  77 0058 FEFFFFEB 		bl	_tx_thread_sleep
3397:../uvc.c      **** 	CyU3PTimerStart(&I2CCmdTimer);
  78              		.loc 1 3397 0
  79 005c BC019FE5 		ldr	r0, .L22+4
  80 0060 FEFFFFEB 		bl	_txe_timer_activate
3398:../uvc.c      **** 
3399:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  81              		.loc 1 3399 0
  82 0064 000000EA 		b	.L2
  83              	.L3:
3400:../uvc.c      ****         /* Allow other ready threads to run. */
3401:../uvc.c      **** 
3402:../uvc.c      ****         CyU3PThreadRelinquish ();
  84              		.loc 1 3402 0
  85 0068 FEFFFFEB 		bl	_txe_thread_relinquish
  86              	.L2:
3399:../uvc.c      **** 	while(cmdQuptr->bugFlag == (uint8_t)CyFalse){ //waiting for first command
  87              		.loc 1 3399 0 discriminator 1
  88 006c 1A20D5E5 		ldrb	r2, [r5, #26]	@ zero_extendqisi2
  89 0070 000052E3 		cmp	r2, #0
  90 0074 FBFFFF0A 		beq	.L3
3403:../uvc.c      **** 	}
3404:../uvc.c      **** 	CyU3PDebugPrint (4, "The command queue is ready %d %d\r\n", cmdQuptr->bugFlag, cmdQuptr->readPtr->
  91              		.loc 1 3404 0
  92 0078 A8019FE5 		ldr	r0, .L22+12
  93 007c A8119FE5 		ldr	r1, .L22+16
  94 0080 103090E5 		ldr	r3, [r0, #16]
  95 0084 0400A0E3 		mov	r0, #4
  96 0088 3C3093E5 		ldr	r3, [r3, #60]
  97 008c FEFFFFEB 		bl	CyU3PDebugPrint
  98 0090 98719FE5 		ldr	r7, .L22+20
  99 0094 98B19FE5 		ldr	fp, .L22+24
3405:../uvc.c      **** 	//CamDefSet(); //set default parameters to camera
3406:../uvc.c      **** 	/***** add recovery of the current camera settings ****/
3407:../uvc.c      **** 	//CyU3PThreadSleep(100);
3408:../uvc.c      **** 	//SetCurCmd();
3409:../uvc.c      **** 	/*********** the loop of the thread ***********/
3410:../uvc.c      **** 	for(;;){
3411:../uvc.c      **** 
3412:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 100              		.loc 1 3412 0
 101 0098 0060E0E3 		mvn	r6, #0
3413:../uvc.c      **** /*  // for test GPIO output
3414:../uvc.c      **** 		if(trigger)
3415:../uvc.c      **** 		{
3416:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyFalse);
3417:../uvc.c      **** 			{
3418:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyFalse);
3419:../uvc.c      **** 			}
3420:../uvc.c      **** 
3421:../uvc.c      **** 		}else{
3422:../uvc.c      **** 			CyU3PGpioSetValue(SENSOR_RESET_GPIO, CyTrue);
3423:../uvc.c      **** 			{
3424:../uvc.c      **** 				CyU3PDebugPrint(4, "GPIO Set Value Error, Error Code = %d\n", CyTrue);
3425:../uvc.c      **** 			}
3426:../uvc.c      **** 
3427:../uvc.c      **** 		}
3428:../uvc.c      **** */
3429:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3430:../uvc.c      **** 			//CyU3PDebugPrint (4, "get I2C events (0) flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3431:../uvc.c      **** 			lcStaDes = (VdstateDes*)statQuptr->readPtr;
3432:../uvc.c      **** 			if(0 && (lcStaDes->statFlag == CyTrue)){ /* for state queue it's not used right now. */
3433:../uvc.c      **** 				for(i = 0; i < lcStaDes->NumData; i++){
3434:../uvc.c      **** 					regAdd = ((lcStaDes->staPar)+i)->RegAdd;
3435:../uvc.c      **** 					devAdd = ((lcStaDes->staPar)+i)->DevAdd;
3436:../uvc.c      **** 					((lcStaDes->staPar)+i)->Data = SensorGetControl(regAdd, devAdd); //get state value from I2C bu
3437:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3438:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C state stateID %d cmdCopyIdx %d regAdd 0x%x devAdd 0x%x data 0x%x
3439:../uvc.c      **** 								lcStaDes->StatID, regAdd, devAdd, data);
3440:../uvc.c      **** #endif
3441:../uvc.c      **** 				}
3442:../uvc.c      **** 				lcStaDes->statFlag = CyFalse;
3443:../uvc.c      **** 				statQuptr->readPtr = (VdcmdDes*)lcStaDes->staDesNext; //update command queue read pointer
3444:../uvc.c      **** 				cmdFlag = 0xFF; //I2C command done
3445:../uvc.c      **** 			}
3446:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
3447:../uvc.c      **** 			if(cmdFlag != 0xFF){ //for during handle command
3448:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3449:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
3450:../uvc.c      **** 
3451:../uvc.c      **** 				/*
3452:../uvc.c      **** 				CyU3PDebugPrint (4, "get I2C events (1) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3453:../uvc.c      **** 						flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3454:../uvc.c      **** 				*/
3455:../uvc.c      **** 
3456:../uvc.c      **** 				/* find a available command */
3457:../uvc.c      **** 				i = 0;
3458:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 102              		.loc 1 3458 0
 103 009c 0090A0E3 		mov	r9, #0
3459:../uvc.c      **** 					i++;
3460:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
3461:../uvc.c      **** 					cmdQuptr->readPtr = lcCmdDes;
3462:../uvc.c      **** 				}
3463:../uvc.c      **** 				//CyU3PDebugPrint (4, "i %d Cmf_Flag %d\r\n", i, lcCmdDes->cmdFlag);
3464:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
3465:../uvc.c      **** 					i = lcCmdDes->curNum;
3466:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
3467:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
3468:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
3469:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
3470:../uvc.c      **** 					switch(lcCmdDes->CmdID){
3471:../uvc.c      **** 						case 20:
3472:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
3473:../uvc.c      **** 							delaytime = 500;
3474:../uvc.c      **** 							break;
3475:../uvc.c      **** 						case 21:
3476:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
3477:../uvc.c      **** 							delaytime = 500;
3478:../uvc.c      **** 							break;
3479:../uvc.c      **** 						case 22:
3480:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3481:../uvc.c      **** 							delaytime = 300;
3482:../uvc.c      **** 							break;
3483:../uvc.c      **** 						case 23:
3484:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
3485:../uvc.c      **** 							delaytime = 300;
3486:../uvc.c      **** 							break;
3487:../uvc.c      **** 						default:
3488:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
3489:../uvc.c      **** 							break;
3490:../uvc.c      **** 					}
3491:../uvc.c      **** 					//SensorSetControl(regAdd, devAdd, data);    //send I2C command
3492:../uvc.c      **** 					/** timer's ticket modify **/
3493:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
3494:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
3495:../uvc.c      **** 					//CyU3PDebugPrint (4, "set timer restart(1) %d 0x%x 0x%x %d %d %d %d\r\n", CyU3PGetTime(), reg
3496:../uvc.c      **** 					cmdFlag = 0xFF; //I2C command done
3497:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3498:../uvc.c      **** 					CyU3PDebugPrint (4, "send I2C command cmdID %d regAdd 0x%x devAdd 0x%x data 0x%x cmdflag 0x%x\
3499:../uvc.c      **** 							lcCmdDes->CmdID, regAdd, devAdd, data, lcCmdDes->cmdFlag);
3500:../uvc.c      **** #endif
3501:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
3502:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
3503:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
3504:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
3505:../uvc.c      **** 						}else{
3506:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
3507:../uvc.c      **** 						}
3508:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
3509:../uvc.c      **** 					}else{
3510:../uvc.c      **** 						lcCmdDes->curNum ++;
3511:../uvc.c      **** 						lcCmdDes->cmdFlag = desusing;
 104              		.loc 1 3511 0
 105 00a0 0F80A0E3 		mov	r8, #15
 106              	.L18:
3412:../uvc.c      **** 		CyU3PEventGet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_AND_CLEAR, &flag, CYU3P_WAIT_FOREV
 107              		.loc 1 3412 0
 108 00a4 0320A0E3 		mov	r2, #3
 109 00a8 14308DE2 		add	r3, sp, #20
 110 00ac 2010A0E3 		mov	r1, #32
 111 00b0 80019FE5 		ldr	r0, .L22+28
 112 00b4 00608DE5 		str	r6, [sp, #0]
 113 00b8 FEFFFFEB 		bl	_txe_event_flags_get
3429:../uvc.c      **** 			CyU3PMutexGet(statQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 114              		.loc 1 3429 0
 115 00bc 0610A0E1 		mov	r1, r6
 116 00c0 1C0097E5 		ldr	r0, [r7, #28]
 117 00c4 FEFFFFEB 		bl	_txe_mutex_get
 118              	.LVL3:
3446:../uvc.c      **** 			CyU3PMutexPut(statQuptr->ringMux);  //release the command queue mutex
 119              		.loc 1 3446 0
 120 00c8 1C0097E5 		ldr	r0, [r7, #28]
 121 00cc FEFFFFEB 		bl	_txe_mutex_put
 122              	.LVL4:
3448:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 123              		.loc 1 3448 0
 124 00d0 1C0095E5 		ldr	r0, [r5, #28]
 125 00d4 0610A0E1 		mov	r1, r6
 126 00d8 FEFFFFEB 		bl	_txe_mutex_get
3449:../uvc.c      **** 				lcCmdDes = cmdQuptr->readPtr;
 127              		.loc 1 3449 0
 128 00dc 104095E5 		ldr	r4, [r5, #16]
 129              	.LVL5:
3458:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 130              		.loc 1 3458 0
 131 00e0 3C2094E5 		ldr	r2, [r4, #60]
 132 00e4 000052E3 		cmp	r2, #0
 133 00e8 0800001A 		bne	.L4
 134 00ec 0030A0E3 		mov	r3, #0
 135              	.LVL6:
 136              	.L5:
3460:../uvc.c      **** 					lcCmdDes = lcCmdDes->cmdDesNext;
 137              		.loc 1 3460 0
 138 00f0 344094E5 		ldr	r4, [r4, #52]
 139              	.LVL7:
3459:../uvc.c      **** 					i++;
 140              		.loc 1 3459 0
 141 00f4 011083E2 		add	r1, r3, #1
3458:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 142              		.loc 1 3458 0
 143 00f8 3C2094E5 		ldr	r2, [r4, #60]
3459:../uvc.c      **** 					i++;
 144              		.loc 1 3459 0
 145 00fc FF3001E2 		and	r3, r1, #255
 146              	.LVL8:
3458:../uvc.c      **** 				while((lcCmdDes->cmdFlag == deswait) && (i < MAXCMD)){
 147              		.loc 1 3458 0
 148 0100 3F0053E3 		cmp	r3, #63
 149 0104 00005293 		cmpls	r2, #0
 150 0108 F8FFFF0A 		beq	.L5
 151 010c 104085E5 		str	r4, [r5, #16]
 152              	.LVL9:
 153              	.L4:
3464:../uvc.c      **** 				if(lcCmdDes->cmdFlag != deswait){
 154              		.loc 1 3464 0
 155 0110 000052E3 		cmp	r2, #0
 156 0114 2D00000A 		beq	.L6
 157              	.LVL10:
3466:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 158              		.loc 1 3466 0
 159 0118 0130D4E5 		ldrb	r3, [r4, #1]	@ zero_extendqisi2
3470:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 160              		.loc 1 3470 0
 161 011c 0020D4E5 		ldrb	r2, [r4, #0]	@ zero_extendqisi2
3466:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 162              		.loc 1 3466 0
 163 0120 83E083E0 		add	lr, r3, r3, asl #1
 164 0124 8EA084E0 		add	sl, r4, lr, asl #1
3470:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 165              		.loc 1 3470 0
 166 0128 14C042E2 		sub	ip, r2, #20
3466:../uvc.c      **** 					regAdd = ((lcCmdDes->CmdPar)+i)->RegAdd;
 167              		.loc 1 3466 0
 168 012c 0400DAE5 		ldrb	r0, [sl, #4]	@ zero_extendqisi2
 169              	.LVL11:
3467:../uvc.c      **** 					devAdd = ((lcCmdDes->CmdPar)+i)->DevAdd;
 170              		.loc 1 3467 0
 171 0130 0510DAE5 		ldrb	r1, [sl, #5]	@ zero_extendqisi2
 172              	.LVL12:
3468:../uvc.c      **** 					data = ((lcCmdDes->CmdPar)+i)->Data;
 173              		.loc 1 3468 0
 174 0134 0620DAE5 		ldrb	r2, [sl, #6]	@ zero_extendqisi2
 175              	.LVL13:
3469:../uvc.c      **** 					delaytime = ((lcCmdDes->CmdPar)+i)->DelayT;
 176              		.loc 1 3469 0
 177 0138 B8A0DAE1 		ldrh	sl, [sl, #8]
 178              	.LVL14:
3470:../uvc.c      **** 					switch(lcCmdDes->CmdID){
 179              		.loc 1 3470 0
 180 013c 03005CE3 		cmp	ip, #3
 181 0140 0CF19F97 		ldrls	pc, [pc, ip, asl #2]
 182 0144 1A0000EA 		b	.L7
 183              	.L12:
 184 0148 C0010000 		.word	.L8
 185 014c A4010000 		.word	.L9
 186 0150 58010000 		.word	.L11
 187 0154 58010000 		.word	.L11
 188              	.L11:
3484:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris value 
 189              		.loc 1 3484 0
 190 0158 8230A0E3 		mov	r3, #130
 191 015c FEFFFFEB 		bl	SensorSetIrisControl
 192              	.LVL15:
3486:../uvc.c      **** 							break;
 193              		.loc 1 3486 0
 194 0160 4B1FA0E3 		mov	r1, #300
 195              	.LVL16:
 196              	.L13:
3493:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, delaytime, 0);
 197              		.loc 1 3493 0
 198 0164 0020A0E3 		mov	r2, #0
 199 0168 B0009FE5 		ldr	r0, .L22+4
 200 016c FEFFFFEB 		bl	_txe_timer_change
3494:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);  //start delay timer
 201              		.loc 1 3494 0
 202 0170 A8009FE5 		ldr	r0, .L22+4
 203 0174 FEFFFFEB 		bl	_txe_timer_activate
 204              	.LVL17:
3501:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 205              		.loc 1 3501 0
 206 0178 0100D4E5 		ldrb	r0, [r4, #1]	@ zero_extendqisi2
 207 017c 0210D4E5 		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 208 0180 000051E1 		cmp	r1, r0
3510:../uvc.c      **** 						lcCmdDes->curNum ++;
 209              		.loc 1 3510 0
 210 0184 01008012 		addne	r0, r0, #1
 211 0188 0100C415 		strneb	r0, [r4, #1]
 212              		.loc 1 3511 0
 213 018c 3C808415 		strne	r8, [r4, #60]
3501:../uvc.c      **** 					if(lcCmdDes->NumPara == lcCmdDes->curNum){
 214              		.loc 1 3501 0
 215 0190 1400000A 		beq	.L21
 216              	.LVL18:
 217              	.L17:
3512:../uvc.c      **** 					}
3513:../uvc.c      **** 				}else{
3514:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
3515:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
3516:../uvc.c      **** 				}
3517:../uvc.c      **** 			}
3518:../uvc.c      **** 			CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 218              		.loc 1 3518 0
 219 0194 1C0095E5 		ldr	r0, [r5, #28]
 220 0198 FEFFFFEB 		bl	_txe_mutex_put
 221              	.LVL19:
3519:../uvc.c      **** /*
3520:../uvc.c      **** 			CyU3PDebugPrint (4, "get I2C events (2) flag 0x%x cmdflag 0x%x desflag 0x%x lcCmdDes 0x%x\r\n",
3521:../uvc.c      **** 					flag, cmdFlag, lcCmdDes->cmdFlag, lcCmdDes);
3522:../uvc.c      **** */
3523:../uvc.c      **** #ifdef USB_DEBUG_PRINT
3524:../uvc.c      **** 			CyU3PDebugPrint (4, "I2C thread checking camera parameters count %d data0 %d data1 %d cmdflag 0x
3525:../uvc.c      **** 						0/*count*/, CtrlParArry[count][13], CtrlParArry[count][14], cmdFlag);
3526:../uvc.c      **** #endif
3527:../uvc.c      **** 
3528:../uvc.c      **** 			/**** checking the camera registers if it is the same what the current copy is. ****/
3529:../uvc.c      **** 			/** this code might be used when a timer is used to schedule the I2C command sent out **/
3530:../uvc.c      **** #if 0
3531:../uvc.c      **** 				if((CtrlParArry[cmdCopyIdx][16] != CyTrue)&&(cmdFlag != 0xFF)/*&&(CtrlParArry[cmdCopyIdx][17] !
3532:../uvc.c      **** 
3533:../uvc.c      **** 				regAdd = CtrlParArry[cmdCopyIdx][0];
3534:../uvc.c      **** 			    regAdd1 = CtrlParArry[cmdCopyIdx][1];
3535:../uvc.c      **** 			    devAdd = CtrlParArry[cmdCopyIdx][15];
3536:../uvc.c      **** 			    data = SensorGetControl(regAdd, devAdd); //SensorGetBLCMode();
3537:../uvc.c      **** 			    i = 0;
3538:../uvc.c      **** 				 switch(cmdCopyIdx)
3539:../uvc.c      **** 				 {
3540:../uvc.c      **** 					 case BrgtCtlID1:
3541:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][14] != data){
3542:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3543:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][14], i);
3544:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3545:../uvc.c      **** 							 i++;
3546:../uvc.c      **** 						 }
3547:../uvc.c      **** 						 else{
3548:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3549:../uvc.c      **** 						 }
3550:../uvc.c      **** 
3551:../uvc.c      **** 						 CyU3PBusyWait(500);
3552:../uvc.c      **** 						 data =SensorGetControl(regAdd1, devAdd);
3553:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3554:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3555:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd1, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3556:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3557:../uvc.c      **** 						 }
3558:../uvc.c      **** 						 else{
3559:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3560:../uvc.c      **** 						 }
3561:../uvc.c      **** 						 break;
3562:../uvc.c      **** 					 case HueCtlID5:
3563:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] != data){
3564:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3565:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3566:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3567:../uvc.c      **** 						 }
3568:../uvc.c      **** 						 else{
3569:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3570:../uvc.c      **** 						 }
3571:../uvc.c      **** 						 break;
3572:../uvc.c      **** 					 case SaturCtlID6:
3573:../uvc.c      **** 					 case WBTLevCtlID10:
3574:../uvc.c      **** 					 default:
3575:../uvc.c      **** 						 if (CtrlParArry[cmdCopyIdx][13] == data){
3576:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
3577:../uvc.c      **** 							 cmdSet(cmdQuptr, cmdCopyIdx, regAdd, devAdd, CtrlParArry[cmdCopyIdx][13], i);
3578:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
3579:../uvc.c      **** 						 }
3580:../uvc.c      **** 						 else{
3581:../uvc.c      **** 							 ;//CtrlParArry[cmdCopyIdx][16] = CyTrue; //if they are the same, set flag is true.
3582:../uvc.c      **** 						 }
3583:../uvc.c      **** 						 break;
3584:../uvc.c      **** 				 }
3585:../uvc.c      **** 				 //cmdFlag = 0xFF; //one I2C command one available event.
3586:../uvc.c      **** 				 CtrlParArry[cmdCopyIdx][16] = CyTrue; //set flag to true. let it sent to camera.
3587:../uvc.c      **** 			}
3588:../uvc.c      **** 			cmdCopyIdx = (cmdCopyIdx + 1 )& 0x1F;    //update checking index.
3589:../uvc.c      **** #endif
3590:../uvc.c      **** 			cmdFlag = 0x00; //clear flag
3591:../uvc.c      **** 		/* Allow other ready threads to run. */
3592:../uvc.c      **** 			//CyU3PDebugPrint (4, "out of the i2cthread flag 0x%x cmdflag 0x%x\r\n", flag, cmdFlag);
3593:../uvc.c      **** 			CyU3PThreadRelinquish ();
 222              		.loc 1 3593 0
 223 019c FEFFFFEB 		bl	_txe_thread_relinquish
3594:../uvc.c      **** 		}
 224              		.loc 1 3594 0
 225 01a0 BFFFFFEA 		b	.L18
 226              	.LVL20:
 227              	.L9:
3476:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris auto 
 228              		.loc 1 3476 0
 229 01a4 5230A0E3 		mov	r3, #82
 230 01a8 FEFFFFEB 		bl	SensorSetIrisControl
 231              	.LVL21:
3478:../uvc.c      **** 							break;
 232              		.loc 1 3478 0
 233 01ac 7D1FA0E3 		mov	r1, #500
 234 01b0 EBFFFFEA 		b	.L13
 235              	.LVL22:
 236              	.L7:
3488:../uvc.c      **** 							SensorSetControl(regAdd, devAdd, data);    //send I2C command
 237              		.loc 1 3488 0
 238 01b4 FEFFFFEB 		bl	SensorSetControl
 239              	.LVL23:
 240 01b8 0A10A0E1 		mov	r1, sl
3489:../uvc.c      **** 							break;
 241              		.loc 1 3489 0
 242 01bc E8FFFFEA 		b	.L13
 243              	.LVL24:
 244              	.L8:
3472:../uvc.c      **** 							SensorSetIrisControl(regAdd, devAdd, data, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris auto (
 245              		.loc 1 3472 0
 246 01c0 8230A0E3 		mov	r3, #130
 247 01c4 FEFFFFEB 		bl	SensorSetIrisControl
 248              	.LVL25:
3474:../uvc.c      **** 							break;
 249              		.loc 1 3474 0
 250 01c8 7D1FA0E3 		mov	r1, #500
 251 01cc E4FFFFEA 		b	.L13
 252              	.LVL26:
 253              	.L6:
3514:../uvc.c      **** 					CyU3PTimerModify(&I2CCmdTimer, 1000, 0);
 254              		.loc 1 3514 0
 255 01d0 FA1FA0E3 		mov	r1, #1000
 256 01d4 44009FE5 		ldr	r0, .L22+4
 257 01d8 FEFFFFEB 		bl	_txe_timer_change
3515:../uvc.c      **** 					CyU3PTimerStart(&I2CCmdTimer);
 258              		.loc 1 3515 0
 259 01dc 3C009FE5 		ldr	r0, .L22+4
 260 01e0 FEFFFFEB 		bl	_txe_timer_activate
 261 01e4 EAFFFFEA 		b	.L17
 262              	.LVL27:
 263              	.L21:
3503:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 264              		.loc 1 3503 0
 265 01e8 00C0D4E5 		ldrb	ip, [r4, #0]	@ zero_extendqisi2
3502:../uvc.c      **** 						lcCmdDes->cmdFlag = deswait;
 266              		.loc 1 3502 0
 267 01ec 3C9084E5 		str	r9, [r4, #60]
3503:../uvc.c      **** 						if(lcCmdDes->CmdID >= EXUAOFFSET){
 268              		.loc 1 3503 0
 269 01f0 1F005CE3 		cmp	ip, #31
3504:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 270              		.loc 1 3504 0
 271 01f4 20C04C82 		subhi	ip, ip, #32
 272 01f8 8CC08C80 		addhi	ip, ip, ip, asl #1
3506:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 273              		.loc 1 3506 0
 274 01fc 8CC08C90 		addls	ip, ip, ip, asl #1
3504:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 275              		.loc 1 3504 0
 276 0200 8CC18B80 		addhi	ip, fp, ip, asl #3
3506:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 277              		.loc 1 3506 0
 278 0204 8CC18B90 		addls	ip, fp, ip, asl #3
3504:../uvc.c      **** 							ExUCtrlParArry[(lcCmdDes->CmdID-EXUAOFFSET)][16] = CyFalse;
 279              		.loc 1 3504 0
 280 0208 1090CC85 		strhib	r9, [ip, #16]
3506:../uvc.c      **** 							CtrlParArry[lcCmdDes->CmdID][16] = CyFalse; //set flag to false. wait for check.
 281              		.loc 1 3506 0
 282 020c 9091CC95 		strlsb	r9, [ip, #400]
3508:../uvc.c      **** 						cmdQuptr->readPtr = lcCmdDes->cmdDesNext; //update command queue read pointer for next handle
 283              		.loc 1 3508 0
 284 0210 344094E5 		ldr	r4, [r4, #52]
 285              	.LVL28:
 286 0214 104085E5 		str	r4, [r5, #16]
 287 0218 DDFFFFEA 		b	.L17
 288              	.L23:
 289              		.align	2
 290              	.L22:
 291 021c 00000000 		.word	I2CCmdCb
 292 0220 00000000 		.word	I2CCmdTimer
 293 0224 00000000 		.word	.LC0
 294 0228 00000000 		.word	cmdQu
 295 022c 14000000 		.word	.LC1
 296 0230 00000000 		.word	statQu
 297 0234 00000000 		.word	.LANCHOR1
 298 0238 00000000 		.word	.LANCHOR0
 299              		.cfi_endproc
 300              	.LFE25:
 302              		.align	2
 303              		.global	I2CCmdCb
 305              	I2CCmdCb:
 306              	.LFB17:
2148:../uvc.c      **** void  I2CCmdCb(uint32_t input){
 307              		.loc 1 2148 0
 308              		.cfi_startproc
 309              		@ args = 0, pretend = 0, frame = 0
 310              		@ frame_needed = 0, uses_anonymous_args = 0
 311              		@ link register save eliminated.
 312              	.LVL29:
2150:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 313              		.loc 1 2150 0
 314 023c 08009FE5 		ldr	r0, .L25
 315              	.LVL30:
 316 0240 2010A0E3 		mov	r1, #32
 317 0244 0020A0E3 		mov	r2, #0
2151:../uvc.c      **** }
 318              		.loc 1 2151 0
2150:../uvc.c      **** 	CyU3PEventSet (&glFxUVCEvent, VD_FX_I2C_CMD_EVENT, CYU3P_EVENT_OR);
 319              		.loc 1 2150 0
 320 0248 FEFFFFEA 		b	_txe_event_flags_set
 321              	.L26:
 322              		.align	2
 323              	.L25:
 324 024c 00000000 		.word	.LANCHOR0
 325              		.cfi_endproc
 326              	.LFE17:
 328              		.align	2
 329              		.global	CyFxUvcApplnDmaCallback
 331              	CyFxUvcApplnDmaCallback:
 332              	.LFB10:
1439:../uvc.c      **** {
 333              		.loc 1 1439 0
 334              		.cfi_startproc
 335              		@ args = 0, pretend = 0, frame = 0
 336              		@ frame_needed = 0, uses_anonymous_args = 0
 337              	.LVL31:
1443:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 338              		.loc 1 1443 0
 339 0250 080051E3 		cmp	r1, #8
1439:../uvc.c      **** {
 340              		.loc 1 1439 0
 341 0254 30402DE9 		stmfd	sp!, {r4, r5, lr}
 342              	.LCFI2:
 343              		.cfi_def_cfa_offset 12
 344 0258 0240A0E1 		mov	r4, r2
 345              		.cfi_offset 14, -4
 346              		.cfi_offset 5, -8
 347              		.cfi_offset 4, -12
 348 025c 0CD04DE2 		sub	sp, sp, #12
 349              	.LCFI3:
 350              		.cfi_def_cfa_offset 24
1443:../uvc.c      ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 351              		.loc 1 1443 0
 352 0260 0B00000A 		beq	.L32
1472:../uvc.c      ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 353              		.loc 1 1472 0
 354 0264 100051E3 		cmp	r1, #16
 355 0268 0700001A 		bne	.L27
1474:../uvc.c      ****         consCount++;
 356              		.loc 1 1474 0
 357 026c 04319FE5 		ldr	r3, .L34
1475:../uvc.c      ****         streamingStarted = CyTrue;
 358              		.loc 1 1475 0
 359 0270 0120A0E3 		mov	r2, #1
 360              	.LVL32:
1474:../uvc.c      ****         consCount++;
 361              		.loc 1 1474 0
 362 0274 B0C3D3E1 		ldrh	ip, [r3, #48]
1475:../uvc.c      ****         streamingStarted = CyTrue;
 363              		.loc 1 1475 0
 364 0278 342083E5 		str	r2, [r3, #52]
1474:../uvc.c      ****         consCount++;
 365              		.loc 1 1474 0
 366 027c 02008CE0 		add	r0, ip, r2
 367              	.LVL33:
 368 0280 0018A0E1 		mov	r1, r0, asl #16
 369              	.LVL34:
 370 0284 2128A0E1 		mov	r2, r1, lsr #16
 371 0288 B023C3E1 		strh	r2, [r3, #48]	@ movhi
 372              	.L27:
1477:../uvc.c      **** }
 373              		.loc 1 1477 0
 374 028c 0CD08DE2 		add	sp, sp, #12
 375 0290 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 376              	.LVL35:
 377              	.L32:
1445:../uvc.c      ****             if (input->buffer_p.count == CY_FX_UVC_BUF_FULL_SIZE)
 378              		.loc 1 1445 0
 379 0294 B420D2E1 		ldrh	r2, [r2, #4]
 380 0298 DC309FE5 		ldr	r3, .L34+4
 381 029c 030052E1 		cmp	r2, r3
 382 02a0 2900000A 		beq	.L33
1453:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_E
 383              		.loc 1 1453 0
 384 02a4 005094E5 		ldr	r5, [r4, #0]
 385              	.LVL36:
 386              	.LBB14:
 387              	.LBB15:
1188:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 388              		.loc 1 1188 0
 389 02a8 D0109FE5 		ldr	r1, .L34+8
 390              	.LVL37:
 391 02ac 0C0045E2 		sub	r0, r5, #12
 392              	.LVL38:
 393 02b0 0C20A0E3 		mov	r2, #12
 394 02b4 FEFFFFEB 		bl	CyU3PMemCopy
 395              	.LVL39:
1193:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 396              		.loc 1 1193 0
 397 02b8 0BC055E5 		ldrb	ip, [r5, #-11]	@ zero_extendqisi2
 398              	.LBE15:
 399              	.LBE14:
1454:../uvc.c      ****                 pb++;
 400              		.loc 1 1454 0
 401 02bc B4309FE5 		ldr	r3, .L34
 402              	.LBB17:
 403              	.LBB16:
1193:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 404              		.loc 1 1193 0
 405 02c0 02108CE3 		orr	r1, ip, #2
 406 02c4 0B1045E5 		strb	r1, [r5, #-11]
 407              	.LBE16:
 408              	.LBE17:
1454:../uvc.c      ****                 pb++;
 409              		.loc 1 1454 0
 410 02c8 BA02D3E1 		ldrh	r0, [r3, #42]
1455:../uvc.c      ****                 pbc = input->buffer_p.count;
 411              		.loc 1 1455 0
 412 02cc B410D4E1 		ldrh	r1, [r4, #4]
1454:../uvc.c      ****                 pb++;
 413              		.loc 1 1454 0
 414 02d0 012080E2 		add	r2, r0, #1
 415 02d4 BA22C3E1 		strh	r2, [r3, #42]	@ movhi
1455:../uvc.c      ****                 pbc = input->buffer_p.count;
 416              		.loc 1 1455 0
 417 02d8 BC12C3E1 		strh	r1, [r3, #44]	@ movhi
 418              	.LVL40:
 419              	.L30:
1460:../uvc.c      ****             prodCount++;
 420              		.loc 1 1460 0
 421 02dc BEE2D3E1 		ldrh	lr, [r3, #46]
1461:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 422              		.loc 1 1461 0
 423 02e0 0C1081E2 		add	r1, r1, #12
1460:../uvc.c      ****             prodCount++;
 424              		.loc 1 1460 0
 425 02e4 01C08EE2 		add	ip, lr, #1
 426 02e8 0C08A0E1 		mov	r0, ip, asl #16
 427 02ec 20E8A0E1 		mov	lr, r0, lsr #16
1461:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 428              		.loc 1 1461 0
 429 02f0 0128A0E1 		mov	r2, r1, asl #16
 430 02f4 2218A0E1 		mov	r1, r2, lsr #16
 431 02f8 84009FE5 		ldr	r0, .L34+12
 432 02fc 0020A0E3 		mov	r2, #0
1460:../uvc.c      ****             prodCount++;
 433              		.loc 1 1460 0
 434 0300 BEE2C3E1 		strh	lr, [r3, #46]	@ movhi
1461:../uvc.c      ****             status = CyU3PDmaMultiChannelCommitBuffer (&glChHandleUVCStream,
 435              		.loc 1 1461 0
 436 0304 FEFFFFEB 		bl	CyU3PDmaMultiChannelCommitBuffer
 437              	.LVL41:
1460:../uvc.c      ****             prodCount++;
 438              		.loc 1 1460 0
 439 0308 68109FE5 		ldr	r1, .L34
1464:../uvc.c      ****             if (status != CY_U3P_SUCCESS)
 440              		.loc 1 1464 0
 441 030c 002050E2 		subs	r2, r0, #0
 442 0310 DDFFFF0A 		beq	.L27
1466:../uvc.c      ****                 prodCount--;
 443              		.loc 1 1466 0
 444 0314 BEC2D1E1 		ldrh	ip, [r1, #46]
1467:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 445              		.loc 1 1467 0
 446 0318 B430D4E1 		ldrh	r3, [r4, #4]
1466:../uvc.c      ****                 prodCount--;
 447              		.loc 1 1466 0
 448 031c 01004CE2 		sub	r0, ip, #1
 449              	.LVL42:
 450 0320 00E8A0E1 		mov	lr, r0, asl #16
 451 0324 2EC8A0E1 		mov	ip, lr, lsr #16
 452 0328 BEC2C1E1 		strh	ip, [r1, #46]	@ movhi
1467:../uvc.c      ****                 CyU3PDebugPrint (4, "Error in multichannelcommitbuffer: Code = %d, size = %x, dmaDo
 453              		.loc 1 1467 0
 454 032c BEE2D1E1 		ldrh	lr, [r1, #46]
 455 0330 B003D1E1 		ldrh	r0, [r1, #48]
 456 0334 4C109FE5 		ldr	r1, .L34+16
 457 0338 0EC060E0 		rsb	ip, r0, lr
 458 033c 0400A0E3 		mov	r0, #4
 459 0340 00C08DE5 		str	ip, [sp, #0]
 460 0344 FEFFFFEB 		bl	CyU3PDebugPrint
 461              	.LVL43:
 462 0348 CFFFFFEA 		b	.L27
 463              	.LVL44:
 464              	.L33:
1447:../uvc.c      ****                 CyFxUVCAddHeader (input->buffer_p.buffer - CY_FX_UVC_MAX_HEADER, CY_FX_UVC_HEADER_F
 465              		.loc 1 1447 0
 466 034c 00E094E5 		ldr	lr, [r4, #0]
 467              	.LBB18:
 468              	.LBB19:
1188:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 469              		.loc 1 1188 0
 470 0350 28109FE5 		ldr	r1, .L34+8
 471              	.LVL45:
 472 0354 0C004EE2 		sub	r0, lr, #12
 473              	.LVL46:
 474 0358 0C20A0E3 		mov	r2, #12
 475 035c FEFFFFEB 		bl	CyU3PMemCopy
 476              	.LVL47:
 477              	.LBE19:
 478              	.LBE18:
1448:../uvc.c      ****                 fb++;
 479              		.loc 1 1448 0
 480 0360 10309FE5 		ldr	r3, .L34
 481 0364 B410D4E1 		ldrh	r1, [r4, #4]
 482 0368 B8C2D3E1 		ldrh	ip, [r3, #40]
 483 036c 01008CE2 		add	r0, ip, #1
 484 0370 B802C3E1 		strh	r0, [r3, #40]	@ movhi
 485 0374 D8FFFFEA 		b	.L30
 486              	.L35:
 487              		.align	2
 488              	.L34:
 489 0378 00000000 		.word	.LANCHOR0
 490 037c F03F0000 		.word	16368
 491 0380 80040000 		.word	.LANCHOR1+1152
 492 0384 00000000 		.word	glChHandleUVCStream
 493 0388 38000000 		.word	.LC2
 494              		.cfi_endproc
 495              	.LFE10:
 497              		.align	2
 499              	CyFxUVCApplnUSBEventCB:
 500              	.LFB8:
1242:../uvc.c      **** {
 501              		.loc 1 1242 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 8
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505              	.LVL48:
1243:../uvc.c      ****     switch (evtype)
 506              		.loc 1 1243 0
 507 038c 020050E3 		cmp	r0, #2
1242:../uvc.c      **** {
 508              		.loc 1 1242 0
 509 0390 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 510              	.LCFI4:
 511              		.cfi_def_cfa_offset 16
 512 0394 0130A0E1 		mov	r3, r1
 513 0398 10D04DE2 		sub	sp, sp, #16
 514              	.LCFI5:
 515              		.cfi_def_cfa_offset 32
1242:../uvc.c      **** {
 516              		.loc 1 1242 0
 517 039c 0040A0E1 		mov	r4, r0
 518              		.cfi_offset 14, -4
 519              		.cfi_offset 6, -8
 520              		.cfi_offset 5, -12
 521              		.cfi_offset 4, -16
1243:../uvc.c      ****     switch (evtype)
 522              		.loc 1 1243 0
 523 03a0 3600000A 		beq	.L39
 524 03a4 040050E3 		cmp	r0, #4
 525 03a8 1F00000A 		beq	.L40
 526 03ac 010050E3 		cmp	r0, #1
 527 03b0 0100000A 		beq	.L42
 528              	.LVL49:
 529              	.L36:
1279:../uvc.c      **** }
 530              		.loc 1 1279 0
 531 03b4 10D08DE2 		add	sp, sp, #16
 532 03b8 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 533              	.LVL50:
 534              	.L42:
1264:../uvc.c      ****             gpif_initialized = 0;
 535              		.loc 1 1264 0
 536 03bc 28519FE5 		ldr	r5, .L43
1262:../uvc.c      ****             CyU3PDebugPrint (4, "USB disconnected...0x%x 0x%x\r\n", evtype, evdata);
 537              		.loc 1 1262 0
 538 03c0 0020A0E1 		mov	r2, r0
 539 03c4 24119FE5 		ldr	r1, .L43+4
 540              	.LVL51:
 541 03c8 0400A0E3 		mov	r0, #4
 542              	.LVL52:
 543 03cc FEFFFFEB 		bl	CyU3PDebugPrint
1263:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 544              		.loc 1 1263 0
 545 03d0 0400A0E1 		mov	r0, r4
 546 03d4 FEFFFFEB 		bl	CyU3PGpifDisable
1264:../uvc.c      ****             gpif_initialized = 0;
 547              		.loc 1 1264 0
 548 03d8 00C0A0E3 		mov	ip, #0
 549              	.LBB26:
 550              	.LBB27:
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 551              		.loc 1 1226 0
 552 03dc 0410A0E1 		mov	r1, r4
 553 03e0 0500A0E1 		mov	r0, r5
 554 03e4 0220A0E3 		mov	r2, #2
 555 03e8 0C308DE2 		add	r3, sp, #12
 556              	.LBE27:
 557              	.LBE26:
1264:../uvc.c      ****             gpif_initialized = 0;
 558              		.loc 1 1264 0
 559 03ec 38C085E5 		str	ip, [r5, #56]
1265:../uvc.c      ****             isUsbConnected = CyFalse;
 560              		.loc 1 1265 0
 561 03f0 3CC085E5 		str	ip, [r5, #60]
1266:../uvc.c      ****             streamingStarted = CyFalse;
 562              		.loc 1 1266 0
 563 03f4 34C085E5 		str	ip, [r5, #52]
 564              	.LBB29:
 565              	.LBB28:
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 566              		.loc 1 1226 0
 567 03f8 00C08DE5 		str	ip, [sp, #0]
 568 03fc FEFFFFEB 		bl	_txe_event_flags_get
 569 0400 004050E2 		subs	r4, r0, #0
 570 0404 EAFFFF1A 		bne	.L36
1229:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 571              		.loc 1 1229 0
 572 0408 0110E0E3 		mvn	r1, #1
 573 040c 0220A0E3 		mov	r2, #2
 574 0410 0500A0E1 		mov	r0, r5
 575              	.L41:
 576 0414 FEFFFFEB 		bl	_txe_event_flags_set
1232:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 577              		.loc 1 1232 0
 578 0418 0500A0E1 		mov	r0, r5
 579 041c 0210A0E3 		mov	r1, #2
 580 0420 0420A0E1 		mov	r2, r4
 581 0424 FEFFFFEB 		bl	_txe_event_flags_set
 582 0428 E1FFFFEA 		b	.L36
 583              	.LVL53:
 584              	.L40:
 585              	.LBE28:
 586              	.LBE29:
1248:../uvc.c      ****             gpif_initialized = 0;
 587              		.loc 1 1248 0
 588 042c B8509FE5 		ldr	r5, .L43
1246:../uvc.c      ****             CyU3PDebugPrint (4, "RESET encountered...0x%x 0x%x\r\n", evtype, evdata);
 589              		.loc 1 1246 0
 590 0430 BC109FE5 		ldr	r1, .L43+8
 591              	.LVL54:
 592 0434 0020A0E1 		mov	r2, r0
 593 0438 FEFFFFEB 		bl	CyU3PDebugPrint
 594              	.LVL55:
1247:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 595              		.loc 1 1247 0
 596 043c 0100A0E3 		mov	r0, #1
 597 0440 FEFFFFEB 		bl	CyU3PGpifDisable
1248:../uvc.c      ****             gpif_initialized = 0;
 598              		.loc 1 1248 0
 599 0444 00C0A0E3 		mov	ip, #0
 600              	.LBB30:
 601              	.LBB31:
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 602              		.loc 1 1226 0
 603 0448 0110A0E3 		mov	r1, #1
 604 044c 0220A0E3 		mov	r2, #2
 605 0450 0500A0E1 		mov	r0, r5
 606 0454 0C308DE2 		add	r3, sp, #12
 607              	.LBE31:
 608              	.LBE30:
1248:../uvc.c      ****             gpif_initialized = 0;
 609              		.loc 1 1248 0
 610 0458 38C085E5 		str	ip, [r5, #56]
1249:../uvc.c      ****             streamingStarted = CyFalse;
 611              		.loc 1 1249 0
 612 045c 34C085E5 		str	ip, [r5, #52]
 613              	.LBB33:
 614              	.LBB32:
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 615              		.loc 1 1226 0
 616 0460 00C08DE5 		str	ip, [sp, #0]
 617 0464 FEFFFFEB 		bl	_txe_event_flags_get
 618 0468 004050E2 		subs	r4, r0, #0
1229:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 619              		.loc 1 1229 0
 620 046c 0500A001 		moveq	r0, r5
 621 0470 0110E003 		mvneq	r1, #1
 622 0474 0220A003 		moveq	r2, #2
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 623              		.loc 1 1226 0
 624 0478 CDFFFF1A 		bne	.L36
 625 047c E4FFFFEA 		b	.L41
 626              	.LVL56:
 627              	.L39:
 628              	.LBE32:
 629              	.LBE33:
1256:../uvc.c      ****             gpif_initialized = 0;
 630              		.loc 1 1256 0
 631 0480 64509FE5 		ldr	r5, .L43
1254:../uvc.c      ****             CyU3PDebugPrint (4, "SUSPEND encountered...0x%x 0x%x\r\n", evtype, evdata);
 632              		.loc 1 1254 0
 633 0484 0020A0E1 		mov	r2, r0
 634 0488 68109FE5 		ldr	r1, .L43+12
 635              	.LVL57:
 636 048c 0400A0E3 		mov	r0, #4
 637              	.LVL58:
 638 0490 FEFFFFEB 		bl	CyU3PDebugPrint
1255:../uvc.c      ****             CyU3PGpifDisable (CyTrue);
 639              		.loc 1 1255 0
 640 0494 0100A0E3 		mov	r0, #1
 641 0498 FEFFFFEB 		bl	CyU3PGpifDisable
1256:../uvc.c      ****             gpif_initialized = 0;
 642              		.loc 1 1256 0
 643 049c 0060A0E3 		mov	r6, #0
 644              	.LBB34:
 645              	.LBB35:
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 646              		.loc 1 1226 0
 647 04a0 0500A0E1 		mov	r0, r5
 648 04a4 0110A0E3 		mov	r1, #1
 649 04a8 0420A0E1 		mov	r2, r4
 650 04ac 0C308DE2 		add	r3, sp, #12
 651              	.LBE35:
 652              	.LBE34:
1256:../uvc.c      ****             gpif_initialized = 0;
 653              		.loc 1 1256 0
 654 04b0 386085E5 		str	r6, [r5, #56]
1257:../uvc.c      ****             streamingStarted = CyFalse;
 655              		.loc 1 1257 0
 656 04b4 346085E5 		str	r6, [r5, #52]
 657              	.LBB37:
 658              	.LBB36:
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 659              		.loc 1 1226 0
 660 04b8 00608DE5 		str	r6, [sp, #0]
 661 04bc FEFFFFEB 		bl	_txe_event_flags_get
 662 04c0 006050E2 		subs	r6, r0, #0
 663 04c4 BAFFFF1A 		bne	.L36
1229:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 664              		.loc 1 1229 0
 665 04c8 0420A0E1 		mov	r2, r4
 666 04cc 0500A0E1 		mov	r0, r5
 667 04d0 0110E0E3 		mvn	r1, #1
 668 04d4 FEFFFFEB 		bl	_txe_event_flags_set
1232:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 669              		.loc 1 1232 0
 670 04d8 0500A0E1 		mov	r0, r5
 671 04dc 0410A0E1 		mov	r1, r4
 672 04e0 0620A0E1 		mov	r2, r6
 673 04e4 FEFFFFEB 		bl	_txe_event_flags_set
 674 04e8 B1FFFFEA 		b	.L36
 675              	.L44:
 676              		.align	2
 677              	.L43:
 678 04ec 00000000 		.word	.LANCHOR0
 679 04f0 C4000000 		.word	.LC5
 680 04f4 80000000 		.word	.LC3
 681 04f8 A0000000 		.word	.LC4
 682              	.LBE36:
 683              	.LBE37:
 684              		.cfi_endproc
 685              	.LFE8:
 687              		.align	2
 689              	CyFxUVCApplnUSBSetupCB:
 690              	.LFB9:
1287:../uvc.c      **** {
 691              		.loc 1 1287 0
 692              		.cfi_startproc
 693              		@ args = 0, pretend = 0, frame = 8
 694              		@ frame_needed = 0, uses_anonymous_args = 0
 695              	.LVL59:
1292:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 696              		.loc 1 1292 0
 697 04fc C0329FE5 		ldr	r3, .L70
1287:../uvc.c      **** {
 698              		.loc 1 1287 0
 699 0500 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 700              	.LCFI6:
 701              		.cfi_def_cfa_offset 24
1293:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 702              		.loc 1 1293 0
 703 0504 BCC29FE5 		ldr	ip, .L70+4
1292:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 704              		.loc 1 1292 0
 705 0508 FF4000E2 		and	r4, r0, #255
 706              		.cfi_offset 14, -4
 707              		.cfi_offset 8, -8
 708              		.cfi_offset 7, -12
 709              		.cfi_offset 6, -16
 710              		.cfi_offset 5, -20
 711              		.cfi_offset 4, -24
1293:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 712              		.loc 1 1293 0
 713 050c FF8C00E2 		and	r8, r0, #65280
1294:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 714              		.loc 1 1294 0
 715 0510 2078A0E1 		mov	r7, r0, lsr #16
1292:../uvc.c      ****     bmReqType = (uint8_t)(setupdat0 & CY_FX_USB_SETUP_REQ_TYPE_MASK);
 716              		.loc 1 1292 0
 717 0514 0040C3E5 		strb	r4, [r3, #0]
1294:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 718              		.loc 1 1294 0
 719 0518 AC229FE5 		ldr	r2, .L70+8
1295:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 720              		.loc 1 1295 0
 721 051c AC029FE5 		ldr	r0, .L70+12
 722              	.LVL60:
1296:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 723              		.loc 1 1296 0
 724 0520 AC329FE5 		ldr	r3, .L70+16
1295:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 725              		.loc 1 1295 0
 726 0524 0158A0E1 		mov	r5, r1, asl #16
1293:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 727              		.loc 1 1293 0
 728 0528 2884A0E1 		mov	r8, r8, lsr #8
1295:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 729              		.loc 1 1295 0
 730 052c 2558A0E1 		mov	r5, r5, lsr #16
1296:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 731              		.loc 1 1296 0
 732 0530 2118A0E1 		mov	r1, r1, lsr #16
 733              	.LVL61:
1299:../uvc.c      ****     switch (bmReqType)
 734              		.loc 1 1299 0
 735 0534 020054E3 		cmp	r4, #2
1287:../uvc.c      **** {
 736              		.loc 1 1287 0
 737 0538 10D04DE2 		sub	sp, sp, #16
 738              	.LCFI7:
 739              		.cfi_def_cfa_offset 40
1293:../uvc.c      ****     bRequest  = (uint8_t)((setupdat0 & CY_FX_USB_SETUP_REQ_MASK) >> 8);
 740              		.loc 1 1293 0
 741 053c 0080CCE5 		strb	r8, [ip, #0]
1294:../uvc.c      ****     wValue    = (uint16_t)((setupdat0 & CY_FX_USB_SETUP_VALUE_MASK) >> 16);
 742              		.loc 1 1294 0
 743 0540 B070C2E1 		strh	r7, [r2, #0]	@ movhi
1295:../uvc.c      ****     wIndex    = (uint16_t)(setupdat1 & CY_FX_USB_SETUP_INDEX_MASK);
 744              		.loc 1 1295 0
 745 0544 B050C0E1 		strh	r5, [r0, #0]	@ movhi
1296:../uvc.c      ****     wLength   = (uint16_t)((setupdat1 & CY_FX_USB_SETUP_LENGTH_MASK) >> 16);
 746              		.loc 1 1296 0
 747 0548 B010C3E1 		strh	r1, [r3, #0]	@ movhi
1299:../uvc.c      ****     switch (bmReqType)
 748              		.loc 1 1299 0
 749 054c 4F00000A 		beq	.L48
 750 0550 0600009A 		bls	.L66
 751 0554 210054E3 		cmp	r4, #33
 752 0558 3A00000A 		beq	.L49
 753 055c A10054E3 		cmp	r4, #161
 754 0560 3800000A 		beq	.L49
 755              	.L63:
1288:../uvc.c      ****     CyBool_t uvcHandleReq = CyFalse;
 756              		.loc 1 1288 0
 757 0564 0000A0E3 		mov	r0, #0
 758              	.LVL62:
 759              	.L46:
1426:../uvc.c      **** }
 760              		.loc 1 1426 0
 761 0568 10D08DE2 		add	sp, sp, #16
 762 056c F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 763              	.LVL63:
 764              	.L66:
1299:../uvc.c      ****     switch (bmReqType)
 765              		.loc 1 1299 0
 766 0570 010054E3 		cmp	r4, #1
 767 0574 FAFFFF1A 		bne	.L63
1339:../uvc.c      ****             if (bRequest == CY_FX_USB_SET_INTERFACE_REQ)
 768              		.loc 1 1339 0
 769 0578 0B0058E3 		cmp	r8, #11
 770 057c F8FFFF1A 		bne	.L63
1343:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 771              		.loc 1 1343 0
 772 0580 010055E3 		cmp	r5, #1
 773 0584 F6FFFF1A 		bne	.L63
1343:../uvc.c      ****                 if ((wIndex == CY_FX_UVC_STREAM_INTERFACE) && (wValue == 0))
 774              		.loc 1 1343 0 is_stmt 0 discriminator 1
 775 0588 000057E3 		cmp	r7, #0
 776 058c F4FFFF1A 		bne	.L63
1348:../uvc.c      ****                     gpif_initialized = 0;
 777              		.loc 1 1348 0 is_stmt 1
 778 0590 40429FE5 		ldr	r4, .L70+20
1346:../uvc.c      ****                 	CyU3PDebugPrint (4, "Alternate setting 0..\r\n");
 779              		.loc 1 1346 0
 780 0594 40129FE5 		ldr	r1, .L70+24
 781 0598 0400A0E3 		mov	r0, #4
 782 059c FEFFFFEB 		bl	CyU3PDebugPrint
1347:../uvc.c      ****                     CyU3PGpifDisable (CyTrue);
 783              		.loc 1 1347 0
 784 05a0 0500A0E1 		mov	r0, r5
 785 05a4 FEFFFFEB 		bl	CyU3PGpifDisable
1351:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 786              		.loc 1 1351 0
 787 05a8 0510A0E1 		mov	r1, r5
 788 05ac 8300A0E3 		mov	r0, #131
1348:../uvc.c      ****                     gpif_initialized = 0;
 789              		.loc 1 1348 0
 790 05b0 387084E5 		str	r7, [r4, #56]
1349:../uvc.c      ****                     streamingStarted = CyFalse;
 791              		.loc 1 1349 0
 792 05b4 347084E5 		str	r7, [r4, #52]
1351:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 793              		.loc 1 1351 0
 794 05b8 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1352:../uvc.c      ****                     CyU3PBusyWait (100);
 795              		.loc 1 1352 0
 796 05bc 6400A0E3 		mov	r0, #100
 797 05c0 FEFFFFEB 		bl	CyU3PBusyWait
1355:../uvc.c      ****                     CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 798              		.loc 1 1355 0
 799 05c4 14029FE5 		ldr	r0, .L70+28
 800 05c8 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1356:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 801              		.loc 1 1356 0
 802 05cc 8300A0E3 		mov	r0, #131
 803 05d0 FEFFFFEB 		bl	CyU3PUsbFlushEp
1357:../uvc.c      ****                     CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 804              		.loc 1 1357 0
 805 05d4 0710A0E1 		mov	r1, r7
 806 05d8 8300A0E3 		mov	r0, #131
 807 05dc FEFFFFEB 		bl	CyU3PUsbSetEpNak
1358:../uvc.c      ****                     CyU3PBusyWait (100);
 808              		.loc 1 1358 0
 809 05e0 6400A0E3 		mov	r0, #100
 810 05e4 FEFFFFEB 		bl	CyU3PBusyWait
1361:../uvc.c      ****                     CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 811              		.loc 1 1361 0
 812 05e8 0710A0E1 		mov	r1, r7
 813 05ec 0520A0E1 		mov	r2, r5
 814 05f0 8300A0E3 		mov	r0, #131
 815 05f4 FEFFFFEB 		bl	CyU3PUsbStall
 816              	.LVL64:
1364:../uvc.c      ****                     CyU3PUsbAckSetup ();
 817              		.loc 1 1364 0
 818 05f8 FEFFFFEB 		bl	CyU3PUsbAckSetup
1366:../uvc.c      ****                     clearFeatureRqtReceived = CyTrue;
 819              		.loc 1 1366 0
 820 05fc 405084E5 		str	r5, [r4, #64]
 821              	.LBB42:
 822              	.LBB43:
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 823              		.loc 1 1226 0
 824 0600 0400A0E1 		mov	r0, r4
 825 0604 0510A0E1 		mov	r1, r5
 826 0608 0220A0E3 		mov	r2, #2
 827 060c 0C308DE2 		add	r3, sp, #12
 828 0610 00708DE5 		str	r7, [sp, #0]
 829 0614 FEFFFFEB 		bl	_txe_event_flags_get
 830 0618 006050E2 		subs	r6, r0, #0
 831 061c 2E00001A 		bne	.L61
1229:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 832              		.loc 1 1229 0
 833 0620 0110E0E3 		mvn	r1, #1
 834 0624 0220A0E3 		mov	r2, #2
 835 0628 0400A0E1 		mov	r0, r4
 836 062c FEFFFFEB 		bl	_txe_event_flags_set
1232:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 837              		.loc 1 1232 0
 838 0630 0400A0E1 		mov	r0, r4
 839 0634 0210A0E3 		mov	r1, #2
 840 0638 0620A0E1 		mov	r2, r6
 841 063c FEFFFFEB 		bl	_txe_event_flags_set
1362:../uvc.c      ****                     uvcHandleReq = CyTrue;
 842              		.loc 1 1362 0
 843 0640 0500A0E1 		mov	r0, r5
 844 0644 C7FFFFEA 		b	.L46
 845              	.LVL65:
 846              	.L49:
 847              	.LBE43:
 848              	.LBE42:
1304:../uvc.c      ****             switch (wIndex & 0xFF)
 849              		.loc 1 1304 0
 850 0648 FF5015E2 		ands	r5, r5, #255
 851 064c 1A00001A 		bne	.L67
 852              	.LVL66:
1309:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVEN
 853              		.loc 1 1309 0
 854 0650 0520A0E1 		mov	r2, r5
 855 0654 7C019FE5 		ldr	r0, .L70+20
 856 0658 0410A0E3 		mov	r1, #4
 857 065c FEFFFFEB 		bl	_txe_event_flags_set
 858              	.LVL67:
1311:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 859              		.loc 1 1311 0
 860 0660 002050E2 		subs	r2, r0, #0
1308:../uvc.c      ****                         uvcHandleReq = CyTrue;
 861              		.loc 1 1308 0
 862 0664 0100A003 		moveq	r0, #1
 863              	.LVL68:
1311:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 864              		.loc 1 1311 0
 865 0668 BEFFFF0A 		beq	.L46
1313:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %
 866              		.loc 1 1313 0
 867 066c 70119FE5 		ldr	r1, .L70+32
 868 0670 0400A0E3 		mov	r0, #4
 869 0674 FEFFFFEB 		bl	CyU3PDebugPrint
 870              	.LVL69:
1314:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 871              		.loc 1 1314 0
 872 0678 0500A0E1 		mov	r0, r5
 873 067c 0110A0E3 		mov	r1, #1
 874 0680 0520A0E1 		mov	r2, r5
 875 0684 FEFFFFEB 		bl	CyU3PUsbStall
1308:../uvc.c      ****                         uvcHandleReq = CyTrue;
 876              		.loc 1 1308 0
 877 0688 0100A0E3 		mov	r0, #1
 878 068c B5FFFFEA 		b	.L46
 879              	.LVL70:
 880              	.L48:
1374:../uvc.c      ****             if (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 881              		.loc 1 1374 0
 882 0690 010058E3 		cmp	r8, #1
 883 0694 B2FFFF1A 		bne	.L63
1376:../uvc.c      ****                 if (wIndex == CY_FX_EP_BULK_VIDEO)
 884              		.loc 1 1376 0
 885 0698 830055E3 		cmp	r5, #131
 886 069c B0FFFF1A 		bne	.L63
1382:../uvc.c      ****                     if (streamingStarted == CyTrue)
 887              		.loc 1 1382 0
 888 06a0 30719FE5 		ldr	r7, .L70+20
 889 06a4 346097E5 		ldr	r6, [r7, #52]
 890 06a8 010056E3 		cmp	r6, #1
 891 06ac 1500000A 		beq	.L68
 892              	.LVL71:
1414:../uvc.c      ****                         CyU3PUsbAckSetup ();
 893              		.loc 1 1414 0
 894 06b0 FEFFFFEB 		bl	CyU3PUsbAckSetup
1413:../uvc.c      ****                         uvcHandleReq = CyTrue;
 895              		.loc 1 1413 0
 896 06b4 0800A0E1 		mov	r0, r8
 897 06b8 AAFFFFEA 		b	.L46
 898              	.LVL72:
 899              	.L67:
1304:../uvc.c      ****             switch (wIndex & 0xFF)
 900              		.loc 1 1304 0
 901 06bc 010055E3 		cmp	r5, #1
 902 06c0 A7FFFF1A 		bne	.L63
 903              	.LVL73:
1322:../uvc.c      ****                         status = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT
 904              		.loc 1 1322 0
 905 06c4 0020A0E3 		mov	r2, #0
 906 06c8 08019FE5 		ldr	r0, .L70+20
 907 06cc 0810A0E3 		mov	r1, #8
 908 06d0 FEFFFFEB 		bl	_txe_event_flags_set
 909              	.LVL74:
1324:../uvc.c      ****                         if (status != CY_U3P_SUCCESS)
 910              		.loc 1 1324 0
 911 06d4 002050E2 		subs	r2, r0, #0
 912 06d8 0100001A 		bne	.L69
 913              	.LVL75:
 914              	.L61:
 915              	.LBB45:
 916              	.LBB44:
1362:../uvc.c      ****                     uvcHandleReq = CyTrue;
 917              		.loc 1 1362 0
 918 06dc 0500A0E1 		mov	r0, r5
 919 06e0 A0FFFFEA 		b	.L46
 920              	.LVL76:
 921              	.L69:
 922              	.LBE44:
 923              	.LBE45:
1327:../uvc.c      ****                             CyU3PDebugPrint (4, "Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x
 924              		.loc 1 1327 0
 925 06e4 FC109FE5 		ldr	r1, .L70+36
 926 06e8 0400A0E3 		mov	r0, #4
 927              	.LVL77:
 928 06ec FEFFFFEB 		bl	CyU3PDebugPrint
 929              	.LVL78:
1328:../uvc.c      ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 930              		.loc 1 1328 0
 931 06f0 0000A0E3 		mov	r0, #0
 932 06f4 0510A0E1 		mov	r1, r5
 933 06f8 0020A0E1 		mov	r2, r0
 934 06fc FEFFFFEB 		bl	CyU3PUsbStall
1321:../uvc.c      ****                         uvcHandleReq = CyTrue;
 935              		.loc 1 1321 0
 936 0700 0500A0E1 		mov	r0, r5
 937 0704 97FFFFEA 		b	.L46
 938              	.LVL79:
 939              	.L68:
1384:../uvc.c      ****                         CyU3PDebugPrint (4, "Clear feature request detected..\r\n");
 940              		.loc 1 1384 0
 941 0708 DC109FE5 		ldr	r1, .L70+40
 942 070c 0400A0E3 		mov	r0, #4
 943 0710 FEFFFFEB 		bl	CyU3PDebugPrint
1388:../uvc.c      ****                         gpif_initialized = 0;
 944              		.loc 1 1388 0
 945 0714 0080A0E3 		mov	r8, #0
1387:../uvc.c      ****                         CyU3PGpifDisable (CyTrue);
 946              		.loc 1 1387 0
 947 0718 0600A0E1 		mov	r0, r6
 948 071c FEFFFFEB 		bl	CyU3PGpifDisable
1392:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 949              		.loc 1 1392 0
 950 0720 0610A0E1 		mov	r1, r6
 951 0724 0500A0E1 		mov	r0, r5
1388:../uvc.c      ****                         gpif_initialized = 0;
 952              		.loc 1 1388 0
 953 0728 388087E5 		str	r8, [r7, #56]
1389:../uvc.c      ****                         streamingStarted = CyFalse;
 954              		.loc 1 1389 0
 955 072c 348087E5 		str	r8, [r7, #52]
1392:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyTrue);
 956              		.loc 1 1392 0
 957 0730 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1393:../uvc.c      ****                         CyU3PBusyWait (100);
 958              		.loc 1 1393 0
 959 0734 6400A0E3 		mov	r0, #100
 960 0738 FEFFFFEB 		bl	CyU3PBusyWait
1396:../uvc.c      ****                         CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 961              		.loc 1 1396 0
 962 073c 9C009FE5 		ldr	r0, .L70+28
 963 0740 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
1397:../uvc.c      ****                         CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 964              		.loc 1 1397 0
 965 0744 0500A0E1 		mov	r0, r5
 966 0748 FEFFFFEB 		bl	CyU3PUsbFlushEp
1398:../uvc.c      ****                         CyU3PUsbSetEpNak (CY_FX_EP_BULK_VIDEO, CyFalse);
 967              		.loc 1 1398 0
 968 074c 0810A0E1 		mov	r1, r8
 969 0750 0500A0E1 		mov	r0, r5
 970 0754 FEFFFFEB 		bl	CyU3PUsbSetEpNak
1399:../uvc.c      ****                         CyU3PBusyWait (100);
 971              		.loc 1 1399 0
 972 0758 6400A0E3 		mov	r0, #100
 973 075c FEFFFFEB 		bl	CyU3PBusyWait
1402:../uvc.c      ****                         CyU3PUsbStall (CY_FX_EP_BULK_VIDEO, CyFalse, CyTrue);
 974              		.loc 1 1402 0
 975 0760 0810A0E1 		mov	r1, r8
 976 0764 0620A0E1 		mov	r2, r6
 977 0768 0500A0E1 		mov	r0, r5
 978 076c FEFFFFEB 		bl	CyU3PUsbStall
 979              	.LVL80:
1406:../uvc.c      ****                         CyU3PUsbAckSetup ();
 980              		.loc 1 1406 0
 981 0770 FEFFFFEB 		bl	CyU3PUsbAckSetup
1408:../uvc.c      ****                         clearFeatureRqtReceived = CyTrue;
 982              		.loc 1 1408 0
 983 0774 406087E5 		str	r6, [r7, #64]
 984              	.LBB46:
 985              	.LBB47:
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 986              		.loc 1 1226 0
 987 0778 0700A0E1 		mov	r0, r7
 988 077c 0610A0E1 		mov	r1, r6
 989 0780 0420A0E1 		mov	r2, r4
 990 0784 0C308DE2 		add	r3, sp, #12
 991 0788 00808DE5 		str	r8, [sp, #0]
 992 078c FEFFFFEB 		bl	_txe_event_flags_get
 993 0790 005050E2 		subs	r5, r0, #0
1404:../uvc.c      ****                         uvcHandleReq = CyTrue;
 994              		.loc 1 1404 0
 995 0794 0600A011 		movne	r0, r6
1226:../uvc.c      **** 	if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,CYU3P_NO_WAIT) ==
 996              		.loc 1 1226 0
 997 0798 72FFFF1A 		bne	.L46
1229:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, ~(CY_FX_UVC_STREAM_EVENT), CYU3P_EVENT_AND);
 998              		.loc 1 1229 0
 999 079c 0110E0E3 		mvn	r1, #1
 1000 07a0 0420A0E1 		mov	r2, r4
 1001 07a4 0700A0E1 		mov	r0, r7
 1002 07a8 FEFFFFEB 		bl	_txe_event_flags_set
1232:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_OR);
 1003              		.loc 1 1232 0
 1004 07ac 0700A0E1 		mov	r0, r7
 1005 07b0 0410A0E1 		mov	r1, r4
 1006 07b4 0520A0E1 		mov	r2, r5
 1007 07b8 FEFFFFEB 		bl	_txe_event_flags_set
1404:../uvc.c      ****                         uvcHandleReq = CyTrue;
 1008              		.loc 1 1404 0
 1009 07bc 0600A0E1 		mov	r0, r6
 1010 07c0 68FFFFEA 		b	.L46
 1011              	.L71:
 1012              		.align	2
 1013              	.L70:
 1014 07c4 00000000 		.word	bmReqType
 1015 07c8 00000000 		.word	bRequest
 1016 07cc 00000000 		.word	wValue
 1017 07d0 00000000 		.word	wIndex
 1018 07d4 00000000 		.word	wLength
 1019 07d8 00000000 		.word	.LANCHOR0
 1020 07dc 50010000 		.word	.LC8
 1021 07e0 00000000 		.word	glChHandleUVCStream
 1022 07e4 E4000000 		.word	.LC6
 1023 07e8 1C010000 		.word	.LC7
 1024 07ec 68010000 		.word	.LC9
 1025              	.LBE47:
 1026              	.LBE46:
 1027              		.cfi_endproc
 1028              	.LFE9:
 1030              		.align	2
 1031              		.global	CyFxGpifCB
 1033              	CyFxGpifCB:
 1034              	.LFB12:
1597:../uvc.c      **** {
 1035              		.loc 1 1597 0
 1036              		.cfi_startproc
 1037              		@ args = 0, pretend = 0, frame = 0
 1038              		@ frame_needed = 0, uses_anonymous_args = 0
 1039              	.LVL81:
1598:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1040              		.loc 1 1598 0
 1041 07f0 010050E3 		cmp	r0, #1
1597:../uvc.c      **** {
 1042              		.loc 1 1597 0
 1043 07f4 10402DE9 		stmfd	sp!, {r4, lr}
 1044              	.LCFI8:
 1045              		.cfi_def_cfa_offset 8
1597:../uvc.c      **** {
 1046              		.loc 1 1597 0
 1047 07f8 0120A0E1 		mov	r2, r1
1598:../uvc.c      ****     if (event == CYU3P_GPIF_EVT_SM_INTERRUPT)
 1048              		.loc 1 1598 0
 1049 07fc 1080BD18 		ldmnefd	sp!, {r4, pc}
 1050              		.cfi_offset 14, -4
 1051              		.cfi_offset 4, -8
1600:../uvc.c      ****         hitFV = CyTrue;
 1052              		.loc 1 1600 0
 1053 0800 D0109FE5 		ldr	r1, .L88
 1054              	.LVL82:
 1055              	.LBB52:
 1056              	.LBB54:
1497:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1057              		.loc 1 1497 0
 1058 0804 4830D1E5 		ldrb	r3, [r1, #72]	@ zero_extendqisi2
 1059              	.LBE54:
 1060              	.LBE52:
1600:../uvc.c      ****         hitFV = CyTrue;
 1061              		.loc 1 1600 0
 1062 0808 440081E5 		str	r0, [r1, #68]
 1063              	.LVL83:
 1064              	.LBB58:
 1065              	.LBB53:
1497:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 1066              		.loc 1 1497 0
 1067 080c 030053E3 		cmp	r3, #3
 1068 0810 2800000A 		beq	.L87
1521:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 1069              		.loc 1 1521 0
 1070 0814 020053E3 		cmp	r3, #2
 1071 0818 1080BD18 		ldmnefd	sp!, {r4, pc}
1523:../uvc.c      ****         switch (stateId)
 1072              		.loc 1 1523 0
 1073 081c 080042E2 		sub	r0, r2, #8
 1074              	.LVL84:
 1075 0820 0A0050E3 		cmp	r0, #10
 1076 0824 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 1077 0828 1B0000EA 		b	.L80
 1078              	.L82:
 1079 082c 5C080000 		.word	.L76
 1080 0830 9C080000 		.word	.L80
 1081 0834 9C080000 		.word	.L80
 1082 0838 58080000 		.word	.L72
 1083 083c 9C080000 		.word	.L80
 1084 0840 9C080000 		.word	.L80
 1085 0844 9C080000 		.word	.L80
 1086 0848 94080000 		.word	.L86
 1087 084c 9C080000 		.word	.L80
 1088 0850 9C080000 		.word	.L80
 1089 0854 58080000 		.word	.L72
 1090              	.LVL85:
 1091              	.L72:
 1092 0858 1080BDE8 		ldmfd	sp!, {r4, pc}
 1093              	.LVL86:
 1094              	.L76:
1507:../uvc.c      ****                 socket = 0;
 1095              		.loc 1 1507 0
 1096 085c 0010A0E3 		mov	r1, #0
 1097              	.L77:
 1098              	.LVL87:
1580:../uvc.c      ****         apiRetStatus = CyU3PDmaMultiChannelSetWrapUp (handle, socket);
 1099              		.loc 1 1580 0
 1100 0860 74009FE5 		ldr	r0, .L88+4
 1101 0864 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetWrapUp
 1102              	.LVL88:
1581:../uvc.c      ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1103              		.loc 1 1581 0
 1104 0868 002050E2 		subs	r2, r0, #0
 1105 086c F9FFFF0A 		beq	.L72
1583:../uvc.c      ****             CyU3PDebugPrint (4, "Channel Set WrapUp failed, Error code = %d\r\n", apiRetStatus);
 1106              		.loc 1 1583 0
 1107 0870 0400A0E3 		mov	r0, #4
 1108              	.LVL89:
 1109 0874 64109FE5 		ldr	r1, .L88+8
 1110 0878 FEFFFFEB 		bl	CyU3PDebugPrint
 1111              	.LVL90:
 1112              	.L83:
 1113              	.LBB55:
 1114              	.LBB56:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 1115              		.loc 1 1213 0
 1116 087c 60109FE5 		ldr	r1, .L88+12
 1117 0880 0400A0E3 		mov	r0, #4
 1118 0884 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 1119              		.loc 1 1214 0
 1120 0888 FA0FA0E3 		mov	r0, #1000
 1121 088c FEFFFFEB 		bl	_tx_thread_sleep
 1122 0890 F9FFFFEA 		b	.L83
 1123              	.LVL91:
 1124              	.L86:
 1125              	.LBE56:
 1126              	.LBE55:
1550:../uvc.c      ****                 socket = 1;
 1127              		.loc 1 1550 0
 1128 0894 0110A0E3 		mov	r1, #1
 1129 0898 F0FFFFEA 		b	.L77
 1130              	.L80:
1569:../uvc.c      ****             	CyU3PDebugPrint(1,"\r\n commiteof state = %d",stateId);
 1131              		.loc 1 1569 0
 1132 089c 44109FE5 		ldr	r1, .L88+16
 1133 08a0 0100A0E3 		mov	r0, #1
 1134 08a4 FEFFFFEB 		bl	CyU3PDebugPrint
 1135              	.LVL92:
 1136              	.LBE53:
 1137              	.LBE58:
1602:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1138              		.loc 1 1602 0
 1139 08a8 3C109FE5 		ldr	r1, .L88+20
 1140 08ac 0400A0E3 		mov	r0, #4
1604:../uvc.c      **** }
 1141              		.loc 1 1604 0
 1142 08b0 1040BDE8 		ldmfd	sp!, {r4, lr}
1602:../uvc.c      ****             CyU3PDebugPrint (4, "Commit EOF failed!\n");
 1143              		.loc 1 1602 0
 1144 08b4 FEFFFFEA 		b	CyU3PDebugPrint
 1145              	.LVL93:
 1146              	.L87:
 1147              	.LBB59:
 1148              	.LBB57:
1499:../uvc.c      ****         switch (stateId)
 1149              		.loc 1 1499 0
 1150 08b8 0B3042E2 		sub	r3, r2, #11
 1151 08bc 030053E3 		cmp	r3, #3
 1152 08c0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1153 08c4 F4FFFFEA 		b	.L80
 1154              	.L78:
 1155 08c8 5C080000 		.word	.L76
 1156 08cc 94080000 		.word	.L86
 1157 08d0 58080000 		.word	.L72
 1158 08d4 58080000 		.word	.L72
 1159              	.L89:
 1160              		.align	2
 1161              	.L88:
 1162 08d8 00000000 		.word	.LANCHOR0
 1163 08dc 00000000 		.word	glChHandleUVCStream
 1164 08e0 A4010000 		.word	.LC11
 1165 08e4 D4010000 		.word	.LC12
 1166 08e8 8C010000 		.word	.LC10
 1167 08ec E8010000 		.word	.LC13
 1168              	.LBE57:
 1169              	.LBE59:
 1170              		.cfi_endproc
 1171              	.LFE12:
 1173              		.align	2
 1174              		.global	I2CCmdHandler
 1176              	I2CCmdHandler:
 1177              	.LFB0:
 310:../uvc.c      **** void I2CCmdHandler(){
 1178              		.loc 1 310 0
 1179              		.cfi_startproc
 1180              		@ args = 0, pretend = 0, frame = 16
 1181              		@ frame_needed = 0, uses_anonymous_args = 0
 1182 08f0 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1183              	.LCFI9:
 1184              		.cfi_def_cfa_offset 36
 313:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1185              		.loc 1 313 0
 1186 08f4 50419FE5 		ldr	r4, .L101
 1187              		.cfi_offset 14, -4
 1188              		.cfi_offset 11, -8
 1189              		.cfi_offset 10, -12
 1190              		.cfi_offset 9, -16
 1191              		.cfi_offset 8, -20
 1192              		.cfi_offset 7, -24
 1193              		.cfi_offset 6, -28
 1194              		.cfi_offset 5, -32
 1195              		.cfi_offset 4, -36
 310:../uvc.c      **** void I2CCmdHandler(){
 1196              		.loc 1 310 0
 1197 08f8 3CD04DE2 		sub	sp, sp, #60
 1198              	.LCFI10:
 1199              		.cfi_def_cfa_offset 96
 318:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1200              		.loc 1 318 0
 1201 08fc 5520D4E5 		ldrb	r2, [r4, #85]	@ zero_extendqisi2
 313:../uvc.c      **** 	CmdType = I2CCMDArry[0];
 1202              		.loc 1 313 0
 1203 0900 4C50D4E5 		ldrb	r5, [r4, #76]	@ zero_extendqisi2
 1204              	.LVL94:
 318:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1205              		.loc 1 318 0
 1206 0904 4D30D4E5 		ldrb	r3, [r4, #77]	@ zero_extendqisi2
 315:../uvc.c      **** 	CmdDataLen = I2CCMDArry[8];
 1207              		.loc 1 315 0
 1208 0908 5460D4E5 		ldrb	r6, [r4, #84]	@ zero_extendqisi2
 1209              	.LVL95:
 318:../uvc.c      **** 	CyU3PDebugPrint (4, "The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\r\n
 1210              		.loc 1 318 0
 1211 090c 4E70D4E5 		ldrb	r7, [r4, #78]	@ zero_extendqisi2
 1212 0910 4FE0D4E5 		ldrb	lr, [r4, #79]	@ zero_extendqisi2
 1213 0914 5080D4E5 		ldrb	r8, [r4, #80]	@ zero_extendqisi2
 1214 0918 51A0D4E5 		ldrb	sl, [r4, #81]	@ zero_extendqisi2
 1215 091c 5290D4E5 		ldrb	r9, [r4, #82]	@ zero_extendqisi2
 1216 0920 53B0D4E5 		ldrb	fp, [r4, #83]	@ zero_extendqisi2
 1217 0924 1C208DE5 		str	r2, [sp, #28]
 1218 0928 56C0D4E5 		ldrb	ip, [r4, #86]	@ zero_extendqisi2
 1219 092c 0400A0E3 		mov	r0, #4
 1220 0930 18119FE5 		ldr	r1, .L101+4
 1221 0934 0520A0E1 		mov	r2, r5
 1222 0938 80408DE8 		stmia	sp, {r7, lr}	@ phole stm
 1223 093c 08808DE5 		str	r8, [sp, #8]
 1224 0940 0CA08DE5 		str	sl, [sp, #12]
 1225 0944 10908DE5 		str	r9, [sp, #16]
 1226 0948 14B08DE5 		str	fp, [sp, #20]
 1227 094c 18608DE5 		str	r6, [sp, #24]
 1228 0950 20C08DE5 		str	ip, [sp, #32]
 1229 0954 FEFFFFEB 		bl	CyU3PDebugPrint
 1230              	.LVL96:
 322:../uvc.c      **** 	if(CmdType == 0)//I2C read
 1231              		.loc 1 322 0
 1232 0958 000055E3 		cmp	r5, #0
 1233 095c 1000000A 		beq	.L98
 347:../uvc.c      **** 	}else if(CmdType == 1){
 1234              		.loc 1 347 0
 1235 0960 010055E3 		cmp	r5, #1
 1236 0964 0100000A 		beq	.L99
 1237              	.LVL97:
 1238              	.L90:
 360:../uvc.c      **** }
 1239              		.loc 1 360 0
 1240 0968 3CD08DE2 		add	sp, sp, #60
 1241 096c F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1242              	.LVL98:
 1243              	.L99:
 349:../uvc.c      **** 			if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1244              		.loc 1 349 0
 1245 0970 4F20D4E5 		ldrb	r2, [r4, #79]	@ zero_extendqisi2
 1246 0974 FE1002E2 		and	r1, r2, #254
 1247 0978 820051E3 		cmp	r1, #130
 352:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 1248              		.loc 1 352 0
 1249 097c 5050D415 		ldrneb	r5, [r4, #80]	@ zero_extendqisi2
 1250              	.LVL99:
 349:../uvc.c      **** 			if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1251              		.loc 1 349 0
 1252 0980 1A00000A 		beq	.L100
 1253              	.L97:
 352:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 1254              		.loc 1 352 0
 1255 0984 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1256              	.L96:
 354:../uvc.c      **** 			else SensorWrite2B(I2CCMDArry[2]&I2C_WR_MASK, I2CCMDArry[3]&I2C_WR_MASK, I2CCMDArry[4], I2CCMDAr
 1257              		.loc 1 354 0
 1258 0988 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1259 098c 55E0D4E5 		ldrb	lr, [r4, #85]	@ zero_extendqisi2
 1260 0990 0520A0E1 		mov	r2, r5
 1261 0994 FE0000E2 		and	r0, r0, #254
 1262 0998 00E08DE5 		str	lr, [sp, #0]
 1263 099c FEFFFFEB 		bl	SensorWrite2B
 1264 09a0 F0FFFFEA 		b	.L90
 1265              	.LVL100:
 1266              	.L98:
 338:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1267              		.loc 1 338 0
 1268 09a4 4E00D4E5 		ldrb	r0, [r4, #78]	@ zero_extendqisi2
 1269 09a8 4F10D4E5 		ldrb	r1, [r4, #79]	@ zero_extendqisi2
 324:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1270              		.loc 1 324 0
 1271 09ac 0FE0A0E3 		mov	lr, #15
 338:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1272              		.loc 1 338 0
 1273 09b0 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1274 09b4 5020D4E5 		ldrb	r2, [r4, #80]	@ zero_extendqisi2
 324:../uvc.c      **** 		I2CCMDArry[11] = 0xf; //setting I2C data is not available.
 1275              		.loc 1 324 0
 1276 09b8 57E0C4E5 		strb	lr, [r4, #87]
 338:../uvc.c      **** 			SensorRead2B(I2CCMDArry[2]|I2C_RD_MASK, I2CCMDArry[3]|I2C_RD_MASK, I2CCMDArry[4], I2CCMDArry[5],
 1277              		.loc 1 338 0
 1278 09bc 34C08DE2 		add	ip, sp, #52
 1279 09c0 010080E3 		orr	r0, r0, #1
 1280 09c4 011081E3 		orr	r1, r1, #1
 1281 09c8 00C08DE5 		str	ip, [sp, #0]
 1282 09cc FEFFFFEB 		bl	SensorRead2B
 339:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1283              		.loc 1 339 0
 1284 09d0 3400DDE5 		ldrb	r0, [sp, #52]	@ zero_extendqisi2
 340:../uvc.c      **** 			if(CmdDataLen == 2){
 1285              		.loc 1 340 0
 1286 09d4 020056E3 		cmp	r6, #2
 339:../uvc.c      **** 			I2CCMDArry[9] = buf[0];
 1287              		.loc 1 339 0
 1288 09d8 5500C4E5 		strb	r0, [r4, #85]
 341:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1289              		.loc 1 341 0
 1290 09dc 3500DD05 		ldreqb	r0, [sp, #53]	@ zero_extendqisi2
 343:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1291              		.loc 1 343 0
 1292 09e0 0030E0E3 		mvn	r3, #0
 341:../uvc.c      **** 				I2CCMDArry[10] = buf[1];
 1293              		.loc 1 341 0
 1294 09e4 5600C405 		streqb	r0, [r4, #86]
 343:../uvc.c      **** 			I2CCMDArry[11] = 0xff; //setting I2C data is available.
 1295              		.loc 1 343 0
 1296 09e8 5730C4E5 		strb	r3, [r4, #87]
 1297 09ec DDFFFFEA 		b	.L90
 1298              	.LVL101:
 1299              	.L100:
 349:../uvc.c      **** 			if((I2CCMDArry[3]&I2C_WR_MASK)==0x82 && (I2CCMDArry[4]==0x30) && (I2CCMDArry[5]==0x10)){
 1300              		.loc 1 349 0 discriminator 1
 1301 09f0 5050D4E5 		ldrb	r5, [r4, #80]	@ zero_extendqisi2
 1302 09f4 300055E3 		cmp	r5, #48
 1303 09f8 E1FFFF1A 		bne	.L97
 1304 09fc 5130D4E5 		ldrb	r3, [r4, #81]	@ zero_extendqisi2
 1305 0a00 100053E3 		cmp	r3, #16
 1306 0a04 DFFFFF1A 		bne	.L96
 350:../uvc.c      **** 				CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);
 1307              		.loc 1 350 0
 1308 0a08 44409FE5 		ldr	r4, .L101+8
 1309 0a0c 0010E0E3 		mvn	r1, #0
 1310 0a10 1C0094E5 		ldr	r0, [r4, #28]
 1311 0a14 2C308DE5 		str	r3, [sp, #44]
 1312 0a18 FEFFFFEB 		bl	_txe_mutex_get
 351:../uvc.c      **** 				cmdSet(cmdQuptr, 23, 0x10, 0x30, STOP, 0);
 1313              		.loc 1 351 0
 1314 0a1c 2C309DE5 		ldr	r3, [sp, #44]
 1315 0a20 00C0A0E3 		mov	ip, #0
 1316 0a24 0320A0E1 		mov	r2, r3
 1317 0a28 0400A0E1 		mov	r0, r4
 1318 0a2c 1710A0E3 		mov	r1, #23
 1319 0a30 0530A0E1 		mov	r3, r5
 1320 0a34 00C08DE5 		str	ip, [sp, #0]
 1321 0a38 04C08DE5 		str	ip, [sp, #4]
 1322 0a3c FEFFFFEB 		bl	cmdSet
 352:../uvc.c      **** 				CyU3PMutexPut(cmdQuptr->ringMux);
 1323              		.loc 1 352 0
 1324 0a40 1C0094E5 		ldr	r0, [r4, #28]
 1325 0a44 FEFFFFEB 		bl	_txe_mutex_put
 1326 0a48 C6FFFFEA 		b	.L90
 1327              	.L102:
 1328              		.align	2
 1329              	.L101:
 1330 0a4c 00000000 		.word	.LANCHOR0
 1331 0a50 FC010000 		.word	.LC14
 1332 0a54 00000000 		.word	cmdQu
 1333              		.cfi_endproc
 1334              	.LFE0:
 1336              		.align	2
 1337              		.global	setIrisauto
 1339              	setIrisauto:
 1340              	.LFB1:
 366:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1341              		.loc 1 366 0
 1342              		.cfi_startproc
 1343              		@ args = 0, pretend = 0, frame = 0
 1344              		@ frame_needed = 0, uses_anonymous_args = 0
 1345              	.LVL102:
 1346 0a58 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1347              	.LCFI11:
 1348              		.cfi_def_cfa_offset 16
 1349 0a5c 0160A0E1 		mov	r6, r1
 1350              		.cfi_offset 14, -4
 1351              		.cfi_offset 6, -8
 1352              		.cfi_offset 5, -12
 1353              		.cfi_offset 4, -16
 1354 0a60 08D04DE2 		sub	sp, sp, #8
 1355              	.LCFI12:
 1356              		.cfi_def_cfa_offset 24
 370:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1357              		.loc 1 370 0
 1358 0a64 0050A0E3 		mov	r5, #0
 366:../uvc.c      **** inline void setIrisauto(VdRingBuf *cmdQuptr, uint8_t isAuto){
 1359              		.loc 1 366 0
 1360 0a68 0040A0E1 		mov	r4, r0
 369:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 1361              		.loc 1 369 0
 1362 0a6c 0010E0E3 		mvn	r1, #0
 1363              	.LVL103:
 1364 0a70 1C0090E5 		ldr	r0, [r0, #28]
 1365              	.LVL104:
 1366 0a74 FEFFFFEB 		bl	_txe_mutex_get
 370:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 1367              		.loc 1 370 0
 1368 0a78 060065E0 		rsb	r0, r5, r6
 1369 0a7c 00C070E2 		rsbs	ip, r0, #0
 1370 0a80 00C0ACE0 		adc	ip, ip, r0
 1371 0a84 1410A0E3 		mov	r1, #20
 1372 0a88 2720A0E3 		mov	r2, #39
 1373 0a8c 3030A0E3 		mov	r3, #48
 1374 0a90 0400A0E1 		mov	r0, r4
 1375 0a94 00C08DE5 		str	ip, [sp, #0]
 1376 0a98 04508DE5 		str	r5, [sp, #4]
 1377 0a9c FEFFFFEB 		bl	cmdSet
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 1378              		.loc 1 371 0
 1379 0aa0 050056E1 		cmp	r6, r5
 1380 0aa4 0260A003 		moveq	r6, #2
 1381 0aa8 0560A011 		movne	r6, r5
 1382 0aac 0400A0E1 		mov	r0, r4
 1383 0ab0 1510A0E3 		mov	r1, #21
 1384 0ab4 2520A0E3 		mov	r2, #37
 1385 0ab8 3030A0E3 		mov	r3, #48
 1386 0abc 00608DE5 		str	r6, [sp, #0]
 1387 0ac0 04508DE5 		str	r5, [sp, #4]
 1388 0ac4 FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1389              		.loc 1 372 0
 1390 0ac8 1C0094E5 		ldr	r0, [r4, #28]
 373:../uvc.c      **** }
 1391              		.loc 1 373 0
 1392 0acc 08D08DE2 		add	sp, sp, #8
 1393 0ad0 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 372:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 1394              		.loc 1 372 0
 1395 0ad4 FEFFFFEA 		b	_txe_mutex_put
 1396              		.cfi_endproc
 1397              	.LFE1:
 1399              		.align	2
 1400              		.global	ControlHandle
 1402              	ControlHandle:
 1403              	.LFB2:
 375:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1404              		.loc 1 375 0
 1405              		.cfi_startproc
 1406              		@ args = 0, pretend = 0, frame = 24
 1407              		@ frame_needed = 0, uses_anonymous_args = 0
 1408              	.LVL105:
 1409 0ad8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1410              	.LCFI13:
 1411              		.cfi_def_cfa_offset 36
 382:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1412              		.loc 1 382 0
 1413 0adc 1F0050E3 		cmp	r0, #31
 381:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1414              		.loc 1 381 0
 1415 0ae0 207040E2 		sub	r7, r0, #32
 1416              		.cfi_offset 14, -4
 1417              		.cfi_offset 11, -8
 1418              		.cfi_offset 10, -12
 1419              		.cfi_offset 9, -16
 1420              		.cfi_offset 8, -20
 1421              		.cfi_offset 7, -24
 1422              		.cfi_offset 6, -28
 1423              		.cfi_offset 5, -32
 1424              		.cfi_offset 4, -36
 375:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1425              		.loc 1 375 0
 1426 0ae4 2CD04DE2 		sub	sp, sp, #44
 1427              	.LCFI14:
 1428              		.cfi_def_cfa_offset 80
 375:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1429              		.loc 1 375 0
 1430 0ae8 0040A0E1 		mov	r4, r0
 381:../uvc.c      ****     locCtrlID = CtrlID-EXUAOFFSET;
 1431              		.loc 1 381 0
 1432 0aec FF7007E2 		and	r7, r7, #255
 1433              	.LVL106:
 382:../uvc.c      ****     if(CtrlID >= EXUAOFFSET){//the extension command over 32.
 1434              		.loc 1 382 0
 1435 0af0 2300009A 		bls	.L107
 383:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1436              		.loc 1 383 0
 1437 0af4 C06E9FE5 		ldr	r6, .L215
 1438 0af8 872087E0 		add	r2, r7, r7, asl #1
 1439 0afc 8221A0E1 		mov	r2, r2, asl #3
 1440 0b00 023086E0 		add	r3, r6, r2
 384:../uvc.c      ****         RegAdd1 = ExUCtrlParArry[locCtrlID][1];
 1441              		.loc 1 384 0
 1442 0b04 01B0D3E5 		ldrb	fp, [r3, #1]	@ zero_extendqisi2
 385:../uvc.c      ****         devAdd = ExUCtrlParArry[locCtrlID][15];
 1443              		.loc 1 385 0
 1444 0b08 0FA0D3E5 		ldrb	sl, [r3, #15]	@ zero_extendqisi2
 386:../uvc.c      ****         Len = ExUCtrlParArry[locCtrlID][2];
 1445              		.loc 1 386 0
 1446 0b0c 0280D3E5 		ldrb	r8, [r3, #2]	@ zero_extendqisi2
 397:../uvc.c      ****     reqData = bRequest;
 1447              		.loc 1 397 0
 1448 0b10 A83E9FE5 		ldr	r3, .L215+4
 383:../uvc.c      ****     	RegAdd0 = ExUCtrlParArry[locCtrlID][0];
 1449              		.loc 1 383 0
 1450 0b14 0290D6E7 		ldrb	r9, [r6, r2]	@ zero_extendqisi2
 1451              	.LVL107:
 397:../uvc.c      ****     reqData = bRequest;
 1452              		.loc 1 397 0
 1453 0b18 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 1454              	.LVL108:
 405:../uvc.c      ****     switch (bRequest)
 1455              		.loc 1 405 0
 1456 0b1c 830055E3 		cmp	r5, #131
 1457 0b20 2200000A 		beq	.L113
 1458              	.LVL109:
 1459              	.L210:
 1460 0b24 2B00009A 		bls	.L208
 1461 0b28 850055E3 		cmp	r5, #133
 1462 0b2c 8400000A 		beq	.L115
 1463 0b30 7200003A 		bcc	.L114
 1464 0b34 860055E3 		cmp	r5, #134
 1465 0b38 BD00000A 		beq	.L116
 1466 0b3c 870055E3 		cmp	r5, #135
 1467 0b40 B100000A 		beq	.L209
 1468              	.L109:
 863:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 1469              		.loc 1 863 0
 1470 0b44 0000A0E3 		mov	r0, #0
 1471 0b48 0110A0E3 		mov	r1, #1
 1472 0b4c 0020A0E1 		mov	r2, r0
 1473 0b50 FEFFFFEB 		bl	CyU3PUsbStall
 864:../uvc.c      **** 			  break;
 1474              		.loc 1 864 0
 1475 0b54 FFE0A0E3 		mov	lr, #255
 1476 0b58 0E40A0E1 		mov	r4, lr
 1477 0b5c 0EC0A0E1 		mov	ip, lr
 1478 0b60 0E30A0E1 		mov	r3, lr
 1479              	.LVL110:
 1480              	.L119:
 866:../uvc.c      **** EndofSet:    CyU3PDebugPrint (4, "The Request 0x%x parameter get from host 0x%x 0x%x / send to host
 1481              		.loc 1 866 0
 1482 0b64 581E9FE5 		ldr	r1, .L215+8
 1483 0b68 0520A0E1 		mov	r2, r5
 1484 0b6c 0400A0E3 		mov	r0, #4
 1485 0b70 00C08DE5 		str	ip, [sp, #0]
 1486 0b74 10408DE9 		stmib	sp, {r4, lr}	@ phole stm
 1487 0b78 FEFFFFEB 		bl	CyU3PDebugPrint
 867:../uvc.c      **** }
 1488              		.loc 1 867 0
 1489 0b7c 2CD08DE2 		add	sp, sp, #44
 1490 0b80 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1491              	.LVL111:
 1492              	.L107:
 388:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1493              		.loc 1 388 0
 1494 0b84 306E9FE5 		ldr	r6, .L215
 397:../uvc.c      ****     reqData = bRequest;
 1495              		.loc 1 397 0
 1496 0b88 303E9FE5 		ldr	r3, .L215+4
 388:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1497              		.loc 1 388 0
 1498 0b8c 805080E0 		add	r5, r0, r0, asl #1
 1499 0b90 850186E0 		add	r0, r6, r5, asl #3
 1500              	.LVL112:
 397:../uvc.c      ****     reqData = bRequest;
 1501              		.loc 1 397 0
 1502 0b94 0050D3E5 		ldrb	r5, [r3, #0]	@ zero_extendqisi2
 388:../uvc.c      **** 		RegAdd0 = CtrlParArry[CtrlID][0];
 1503              		.loc 1 388 0
 1504 0b98 8091D0E5 		ldrb	r9, [r0, #384]	@ zero_extendqisi2
 1505              	.LVL113:
 405:../uvc.c      ****     switch (bRequest)
 1506              		.loc 1 405 0
 1507 0b9c 830055E3 		cmp	r5, #131
 389:../uvc.c      **** 		RegAdd1 = CtrlParArry[CtrlID][1];
 1508              		.loc 1 389 0
 1509 0ba0 81B1D0E5 		ldrb	fp, [r0, #385]	@ zero_extendqisi2
 1510              	.LVL114:
 390:../uvc.c      **** 		devAdd = CtrlParArry[CtrlID][15];
 1511              		.loc 1 390 0
 1512 0ba4 8FA1D0E5 		ldrb	sl, [r0, #399]	@ zero_extendqisi2
 1513              	.LVL115:
 391:../uvc.c      **** 		Len = CtrlParArry[CtrlID][2];
 1514              		.loc 1 391 0
 1515 0ba8 8281D0E5 		ldrb	r8, [r0, #386]	@ zero_extendqisi2
 1516              	.LVL116:
 405:../uvc.c      ****     switch (bRequest)
 1517              		.loc 1 405 0
 1518 0bac DCFFFF1A 		bne	.L210
 1519              	.LVL117:
 1520              	.L113:
 528:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1521              		.loc 1 528 0
 1522 0bb0 1F0054E3 		cmp	r4, #31
 1523 0bb4 BC00009A 		bls	.L144
 529:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1524              		.loc 1 529 0
 1525 0bb8 877087E0 		add	r7, r7, r7, asl #1
 1526              	.LVL118:
 1527 0bbc 876186E0 		add	r6, r6, r7, asl #3
 1528 0bc0 00AE9FE5 		ldr	sl, .L215+12
 1529 0bc4 0500D6E5 		ldrb	r0, [r6, #5]	@ zero_extendqisi2
 530:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1530              		.loc 1 530 0
 1531 0bc8 06C0D6E5 		ldrb	ip, [r6, #6]	@ zero_extendqisi2
 529:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][5];//ext_control array;
 1532              		.loc 1 529 0
 1533 0bcc 5800CAE5 		strb	r0, [sl, #88]
 530:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][6];
 1534              		.loc 1 530 0
 1535 0bd0 59C0CAE5 		strb	ip, [sl, #89]
 1536 0bd4 0B0000EA 		b	.L152
 1537              	.LVL119:
 1538              	.L208:
 405:../uvc.c      ****     switch (bRequest)
 1539              		.loc 1 405 0
 1540 0bd8 810055E3 		cmp	r5, #129
 1541 0bdc 6400000A 		beq	.L111
 1542 0be0 1000009A 		bls	.L211
 509:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1543              		.loc 1 509 0
 1544 0be4 1F0054E3 		cmp	r4, #31
 1545 0be8 A300009A 		bls	.L141
 510:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1546              		.loc 1 510 0
 1547 0bec 877087E0 		add	r7, r7, r7, asl #1
 1548              	.LVL120:
 1549 0bf0 876186E0 		add	r6, r6, r7, asl #3
 1550 0bf4 CCAD9FE5 		ldr	sl, .L215+12
 1551 0bf8 0340D6E5 		ldrb	r4, [r6, #3]	@ zero_extendqisi2
 511:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1552              		.loc 1 511 0
 1553 0bfc 04E0D6E5 		ldrb	lr, [r6, #4]	@ zero_extendqisi2
 510:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][3];//ext_control array;
 1554              		.loc 1 510 0
 1555 0c00 5840CAE5 		strb	r4, [sl, #88]
 511:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][4];
 1556              		.loc 1 511 0
 1557 0c04 59E0CAE5 		strb	lr, [sl, #89]
 1558              	.L152:
 587:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1559              		.loc 1 587 0
 1560 0c08 0800A0E1 		mov	r0, r8
 1561 0c0c B81D9FE5 		ldr	r1, .L215+16
 1562 0c10 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1563              	.LVL121:
 589:../uvc.c      **** 			  break;
 1564              		.loc 1 589 0
 1565 0c14 FFE0A0E3 		mov	lr, #255
 587:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1566              		.loc 1 587 0
 1567 0c18 5840DAE5 		ldrb	r4, [sl, #88]	@ zero_extendqisi2
 589:../uvc.c      **** 			  break;
 1568              		.loc 1 589 0
 1569 0c1c 0EC0A0E1 		mov	ip, lr
 1570 0c20 0E30A0E1 		mov	r3, lr
 1571 0c24 CEFFFFEA 		b	.L119
 1572              	.LVL122:
 1573              	.L211:
 405:../uvc.c      ****     switch (bRequest)
 1574              		.loc 1 405 0
 1575 0c28 010055E3 		cmp	r5, #1
 1576 0c2c C4FFFF1A 		bne	.L109
 591:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 1577              		.loc 1 591 0
 1578 0c30 901D9FE5 		ldr	r1, .L215+12
 1579 0c34 26208DE2 		add	r2, sp, #38
 1580 0c38 2000A0E3 		mov	r0, #32
 1581 0c3c 581081E2 		add	r1, r1, #88
 1582 0c40 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 1583              	.LVL123:
 593:../uvc.c      **** 			  if (apiRetStatus == CY_U3P_SUCCESS )
 1584              		.loc 1 593 0
 1585 0c44 002050E2 		subs	r2, r0, #0
 1586 0c48 2003001A 		bne	.L154
 595:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1587              		.loc 1 595 0
 1588 0c4c 74ED9FE5 		ldr	lr, .L215+12
 1589 0c50 5830DEE5 		ldrb	r3, [lr, #88]	@ zero_extendqisi2
 596:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1590              		.loc 1 596 0
 1591 0c54 6CED9FE5 		ldr	lr, .L215+12
 595:../uvc.c      **** 				  Data0 = glEp0Buffer[0];
 1592              		.loc 1 595 0
 1593 0c58 18308DE5 		str	r3, [sp, #24]
 1594              	.LVL124:
 598:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1595              		.loc 1 598 0
 1596 0c5c 5A00DEE5 		ldrb	r0, [lr, #90]	@ zero_extendqisi2
 1597              	.LVL125:
 596:../uvc.c      **** 				  Data1 = glEp0Buffer[1];
 1598              		.loc 1 596 0
 1599 0c60 59C0DEE5 		ldrb	ip, [lr, #89]	@ zero_extendqisi2
 1600              	.LVL126:
 598:../uvc.c      **** 				  getData1 = glEp0Buffer[2];
 1601              		.loc 1 598 0
 1602 0c64 1C008DE5 		str	r0, [sp, #28]
 1603              	.LVL127:
 602:../uvc.c      **** 				  switch(CtrlID)
 1604              		.loc 1 602 0
 1605 0c68 220054E3 		cmp	r4, #34
 1606 0c6c 04F19F97 		ldrls	pc, [pc, r4, asl #2]
 1607 0c70 FD0200EA 		b	.L155
 1608              	.L170:
 1609 0c74 1C180000 		.word	.L156
 1610 0c78 60170000 		.word	.L157
 1611 0c7c 6C180000 		.word	.L155
 1612 0c80 6C180000 		.word	.L155
 1613 0c84 FC160000 		.word	.L158
 1614 0c88 B8150000 		.word	.L159
 1615 0c8c 38150000 		.word	.L160
 1616 0c90 6C180000 		.word	.L155
 1617 0c94 6C180000 		.word	.L155
 1618 0c98 6C180000 		.word	.L155
 1619 0c9c 6C180000 		.word	.L155
 1620 0ca0 B4140000 		.word	.L161
 1621 0ca4 6C180000 		.word	.L155
 1622 0ca8 6C180000 		.word	.L155
 1623 0cac 6C180000 		.word	.L155
 1624 0cb0 6C180000 		.word	.L155
 1625 0cb4 BC130000 		.word	.L162
 1626 0cb8 6C180000 		.word	.L155
 1627 0cbc 6C180000 		.word	.L155
 1628 0cc0 6C180000 		.word	.L155
 1629 0cc4 6C180000 		.word	.L155
 1630 0cc8 6C180000 		.word	.L155
 1631 0ccc 6C180000 		.word	.L155
 1632 0cd0 6C180000 		.word	.L155
 1633 0cd4 6C180000 		.word	.L155
 1634 0cd8 00130000 		.word	.L163
 1635 0cdc 6C180000 		.word	.L155
 1636 0ce0 6C180000 		.word	.L155
 1637 0ce4 44140000 		.word	.L164
 1638 0ce8 6C180000 		.word	.L155
 1639 0cec A4120000 		.word	.L165
 1640 0cf0 20120000 		.word	.L166
 1641 0cf4 88110000 		.word	.L167
 1642 0cf8 70110000 		.word	.L168
 1643 0cfc 0C110000 		.word	.L169
 1644              	.LVL128:
 1645              	.L114:
 546:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1646              		.loc 1 546 0
 1647 0d00 1F0054E3 		cmp	r4, #31
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1648              		.loc 1 547 0
 1649 0d04 87708780 		addhi	r7, r7, r7, asl #1
 1650              	.LVL129:
 553:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1651              		.loc 1 553 0
 1652 0d08 84408490 		addls	r4, r4, r4, asl #1
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1653              		.loc 1 547 0
 1654 0d0c 87618680 		addhi	r6, r6, r7, asl #3
 553:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1655              		.loc 1 553 0
 1656 0d10 84618690 		addls	r6, r6, r4, asl #3
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1657              		.loc 1 547 0
 1658 0d14 ACAC9F85 		ldrhi	sl, .L215+12
 553:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1659              		.loc 1 553 0
 1660 0d18 A8AC9F95 		ldrls	sl, .L215+12
 547:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][7];//ext_control array;
 1661              		.loc 1 547 0
 1662 0d1c 0710D685 		ldrhib	r1, [r6, #7]	@ zero_extendqisi2
 548:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][8];
 1663              		.loc 1 548 0
 1664 0d20 0820D685 		ldrhib	r2, [r6, #8]	@ zero_extendqisi2
 553:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1665              		.loc 1 553 0
 1666 0d24 8711D695 		ldrlsb	r1, [r6, #391]	@ zero_extendqisi2
 554:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1667              		.loc 1 554 0
 1668 0d28 8821D695 		ldrlsb	r2, [r6, #392]	@ zero_extendqisi2
 555:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1669              		.loc 1 555 0
 1670 0d2c 0030A0E3 		mov	r3, #0
 553:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][7];
 1671              		.loc 1 553 0
 1672 0d30 5810CAE5 		strb	r1, [sl, #88]
 554:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][8];
 1673              		.loc 1 554 0
 1674 0d34 5920CAE5 		strb	r2, [sl, #89]
 555:../uvc.c      **** 			  glEp0Buffer[2] = 0;
 1675              		.loc 1 555 0
 1676 0d38 5A30CAE5 		strb	r3, [sl, #90]
 556:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 1677              		.loc 1 556 0
 1678 0d3c 5B30CAE5 		strb	r3, [sl, #91]
 1679 0d40 B0FFFFEA 		b	.L152
 1680              	.LVL130:
 1681              	.L115:
 409:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1682              		.loc 1 409 0
 1683 0d44 7C4C9FE5 		ldr	r4, .L215+12
 410:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 1684              		.loc 1 410 0
 1685 0d48 00C0A0E3 		mov	ip, #0
 1686 0d4c 59C0C4E5 		strb	ip, [r4, #89]
 411:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1687              		.loc 1 411 0
 1688 0d50 581084E2 		add	r1, r4, #88
 409:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 1689              		.loc 1 409 0
 1690 0d54 5880C4E5 		strb	r8, [r4, #88]
 411:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1691              		.loc 1 411 0
 1692 0d58 0200A0E3 		mov	r0, #2
 1693 0d5c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1694              	.LVL131:
 413:../uvc.c      **** 			  break;
 1695              		.loc 1 413 0
 1696 0d60 FFE0A0E3 		mov	lr, #255
 411:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 1697              		.loc 1 411 0
 1698 0d64 5840D4E5 		ldrb	r4, [r4, #88]	@ zero_extendqisi2
 413:../uvc.c      **** 			  break;
 1699              		.loc 1 413 0
 1700 0d68 0EC0A0E1 		mov	ip, lr
 1701 0d6c 0E30A0E1 		mov	r3, lr
 1702 0d70 7BFFFFEA 		b	.L119
 1703              	.LVL132:
 1704              	.L111:
 416:../uvc.c      **** 			 switch(CtrlID)
 1705              		.loc 1 416 0
 1706 0d74 011044E2 		sub	r1, r4, #1
 1707 0d78 210051E3 		cmp	r1, #33
 1708 0d7c 01F19F97 		ldrls	pc, [pc, r1, asl #2]
 1709 0d80 D80000EA 		b	.L120
 1710              	.L128:
 1711 0d84 A4100000 		.word	.L121
 1712 0d88 E8100000 		.word	.L120
 1713 0d8c E8100000 		.word	.L120
 1714 0d90 E8100000 		.word	.L120
 1715 0d94 84100000 		.word	.L122
 1716 0d98 E8100000 		.word	.L120
 1717 0d9c E8100000 		.word	.L120
 1718 0da0 E8100000 		.word	.L120
 1719 0da4 E8100000 		.word	.L120
 1720 0da8 E8100000 		.word	.L120
 1721 0dac 60100000 		.word	.L123
 1722 0db0 E8100000 		.word	.L120
 1723 0db4 E8100000 		.word	.L120
 1724 0db8 E8100000 		.word	.L120
 1725 0dbc E8100000 		.word	.L120
 1726 0dc0 E8100000 		.word	.L120
 1727 0dc4 E8100000 		.word	.L120
 1728 0dc8 E8100000 		.word	.L120
 1729 0dcc E8100000 		.word	.L120
 1730 0dd0 E8100000 		.word	.L120
 1731 0dd4 E8100000 		.word	.L120
 1732 0dd8 E8100000 		.word	.L120
 1733 0ddc E8100000 		.word	.L120
 1734 0de0 E8100000 		.word	.L120
 1735 0de4 24100000 		.word	.L124
 1736 0de8 E8100000 		.word	.L120
 1737 0dec E8100000 		.word	.L120
 1738 0df0 FC0F0000 		.word	.L125
 1739 0df4 E8100000 		.word	.L120
 1740 0df8 E8100000 		.word	.L120
 1741 0dfc 600F0000 		.word	.L126
 1742 0e00 280F0000 		.word	.L127
 1743 0e04 280F0000 		.word	.L127
 1744 0e08 280F0000 		.word	.L127
 1745              	.L209:
 573:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1746              		.loc 1 573 0
 1747 0e0c 1F0054E3 		cmp	r4, #31
 1748 0e10 3100009A 		bls	.L151
 574:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1749              		.loc 1 574 0
 1750 0e14 877087E0 		add	r7, r7, r7, asl #1
 1751              	.LVL133:
 1752 0e18 876186E0 		add	r6, r6, r7, asl #3
 1753 0e1c A4AB9FE5 		ldr	sl, .L215+12
 1754 0e20 0B20D6E5 		ldrb	r2, [r6, #11]	@ zero_extendqisi2
 575:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1755              		.loc 1 575 0
 1756 0e24 0C10D6E5 		ldrb	r1, [r6, #12]	@ zero_extendqisi2
 574:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][11];//ext_control array;
 1757              		.loc 1 574 0
 1758 0e28 5820CAE5 		strb	r2, [sl, #88]
 575:../uvc.c      **** 				 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][12];
 1759              		.loc 1 575 0
 1760 0e2c 5910CAE5 		strb	r1, [sl, #89]
 1761 0e30 74FFFFEA 		b	.L152
 1762              	.LVL134:
 1763              	.L116:
 562:../uvc.c      **** 		 	 if(CtrlID >= EXUAOFFSET){
 1764              		.loc 1 562 0
 1765 0e34 1F0054E3 		cmp	r4, #31
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1766              		.loc 1 566 0
 1767 0e38 84408490 		addls	r4, r4, r4, asl #1
 563:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1768              		.loc 1 563 0
 1769 0e3c 87708780 		addhi	r7, r7, r7, asl #1
 1770              	.LVL135:
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1771              		.loc 1 566 0
 1772 0e40 84618690 		addls	r6, r6, r4, asl #3
 563:../uvc.c      **** 				 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][9];//ext_control array;
 1773              		.loc 1 563 0
 1774 0e44 87618680 		addhi	r6, r6, r7, asl #3
 1775 0e48 788B9F85 		ldrhi	r8, .L215+12
 1776 0e4c 0930D685 		ldrhib	r3, [r6, #9]	@ zero_extendqisi2
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1777              		.loc 1 566 0
 1778 0e50 708B9F95 		ldrls	r8, .L215+12
 1779 0e54 8931D695 		ldrlsb	r3, [r6, #393]	@ zero_extendqisi2
 568:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1780              		.loc 1 568 0
 1781 0e58 0100A0E3 		mov	r0, #1
 566:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][9];
 1782              		.loc 1 566 0
 1783 0e5c 5830C8E5 		strb	r3, [r8, #88]
 568:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1784              		.loc 1 568 0
 1785 0e60 641B9FE5 		ldr	r1, .L215+16
 1786 0e64 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 1787              	.LVL136:
 571:../uvc.c      **** 			  break;
 1788              		.loc 1 571 0
 1789 0e68 FFE0A0E3 		mov	lr, #255
 568:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 1790              		.loc 1 568 0
 1791 0e6c 5840D8E5 		ldrb	r4, [r8, #88]	@ zero_extendqisi2
 571:../uvc.c      **** 			  break;
 1792              		.loc 1 571 0
 1793 0e70 0EC0A0E1 		mov	ip, lr
 1794 0e74 0E30A0E1 		mov	r3, lr
 1795 0e78 39FFFFEA 		b	.L119
 1796              	.LVL137:
 1797              	.L141:
 514:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1798              		.loc 1 514 0
 1799 0e7c 0B0054E3 		cmp	r4, #11
 521:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1800              		.loc 1 521 0
 1801 0e80 84408410 		addne	r4, r4, r4, asl #1
 1802 0e84 84618610 		addne	r6, r6, r4, asl #3
 1803 0e88 38AB9F15 		ldrne	sl, .L215+12
 515:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1804              		.loc 1 515 0
 1805 0e8c 34AB9F05 		ldreq	sl, .L215+12
 1806 0e90 383B9F05 		ldreq	r3, .L215+20
 521:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1807              		.loc 1 521 0
 1808 0e94 8321D615 		ldrneb	r2, [r6, #387]	@ zero_extendqisi2
 522:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1809              		.loc 1 522 0
 1810 0e98 8431D615 		ldrneb	r3, [r6, #388]	@ zero_extendqisi2
 515:../uvc.c      **** 				 glEp0Buffer[0] = 1;//WBMenuCmpArry[0];//using for blue part
 1811              		.loc 1 515 0
 1812 0e9c 58308A05 		streq	r3, [sl, #88]
 521:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][3];
 1813              		.loc 1 521 0
 1814 0ea0 5820CA15 		strneb	r2, [sl, #88]
 522:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][4];
 1815              		.loc 1 522 0
 1816 0ea4 5930CA15 		strneb	r3, [sl, #89]
 1817 0ea8 56FFFFEA 		b	.L152
 1818              	.L144:
 532:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1819              		.loc 1 532 0
 1820 0eac 0B0054E3 		cmp	r4, #11
 539:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1821              		.loc 1 539 0
 1822 0eb0 84408410 		addne	r4, r4, r4, asl #1
 1823 0eb4 84618610 		addne	r6, r6, r4, asl #3
 1824 0eb8 08AB9F15 		ldrne	sl, .L215+12
 533:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1825              		.loc 1 533 0
 1826 0ebc 04AB9F05 		ldreq	sl, .L215+12
 1827 0ec0 0C3B9F05 		ldreq	r3, .L215+24
 539:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1828              		.loc 1 539 0
 1829 0ec4 8521D615 		ldrneb	r2, [r6, #389]	@ zero_extendqisi2
 540:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1830              		.loc 1 540 0
 1831 0ec8 8631D615 		ldrneb	r3, [r6, #390]	@ zero_extendqisi2
 533:../uvc.c      **** 				 glEp0Buffer[0] = 0xff;//WBMenuCmpArry[0];//using for blue part
 1832              		.loc 1 533 0
 1833 0ecc 58308A05 		streq	r3, [sl, #88]
 539:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][5];
 1834              		.loc 1 539 0
 1835 0ed0 5820CA15 		strneb	r2, [sl, #88]
 540:../uvc.c      **** 				  glEp0Buffer[1] = CtrlParArry[CtrlID][6];
 1836              		.loc 1 540 0
 1837 0ed4 5930CA15 		strneb	r3, [sl, #89]
 1838 0ed8 4AFFFFEA 		b	.L152
 1839              	.L151:
 578:../uvc.c      **** 		 	 else if(CtrlID == WBTLevCtlID11){
 1840              		.loc 1 578 0
 1841 0edc 0B0054E3 		cmp	r4, #11
 1842 0ee0 0700000A 		beq	.L212
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1843              		.loc 1 584 0
 1844 0ee4 84A084E0 		add	sl, r4, r4, asl #1
 1845 0ee8 8A6186E0 		add	r6, r6, sl, asl #3
 1846 0eec 8B31D6E5 		ldrb	r3, [r6, #395]	@ zero_extendqisi2
 1847 0ef0 D0AA9FE5 		ldr	sl, .L215+12
 585:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1848              		.loc 1 585 0
 1849 0ef4 8C01D6E5 		ldrb	r0, [r6, #396]	@ zero_extendqisi2
 584:../uvc.c      **** 			  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1850              		.loc 1 584 0
 1851 0ef8 5830CAE5 		strb	r3, [sl, #88]
 585:../uvc.c      **** 			  glEp0Buffer[1] = CtrlParArry[CtrlID][12];
 1852              		.loc 1 585 0
 1853 0efc 5900CAE5 		strb	r0, [sl, #89]
 1854 0f00 40FFFFEA 		b	.L152
 1855              	.L212:
 579:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1856              		.loc 1 579 0
 1857 0f04 BCAA9FE5 		ldr	sl, .L215+12
 1858 0f08 93C2D6E5 		ldrb	ip, [r6, #659]	@ zero_extendqisi2
 581:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1859              		.loc 1 581 0
 1860 0f0c 9442D6E5 		ldrb	r4, [r6, #660]	@ zero_extendqisi2
 580:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1861              		.loc 1 580 0
 1862 0f10 00E0A0E3 		mov	lr, #0
 579:../uvc.c      **** 				  glEp0Buffer[0] = CtrlParArry[CtrlID][11];
 1863              		.loc 1 579 0
 1864 0f14 58C0CAE5 		strb	ip, [sl, #88]
 580:../uvc.c      **** 				  glEp0Buffer[1] = 0;
 1865              		.loc 1 580 0
 1866 0f18 59E0CAE5 		strb	lr, [sl, #89]
 581:../uvc.c      **** 				  glEp0Buffer[2] = CtrlParArry[CtrlID][12];
 1867              		.loc 1 581 0
 1868 0f1c 5A40CAE5 		strb	r4, [sl, #90]
 582:../uvc.c      **** 				  glEp0Buffer[3] = 0;
 1869              		.loc 1 582 0
 1870 0f20 5BE0CAE5 		strb	lr, [sl, #91]
 1871 0f24 37FFFFEA 		b	.L152
 1872              	.L127:
 422:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1873              		.loc 1 422 0
 1874 0f28 877087E0 		add	r7, r7, r7, asl #1
 1875              	.LVL138:
 1876 0f2c 876186E0 		add	r6, r6, r7, asl #3
 1877 0f30 90EA9FE5 		ldr	lr, .L215+12
 1878 0f34 0D40D6E5 		ldrb	r4, [r6, #13]	@ zero_extendqisi2
 423:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1879              		.loc 1 423 0
 1880 0f38 0E60D6E5 		ldrb	r6, [r6, #14]	@ zero_extendqisi2
 422:../uvc.c      **** 						 glEp0Buffer[0] = ExUCtrlParArry[locCtrlID][13];//ext_control array;
 1881              		.loc 1 422 0
 1882 0f3c 5840CEE5 		strb	r4, [lr, #88]
 423:../uvc.c      **** 						 glEp0Buffer[1] = ExUCtrlParArry[locCtrlID][14];
 1883              		.loc 1 423 0
 1884 0f40 5960CEE5 		strb	r6, [lr, #89]
 1885              	.LVL139:
 1886              	.L131:
 502:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1887              		.loc 1 502 0
 1888 0f44 0800A0E1 		mov	r0, r8
 1889 0f48 7C1A9FE5 		ldr	r1, .L215+16
 1890 0f4c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 507:../uvc.c      **** 			  break;
 1891              		.loc 1 507 0
 1892 0f50 FFC0A0E3 		mov	ip, #255
 502:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 1893              		.loc 1 502 0
 1894 0f54 06E0A0E1 		mov	lr, r6
 507:../uvc.c      **** 			  break;
 1895              		.loc 1 507 0
 1896 0f58 0C30A0E1 		mov	r3, ip
 1897 0f5c 00FFFFEA 		b	.L119
 1898              	.LVL140:
 1899              	.L126:
 443:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1900              		.loc 1 443 0 discriminator 1
 1901 0f60 000058E3 		cmp	r8, #0
 1902 0f64 8D02000A 		beq	.L204
 441:../uvc.c      **** 					 break;
 1903              		.loc 1 441 0
 1904 0f68 28E1A0E1 		mov	lr, r8, lsr #2
 1905 0f6c 00005EE3 		cmp	lr, #0
 1906 0f70 03005813 		cmpne	r8, #3
 1907 0f74 0020A083 		movhi	r2, #0
 1908 0f78 0120A093 		movls	r2, #1
 375:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 1909              		.loc 1 375 0
 1910 0f7c 0E31A0E1 		mov	r3, lr, asl #2
 441:../uvc.c      **** 					 break;
 1911              		.loc 1 441 0
 1912 0f80 8A02009A 		bls	.L191
 1913 0f84 401A9FE5 		ldr	r1, .L215+16
 1914 0f88 0C0041E2 		sub	r0, r1, #12
 1915              	.LVL141:
 1916              	.L136:
 444:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1917              		.loc 1 444 0 discriminator 2
 1918 0f8c 044090E4 		ldr	r4, [r0], #4
 1919 0f90 01C082E2 		add	ip, r2, #1
 1920 0f94 FF200CE2 		and	r2, ip, #255
 1921 0f98 02005EE1 		cmp	lr, r2
 1922 0f9c 044081E4 		str	r4, [r1], #4
 1923 0fa0 F9FFFF8A 		bhi	.L136
 444:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1924              		.loc 1 444 0 is_stmt 0
 1925 0fa4 030058E1 		cmp	r8, r3
 1926 0fa8 180A9F15 		ldrne	r0, .L215+12
 1927 0fac 7B02000A 		beq	.L204
 1928              	.L196:
 1929 0fb0 03E080E0 		add	lr, r0, r3
 1930 0fb4 4C10DEE5 		ldrb	r1, [lr, #76]	@ zero_extendqisi2
 443:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1931              		.loc 1 443 0 is_stmt 1
 1932 0fb8 016083E2 		add	r6, r3, #1
 1933 0fbc FF3006E2 		and	r3, r6, #255
 1934              	.LVL142:
 1935 0fc0 030058E1 		cmp	r8, r3
 444:../uvc.c      **** 			 			glEp0Buffer[idx] = I2CCMDArry[idx];
 1936              		.loc 1 444 0
 1937 0fc4 5810CEE5 		strb	r1, [lr, #88]
 443:../uvc.c      **** 			 		 for(idx=0; idx<Len; idx++){
 1938              		.loc 1 443 0
 1939 0fc8 F8FFFF8A 		bhi	.L196
 1940              	.LVL143:
 1941              	.L130:
 453:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1942              		.loc 1 453 0
 1943 0fcc 5720D0E5 		ldrb	r2, [r0, #87]	@ zero_extendqisi2
 446:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1944              		.loc 1 446 0
 1945 0fd0 F0399FE5 		ldr	r3, .L215+12
 453:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1946              		.loc 1 453 0
 1947 0fd4 FF0052E3 		cmp	r2, #255
 446:../uvc.c      **** 			 		 sendData = glEp0Buffer[9];
 1948              		.loc 1 446 0
 1949 0fd8 6140D0E5 		ldrb	r4, [r0, #97]	@ zero_extendqisi2
 1950              	.LVL144:
 447:../uvc.c      **** 			 		 sendData1 = glEp0Buffer[10];
 1951              		.loc 1 447 0
 1952 0fdc 6260D0E5 		ldrb	r6, [r0, #98]	@ zero_extendqisi2
 1953              	.LVL145:
 453:../uvc.c      **** 			 		 if(I2CCMDArry[11] != 0xff)//the data availabel.
 1954              		.loc 1 453 0
 1955 0fe0 D7FFFF0A 		beq	.L131
 455:../uvc.c      **** 			 			CyU3PDebugPrint (4, "The I2C current data is not available. try again. %d %d\r\n", I2CCMDArr
 1956              		.loc 1 455 0
 1957 0fe4 5520D3E5 		ldrb	r2, [r3, #85]	@ zero_extendqisi2
 1958 0fe8 E8199FE5 		ldr	r1, .L215+28
 1959 0fec 5630D3E5 		ldrb	r3, [r3, #86]	@ zero_extendqisi2
 1960 0ff0 0400A0E3 		mov	r0, #4
 1961 0ff4 FEFFFFEB 		bl	CyU3PDebugPrint
 1962 0ff8 D1FFFFEA 		b	.L131
 1963              	.LVL146:
 1964              	.L125:
 430:../uvc.c      **** 					 if(CamMode == 1){//720p
 1965              		.loc 1 430 0
 1966 0ffc C4799FE5 		ldr	r7, .L215+12
 1967              	.LVL147:
 429:../uvc.c      **** 					 sendData = CtrlParArry[CtrlID][13];
 1968              		.loc 1 429 0
 1969 1000 2D44D6E5 		ldrb	r4, [r6, #1069]	@ zero_extendqisi2
 1970              	.LVL148:
 430:../uvc.c      **** 					 if(CamMode == 1){//720p
 1971              		.loc 1 430 0
 1972 1004 7820D7E5 		ldrb	r2, [r7, #120]	@ zero_extendqisi2
 1973 1008 010052E3 		cmp	r2, #1
 1974 100c 3702000A 		beq	.L213
 1975              	.LVL149:
 1976              	.L132:
 440:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1977              		.loc 1 440 0
 1978 1010 0000A0E3 		mov	r0, #0
 439:../uvc.c      **** 					 glEp0Buffer[0] = sendData;
 1979              		.loc 1 439 0
 1980 1014 5840C7E5 		strb	r4, [r7, #88]
 440:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1981              		.loc 1 440 0
 1982 1018 5900C7E5 		strb	r0, [r7, #89]
 393:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 1983              		.loc 1 393 0
 1984 101c FF60A0E3 		mov	r6, #255
 441:../uvc.c      **** 					 break;
 1985              		.loc 1 441 0
 1986 1020 C7FFFFEA 		b	.L131
 1987              	.LVL150:
 1988              	.L124:
 459:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1989              		.loc 1 459 0
 1990 1024 E543D6E5 		ldrb	r4, [r6, #997]	@ zero_extendqisi2
 1991 1028 98C99FE5 		ldr	ip, .L215+12
 461:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 1992              		.loc 1 461 0
 1993 102c E663D6E5 		ldrb	r6, [r6, #998]	@ zero_extendqisi2
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1994              		.loc 1 460 0
 1995 1030 00E0A0E3 		mov	lr, #0
 459:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//exposure mode
 1996              		.loc 1 459 0
 1997 1034 5840CCE5 		strb	r4, [ip, #88]
 460:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 1998              		.loc 1 460 0
 1999 1038 59E0CCE5 		strb	lr, [ip, #89]
 461:../uvc.c      **** 					 glEp0Buffer[2] = CtrlParArry[CtrlID][14];//AGC
 2000              		.loc 1 461 0
 2001 103c 5A60CCE5 		strb	r6, [ip, #90]
 462:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2002              		.loc 1 462 0
 2003 1040 5BE0CCE5 		strb	lr, [ip, #91]
 2004              	.LVL151:
 465:../uvc.c      **** 					 CyU3PDebugPrint (4, "ExpM&AGC sent to host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buffer[1]
 2005              		.loc 1 465 0
 2006 1044 90199FE5 		ldr	r1, .L215+32
 2007 1048 0420A0E1 		mov	r2, r4
 2008 104c 0E30A0E1 		mov	r3, lr
 2009 1050 0400A0E3 		mov	r0, #4
 2010 1054 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 2011 1058 FEFFFFEB 		bl	CyU3PDebugPrint
 466:../uvc.c      **** 					 break;
 2012              		.loc 1 466 0
 2013 105c B8FFFFEA 		b	.L131
 2014              	.LVL152:
 2015              	.L123:
 487:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2016              		.loc 1 487 0
 2017 1060 60099FE5 		ldr	r0, .L215+12
 2018 1064 8C44D6E5 		ldrb	r4, [r6, #1164]	@ zero_extendqisi2
 489:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2019              		.loc 1 489 0
 2020 1068 8E64D6E5 		ldrb	r6, [r6, #1166]	@ zero_extendqisi2
 488:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2021              		.loc 1 488 0
 2022 106c 00C0A0E3 		mov	ip, #0
 487:../uvc.c      **** 					 glEp0Buffer[0] = WBMenuCmpArry[0];//using for blue part
 2023              		.loc 1 487 0
 2024 1070 5840C0E5 		strb	r4, [r0, #88]
 488:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2025              		.loc 1 488 0
 2026 1074 59C0C0E5 		strb	ip, [r0, #89]
 489:../uvc.c      **** 					 glEp0Buffer[2] = WBMenuCmpArry[2];//using for red part
 2027              		.loc 1 489 0
 2028 1078 5A60C0E5 		strb	r6, [r0, #90]
 490:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 2029              		.loc 1 490 0
 2030 107c 5BC0C0E5 		strb	ip, [r0, #91]
 2031              	.LVL153:
 493:../uvc.c      **** 					 break;
 2032              		.loc 1 493 0
 2033 1080 AFFFFFEA 		b	.L131
 2034              	.LVL154:
 2035              	.L122:
 482:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2036              		.loc 1 482 0
 2037 1084 0542D6E5 		ldrb	r4, [r6, #517]	@ zero_extendqisi2
 2038 1088 38E99FE5 		ldr	lr, .L215+12
 2039 108c 804024E2 		eor	r4, r4, #128
 483:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2040              		.loc 1 483 0
 2041 1090 0020A0E3 		mov	r2, #0
 482:../uvc.c      **** 					 glEp0Buffer[0] = glEp0Buffer[0] + GREEN_BASE;
 2042              		.loc 1 482 0
 2043 1094 5840CEE5 		strb	r4, [lr, #88]
 483:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2044              		.loc 1 483 0
 2045 1098 5920CEE5 		strb	r2, [lr, #89]
 2046              	.LVL155:
 393:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2047              		.loc 1 393 0
 2048 109c FF60A0E3 		mov	r6, #255
 485:../uvc.c      **** 					 break;
 2049              		.loc 1 485 0
 2050 10a0 A7FFFFEA 		b	.L131
 2051              	.LVL156:
 2052              	.L121:
 471:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2053              		.loc 1 471 0
 2054 10a4 A611D6E5 		ldrb	r1, [r6, #422]	@ zero_extendqisi2
 469:../uvc.c      **** 					 Data0 = CtrlParArry[CtrlID][13];  //SensorGetControl(RegAdd0, devAdd); //SensorGetBLCMode();
 2055              		.loc 1 469 0
 2056 10a8 A561D6E5 		ldrb	r6, [r6, #421]	@ zero_extendqisi2
 2057              	.LVL157:
 471:../uvc.c      **** 					 if (Data1&0x2){ //check the sign bit (bit1)
 2058              		.loc 1 471 0
 2059 10ac 020011E3 		tst	r1, #2
 474:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2060              		.loc 1 474 0
 2061 10b0 2661A001 		moveq	r6, r6, lsr #2
 2062              	.LVL158:
 2063 10b4 866CE001 		mvneq	r6, r6, asl #25
 2064 10b8 A66CE001 		mvneq	r6, r6, lsr #25
 476:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2065              		.loc 1 476 0
 2066 10bc 04399FE5 		ldr	r3, .L215+12
 472:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2067              		.loc 1 472 0
 2068 10c0 0113A011 		movne	r1, r1, asl #6
 2069 10c4 40400112 		andne	r4, r1, #64
 474:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2070              		.loc 1 474 0
 2071 10c8 01138601 		orreq	r1, r6, r1, asl #6
 472:../uvc.c      **** 						 Data1 = ((Data1<<6)&0x40)| (Data0 >> 2);//clear MSB
 2072              		.loc 1 472 0
 2073 10cc 26418411 		orrne	r4, r4, r6, lsr #2
 2074              	.LVL159:
 474:../uvc.c      **** 						 Data1 = ((Data1<<6)|0x80)| (Data0 >> 2);//set MSB
 2075              		.loc 1 474 0
 2076 10d0 FF400102 		andeq	r4, r1, #255
 2077              	.LVL160:
 477:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2078              		.loc 1 477 0
 2079 10d4 0000A0E3 		mov	r0, #0
 476:../uvc.c      **** 					 glEp0Buffer[0] = Data1;
 2080              		.loc 1 476 0
 2081 10d8 5840C3E5 		strb	r4, [r3, #88]
 477:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2082              		.loc 1 477 0
 2083 10dc 5900C3E5 		strb	r0, [r3, #89]
 2084              	.LVL161:
 393:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2085              		.loc 1 393 0
 2086 10e0 FF60A0E3 		mov	r6, #255
 479:../uvc.c      **** 					 break;
 2087              		.loc 1 479 0
 2088 10e4 96FFFFEA 		b	.L131
 2089              	.LVL162:
 2090              	.L120:
 496:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2091              		.loc 1 496 0
 2092 10e8 842084E0 		add	r2, r4, r4, asl #1
 2093 10ec 826186E0 		add	r6, r6, r2, asl #3
 2094 10f0 D0389FE5 		ldr	r3, .L215+12
 2095 10f4 8D41D6E5 		ldrb	r4, [r6, #397]	@ zero_extendqisi2
 497:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2096              		.loc 1 497 0
 2097 10f8 0010A0E3 		mov	r1, #0
 393:../uvc.c      ****     uint8_t dataIdx, getData=0xFF, getData1=0xff, sendData=0xff, sendData1=0xFF, reqData;
 2098              		.loc 1 393 0
 2099 10fc FF60A0E3 		mov	r6, #255
 496:../uvc.c      **** 					 glEp0Buffer[0] = CtrlParArry[CtrlID][13];//SensorGetControl(RegAdd0, devAdd);
 2100              		.loc 1 496 0
 2101 1100 5840C3E5 		strb	r4, [r3, #88]
 497:../uvc.c      **** 					 glEp0Buffer[1] = 0;
 2102              		.loc 1 497 0
 2103 1104 5910C3E5 		strb	r1, [r3, #89]
 2104              	.LVL163:
 499:../uvc.c      **** 					 break;
 2105              		.loc 1 499 0
 2106 1108 8DFFFFEA 		b	.L131
 2107              	.LVL164:
 2108              	.L169:
 733:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2109              		.loc 1 733 0
 2110 110c CC489FE5 		ldr	r4, .L215+36
 2111 1110 0010E0E3 		mvn	r1, #0
 2112 1114 1C0094E5 		ldr	r0, [r4, #28]
 2113 1118 FEFFFFEB 		bl	_txe_mutex_get
 2114              	.LVL165:
 734:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set grid status
 2115              		.loc 1 734 0
 2116 111c 2210A0E3 		mov	r1, #34
 2117              	.L207:
 2118 1120 18C09DE5 		ldr	ip, [sp, #24]
 2119 1124 00E0A0E3 		mov	lr, #0
 2120 1128 0A30A0E1 		mov	r3, sl
 2121 112c 0920A0E1 		mov	r2, r9
 2122 1130 0400A0E1 		mov	r0, r4
 2123 1134 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2124 1138 FEFFFFEB 		bl	cmdSet
 735:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2125              		.loc 1 735 0
 2126 113c 1C0094E5 		ldr	r0, [r4, #28]
 2127 1140 FEFFFFEB 		bl	_txe_mutex_put
 736:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2128              		.loc 1 736 0
 2129 1144 18109DE5 		ldr	r1, [sp, #24]
 2130 1148 877087E0 		add	r7, r7, r7, asl #1
 2131              	.LVL166:
 2132 114c 876186E0 		add	r6, r6, r7, asl #3
 737:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2133              		.loc 1 737 0
 2134 1150 0130A0E3 		mov	r3, #1
 738:../uvc.c      **** 							 break;
 2135              		.loc 1 738 0
 2136 1154 FFE0A0E3 		mov	lr, #255
 737:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2137              		.loc 1 737 0
 2138 1158 1030C6E5 		strb	r3, [r6, #16]
 736:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;
 2139              		.loc 1 736 0
 2140 115c 0D10C6E5 		strb	r1, [r6, #13]
 737:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2141              		.loc 1 737 0
 2142 1160 0130A0E1 		mov	r3, r1
 2143 1164 1CC09DE5 		ldr	ip, [sp, #28]
 738:../uvc.c      **** 							 break;
 2144              		.loc 1 738 0
 2145 1168 0E40A0E1 		mov	r4, lr
 2146 116c 7CFEFFEA 		b	.L119
 2147              	.LVL167:
 2148              	.L168:
 725:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2149              		.loc 1 725 0
 2150 1170 68489FE5 		ldr	r4, .L215+36
 2151 1174 0010E0E3 		mvn	r1, #0
 2152 1178 1C0094E5 		ldr	r0, [r4, #28]
 2153 117c FEFFFFEB 		bl	_txe_mutex_get
 2154              	.LVL168:
 726:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set weight factor
 2155              		.loc 1 726 0
 2156 1180 2110A0E3 		mov	r1, #33
 2157 1184 E5FFFFEA 		b	.L207
 2158              	.LVL169:
 2159              	.L167:
 711:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2160              		.loc 1 711 0
 2161 1188 50489FE5 		ldr	r4, .L215+36
 2162 118c 0010E0E3 		mvn	r1, #0
 2163 1190 1C0094E5 		ldr	r0, [r4, #28]
 2164 1194 14C08DE5 		str	ip, [sp, #20]
 2165 1198 FEFFFFEB 		bl	_txe_mutex_get
 2166              	.LVL170:
 710:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2167              		.loc 1 710 0
 2168 119c 18209DE5 		ldr	r2, [sp, #24]
 713:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2169              		.loc 1 713 0
 2170 11a0 00E0A0E3 		mov	lr, #0
 710:../uvc.c      **** 							 Data0 = Data0&0x7F; //mask window show flag bit.
 2171              		.loc 1 710 0
 2172 11a4 7F8002E2 		and	r8, r2, #127
 2173 11a8 1C808DE5 		str	r8, [sp, #28]
 2174              	.LVL171:
 713:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //set H/V-Pos
 2175              		.loc 1 713 0
 2176 11ac 1CC09DE5 		ldr	ip, [sp, #28]
 2177 11b0 2010A0E3 		mov	r1, #32
 2178 11b4 0920A0E1 		mov	r2, r9
 2179 11b8 0A30A0E1 		mov	r3, sl
 2180 11bc 0400A0E1 		mov	r0, r4
 2181 11c0 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2182 11c4 FEFFFFEB 		bl	cmdSet
 2183              	.LVL172:
 715:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //set H/V-size
 2184              		.loc 1 715 0
 2185 11c8 14C09DE5 		ldr	ip, [sp, #20]
 2186 11cc 0A30A0E1 		mov	r3, sl
 2187 11d0 0180A0E3 		mov	r8, #1
 2188 11d4 2010A0E3 		mov	r1, #32
 2189 11d8 0B20A0E1 		mov	r2, fp
 2190 11dc 0400A0E1 		mov	r0, r4
 2191 11e0 00C08DE5 		str	ip, [sp, #0]
 2192 11e4 04808DE5 		str	r8, [sp, #4]
 2193 11e8 FEFFFFEB 		bl	cmdSet
 716:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2194              		.loc 1 716 0
 2195 11ec 1C0094E5 		ldr	r0, [r4, #28]
 2196 11f0 FEFFFFEB 		bl	_txe_mutex_put
 2197              	.LVL173:
 719:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][13] = Data0;//ext_control array;
 2198              		.loc 1 719 0
 2199 11f4 1C009DE5 		ldr	r0, [sp, #28]
 2200 11f8 877087E0 		add	r7, r7, r7, asl #1
 2201              	.LVL174:
 2202 11fc 876186E0 		add	r6, r6, r7, asl #3
 2203 1200 0D00C6E5 		strb	r0, [r6, #13]
 720:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2204              		.loc 1 720 0
 2205 1204 14C09DE5 		ldr	ip, [sp, #20]
 722:../uvc.c      **** 							 break;
 2206              		.loc 1 722 0
 2207 1208 FFE0A0E3 		mov	lr, #255
 720:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][14] = Data1;
 2208              		.loc 1 720 0
 2209 120c 0EC0C6E5 		strb	ip, [r6, #14]
 721:../uvc.c      **** 							 ExUCtrlParArry[locCtrlID][16] = CyTrue;
 2210              		.loc 1 721 0
 2211 1210 1080C6E5 		strb	r8, [r6, #16]
 2212 1214 18309DE5 		ldr	r3, [sp, #24]
 722:../uvc.c      **** 							 break;
 2213              		.loc 1 722 0
 2214 1218 0E40A0E1 		mov	r4, lr
 2215 121c 50FEFFEA 		b	.L119
 2216              	.LVL175:
 2217              	.L166:
 682:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2218              		.loc 1 682 0 discriminator 1
 2219 1220 000058E3 		cmp	r8, #0
 2220 1224 1800000A 		beq	.L172
 680:../uvc.c      **** 							 break;
 2221              		.loc 1 680 0
 2222 1228 28E1A0E1 		mov	lr, r8, lsr #2
 2223 122c 00005EE3 		cmp	lr, #0
 2224 1230 03005813 		cmpne	r8, #3
 2225 1234 0020A083 		movhi	r2, #0
 2226 1238 0120A093 		movls	r2, #1
 2227              	.LVL176:
 375:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2228              		.loc 1 375 0
 2229 123c 0E31A0E1 		mov	r3, lr, asl #2
 680:../uvc.c      **** 							 break;
 2230              		.loc 1 680 0
 2231 1240 D801009A 		bls	.L192
 2232 1244 98179FE5 		ldr	r1, .L215+40
 2233 1248 0C0081E2 		add	r0, r1, #12
 2234              	.LVL177:
 2235              	.L183:
 683:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2236              		.loc 1 683 0 discriminator 2
 2237 124c 044090E4 		ldr	r4, [r0], #4
 2238 1250 012082E2 		add	r2, r2, #1
 2239 1254 FF2002E2 		and	r2, r2, #255
 2240 1258 02005EE1 		cmp	lr, r2
 2241 125c 044081E4 		str	r4, [r1], #4
 2242 1260 F9FFFF8A 		bhi	.L183
 683:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2243              		.loc 1 683 0 is_stmt 0
 2244 1264 030058E1 		cmp	r8, r3
 2245 1268 0700000A 		beq	.L172
 2246              	.LVL178:
 2247              	.L197:
 2248 126c 54C79FE5 		ldr	ip, .L215+12
 2249 1270 03E08CE0 		add	lr, ip, r3
 2250 1274 5810DEE5 		ldrb	r1, [lr, #88]	@ zero_extendqisi2
 682:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2251              		.loc 1 682 0 is_stmt 1
 2252 1278 013083E2 		add	r3, r3, #1
 2253 127c FF3003E2 		and	r3, r3, #255
 2254              	.LVL179:
 2255 1280 030058E1 		cmp	r8, r3
 683:../uvc.c      **** 					 			I2CCMDArry[idx] = glEp0Buffer[idx];
 2256              		.loc 1 683 0
 2257 1284 4C10CEE5 		strb	r1, [lr, #76]
 682:../uvc.c      **** 					 		 for(idx=0; idx<Len; idx++){
 2258              		.loc 1 682 0
 2259 1288 F7FFFF8A 		bhi	.L197
 2260              	.LVL180:
 2261              	.L172:
 685:../uvc.c      **** 					 		I2CCmdHandler();
 2262              		.loc 1 685 0
 2263 128c FEFFFFEB 		bl	I2CCmdHandler
 686:../uvc.c      **** 							 break;
 2264              		.loc 1 686 0
 2265 1290 FFE0A0E3 		mov	lr, #255
 685:../uvc.c      **** 					 		I2CCmdHandler();
 2266              		.loc 1 685 0
 2267 1294 18309DE5 		ldr	r3, [sp, #24]
 2268 1298 1CC09DE5 		ldr	ip, [sp, #28]
 686:../uvc.c      **** 							 break;
 2269              		.loc 1 686 0
 2270 129c 0E40A0E1 		mov	r4, lr
 2271 12a0 2FFEFFEA 		b	.L119
 2272              	.LVL181:
 2273              	.L165:
 676:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2274              		.loc 1 676 0
 2275 12a4 34479FE5 		ldr	r4, .L215+36
 2276 12a8 0010E0E3 		mvn	r1, #0
 2277 12ac 1C0094E5 		ldr	r0, [r4, #28]
 2278 12b0 FEFFFFEB 		bl	_txe_mutex_get
 2279              	.LVL182:
 677:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2280              		.loc 1 677 0
 2281 12b4 18009DE5 		ldr	r0, [sp, #24]
 2282 12b8 00E0A0E3 		mov	lr, #0
 2283 12bc 01C070E2 		rsbs	ip, r0, #1
 2284 12c0 00C0A033 		movcc	ip, #0
 2285 12c4 0A30A0E1 		mov	r3, sl
 2286 12c8 1E10A0E3 		mov	r1, #30
 2287 12cc 0920A0E1 		mov	r2, r9
 2288 12d0 0400A0E1 		mov	r0, r4
 2289 12d4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2290 12d8 FEFFFFEB 		bl	cmdSet
 678:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2291              		.loc 1 678 0
 2292 12dc 1C0094E5 		ldr	r0, [r4, #28]
 2293 12e0 FEFFFFEB 		bl	_txe_mutex_put
 679:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2294              		.loc 1 679 0
 2295 12e4 0130A0E3 		mov	r3, #1
 680:../uvc.c      **** 							 break;
 2296              		.loc 1 680 0
 2297 12e8 FFE0A0E3 		mov	lr, #255
 679:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2298              		.loc 1 679 0
 2299 12ec 6034C6E5 		strb	r3, [r6, #1120]
 2300 12f0 1CC09DE5 		ldr	ip, [sp, #28]
 2301 12f4 18309DE5 		ldr	r3, [sp, #24]
 680:../uvc.c      **** 							 break;
 2302              		.loc 1 680 0
 2303 12f8 0E40A0E1 		mov	r4, lr
 2304 12fc 18FEFFEA 		b	.L119
 2305              	.LVL183:
 2306              	.L163:
 643:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2307              		.loc 1 643 0
 2308 1300 D8469FE5 		ldr	r4, .L215+36
 639:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = getData;//exposure mode
 2309              		.loc 1 639 0
 2310 1304 E533C6E5 		strb	r3, [r6, #997]
 640:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2311              		.loc 1 640 0
 2312 1308 1C309DE5 		ldr	r3, [sp, #28]
 641:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2313              		.loc 1 641 0
 2314 130c 0170A0E3 		mov	r7, #1
 2315              	.LVL184:
 643:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2316              		.loc 1 643 0
 2317 1310 0010E0E3 		mvn	r1, #0
 640:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = getData1;//AGC
 2318              		.loc 1 640 0
 2319 1314 E633C6E5 		strb	r3, [r6, #998]
 643:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2320              		.loc 1 643 0
 2321 1318 1C0094E5 		ldr	r0, [r4, #28]
 641:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2322              		.loc 1 641 0
 2323 131c E873C6E5 		strb	r7, [r6, #1000]
 2324              	.LVL185:
 643:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2325              		.loc 1 643 0
 2326 1320 FEFFFFEB 		bl	_txe_mutex_get
 2327              	.LVL186:
 644:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, getData, dataIdx);  //Exposure
 2328              		.loc 1 644 0
 2329 1324 18C09DE5 		ldr	ip, [sp, #24]
 2330 1328 0400A0E1 		mov	r0, r4
 2331 132c 00C08DE5 		str	ip, [sp, #0]
 2332 1330 1910A0E3 		mov	r1, #25
 2333 1334 00C0A0E3 		mov	ip, #0
 2334 1338 0920A0E1 		mov	r2, r9
 2335 133c 0A30A0E1 		mov	r3, sl
 2336 1340 04C08DE5 		str	ip, [sp, #4]
 2337 1344 FEFFFFEB 		bl	cmdSet
 645:../uvc.c      **** 							 if(getData != 0){
 2338              		.loc 1 645 0
 2339 1348 18009DE5 		ldr	r0, [sp, #24]
 2340 134c 000050E3 		cmp	r0, #0
 2341 1350 0700000A 		beq	.L179
 2342              	.LVL187:
 647:../uvc.c      **** 								 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, getData1, dataIdx);  //AGC
 2343              		.loc 1 647 0
 2344 1354 1CE09DE5 		ldr	lr, [sp, #28]
 2345 1358 0400A0E1 		mov	r0, r4
 2346 135c 1910A0E3 		mov	r1, #25
 2347 1360 0B20A0E1 		mov	r2, fp
 2348 1364 0A30A0E1 		mov	r3, sl
 2349 1368 00E08DE5 		str	lr, [sp, #0]
 2350 136c 04708DE5 		str	r7, [sp, #4]
 2351 1370 FEFFFFEB 		bl	cmdSet
 2352              	.LVL188:
 2353              	.L179:
 649:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2354              		.loc 1 649 0
 2355 1374 1C0094E5 		ldr	r0, [r4, #28]
 2356 1378 FEFFFFEB 		bl	_txe_mutex_put
 650:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2357              		.loc 1 650 0
 2358 137c 44069FE5 		ldr	r0, .L215+12
 2359 1380 40169FE5 		ldr	r1, .L215+12
 2360 1384 5AC0D0E5 		ldrb	ip, [r0, #90]	@ zero_extendqisi2
 2361 1388 5B40D1E5 		ldrb	r4, [r1, #91]	@ zero_extendqisi2
 2362 138c 5930D0E5 		ldrb	r3, [r0, #89]	@ zero_extendqisi2
 2363 1390 5820D0E5 		ldrb	r2, [r0, #88]	@ zero_extendqisi2
 2364 1394 4C169FE5 		ldr	r1, .L215+44
 2365 1398 0400A0E3 		mov	r0, #4
 2366 139c 00C08DE5 		str	ip, [sp, #0]
 2367 13a0 04408DE5 		str	r4, [sp, #4]
 2368 13a4 FEFFFFEB 		bl	CyU3PDebugPrint
 651:../uvc.c      **** 							 break;
 2369              		.loc 1 651 0
 2370 13a8 FFE0A0E3 		mov	lr, #255
 650:../uvc.c      **** 							 CyU3PDebugPrint (4, "ExpM&AGC gotten from host. %d %d; %d %d\r\n", glEp0Buffer[0], glEp0Buf
 2371              		.loc 1 650 0
 2372 13ac 18309DE5 		ldr	r3, [sp, #24]
 2373 13b0 1CC09DE5 		ldr	ip, [sp, #28]
 651:../uvc.c      **** 							 break;
 2374              		.loc 1 651 0
 2375 13b4 0E40A0E1 		mov	r4, lr
 2376 13b8 E9FDFFEA 		b	.L119
 2377              	.LVL189:
 2378              	.L162:
 606:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2379              		.loc 1 606 0
 2380 13bc 001053E2 		subs	r1, r3, #0
 605:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2381              		.loc 1 605 0
 2382 13c0 0D13C6E5 		strb	r1, [r6, #781]
 2383 13c4 F0359FE5 		ldr	r3, .L215
 606:../uvc.c      **** 							 if(Data0 == 0){//set exposure mode auto
 2384              		.loc 1 606 0
 2385 13c8 5501001A 		bne	.L173
 607:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 8) && (CTCtrlParArry[AutoExMCtlID1][13] != 2)){
 2386              		.loc 1 607 0
 2387 13cc B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2388              	.LVL190:
 2389 13d0 020052E3 		cmp	r2, #2
 2390 13d4 08005213 		cmpne	r2, #8
 2391 13d8 0300000A 		beq	.L174
 608:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 1) {
 2392              		.loc 1 608 0
 2393 13dc 010052E3 		cmp	r2, #1
 609:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 8; //aperture priority
 2394              		.loc 1 609 0
 2395 13e0 07208202 		addeq	r2, r2, #7
 611:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 2; //auto mode
 2396              		.loc 1 611 0
 2397 13e4 0220A013 		movne	r2, #2
 2398 13e8 B524C3E5 		strb	r2, [r3, #1205]
 2399              	.LVL191:
 2400              	.L174:
 633:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2401              		.loc 1 633 0
 2402 13ec EC459FE5 		ldr	r4, .L215+36
 631:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2403              		.loc 1 631 0
 2404 13f0 0120A0E3 		mov	r2, #1
 633:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2405              		.loc 1 633 0
 2406 13f4 0010E0E3 		mvn	r1, #0
 631:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2407              		.loc 1 631 0
 2408 13f8 1023C6E5 		strb	r2, [r6, #784]
 2409              	.LVL192:
 633:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2410              		.loc 1 633 0
 2411 13fc 1C0094E5 		ldr	r0, [r4, #28]
 2412 1400 FEFFFFEB 		bl	_txe_mutex_get
 634:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2413              		.loc 1 634 0
 2414 1404 18C09DE5 		ldr	ip, [sp, #24]
 2415 1408 1010A0E3 		mov	r1, #16
 2416 140c 00C08DE5 		str	ip, [sp, #0]
 2417 1410 0920A0E1 		mov	r2, r9
 2418 1414 0A30A0E1 		mov	r3, sl
 2419 1418 0400A0E1 		mov	r0, r4
 2420 141c 00C0A0E3 		mov	ip, #0
 2421              	.LVL193:
 2422              	.L206:
 839:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2423              		.loc 1 839 0
 2424 1420 04C08DE5 		str	ip, [sp, #4]
 2425 1424 FEFFFFEB 		bl	cmdSet
 840:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2426              		.loc 1 840 0
 2427 1428 1C0094E5 		ldr	r0, [r4, #28]
 2428 142c FEFFFFEB 		bl	_txe_mutex_put
 842:../uvc.c      **** 					 		 break;
 2429              		.loc 1 842 0
 2430 1430 FFE0A0E3 		mov	lr, #255
 840:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2431              		.loc 1 840 0
 2432 1434 18309DE5 		ldr	r3, [sp, #24]
 2433 1438 1CC09DE5 		ldr	ip, [sp, #28]
 842:../uvc.c      **** 					 		 break;
 2434              		.loc 1 842 0
 2435 143c 0E40A0E1 		mov	r4, lr
 2436 1440 C7FDFFEA 		b	.L119
 2437              	.LVL194:
 2438              	.L164:
 654:../uvc.c      **** 							 if(Data0 <= 3){
 2439              		.loc 1 654 0
 2440 1444 030053E3 		cmp	r3, #3
 655:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2441              		.loc 1 655 0
 2442 1448 78259F95 		ldrls	r2, .L215+12
 2443              	.LVL195:
 658:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2444              		.loc 1 658 0
 2445 144c 74E59F85 		ldrhi	lr, .L215+12
 2446 1450 0340A0E1 		mov	r4, r3
 2447              	.LVL196:
 655:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2448              		.loc 1 655 0
 2449 1454 0030A093 		movls	r3, #0
 2450 1458 7830C295 		strlsb	r3, [r2, #120]
 2451              	.LVL197:
 658:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2452              		.loc 1 658 0
 2453 145c 0120A083 		movhi	r2, #1
 2454 1460 18209D95 		ldrls	r2, [sp, #24]
 655:../uvc.c      **** 								 CamMode = 0; //set 1080p flag
 2455              		.loc 1 655 0
 2456 1464 0430A091 		movls	r3, r4
 658:../uvc.c      **** 								 CamMode = 1; //set 720p flag
 2457              		.loc 1 658 0
 2458 1468 7820CE85 		strhib	r2, [lr, #120]
 2459 146c 0420A081 		movhi	r2, r4
 664:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2460              		.loc 1 664 0
 2461 1470 68459FE5 		ldr	r4, .L215+36
 659:../uvc.c      **** 								 Data1 = Data0-4;
 2462              		.loc 1 659 0
 2463 1474 04304382 		subhi	r3, r3, #4
 2464              	.LVL198:
 661:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2465              		.loc 1 661 0
 2466 1478 2D24C6E5 		strb	r2, [r6, #1069]
 663:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2467              		.loc 1 663 0
 2468 147c 0120A0E3 		mov	r2, #1
 664:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2469              		.loc 1 664 0
 2470 1480 0010E0E3 		mvn	r1, #0
 662:../uvc.c      **** 							 CtrlParArry[BLCIndex][13] = Data1;
 2471              		.loc 1 662 0
 2472 1484 8D31C6E5 		strb	r3, [r6, #397]
 663:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2473              		.loc 1 663 0
 2474 1488 3024C6E5 		strb	r2, [r6, #1072]
 664:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2475              		.loc 1 664 0
 2476 148c 1C0094E5 		ldr	r0, [r4, #28]
 2477 1490 FEFFFFEB 		bl	_txe_mutex_get
 2478              	.LVL199:
 665:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2479              		.loc 1 665 0
 2480 1494 18C09DE5 		ldr	ip, [sp, #24]
 2481 1498 1C10A0E3 		mov	r1, #28
 2482 149c 00C08DE5 		str	ip, [sp, #0]
 2483 14a0 0920A0E1 		mov	r2, r9
 2484 14a4 0A30A0E1 		mov	r3, sl
 2485 14a8 0400A0E1 		mov	r0, r4
 2486 14ac 00C0A0E3 		mov	ip, #0
 2487 14b0 DAFFFFEA 		b	.L206
 2488              	.LVL200:
 2489              	.L161:
 799:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2490              		.loc 1 799 0
 2491 14b4 24459FE5 		ldr	r4, .L215+36
 2492 14b8 0010E0E3 		mvn	r1, #0
 2493 14bc 1C0094E5 		ldr	r0, [r4, #28]
 2494 14c0 FEFFFFEB 		bl	_txe_mutex_get
 2495              	.LVL201:
 800:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2496              		.loc 1 800 0
 2497 14c4 18C09DE5 		ldr	ip, [sp, #24]
 2498 14c8 0B10A0E3 		mov	r1, #11
 2499 14cc 0920A0E1 		mov	r2, r9
 2500 14d0 0A30A0E1 		mov	r3, sl
 2501 14d4 0400A0E1 		mov	r0, r4
 2502 14d8 00C08DE5 		str	ip, [sp, #0]
 2503 14dc 00C0A0E3 		mov	ip, #0
 2504 14e0 04C08DE5 		str	ip, [sp, #4]
 2505 14e4 FEFFFFEB 		bl	cmdSet
 2506              	.LVL202:
 802:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //Second
 2507              		.loc 1 802 0
 2508 14e8 1CE09DE5 		ldr	lr, [sp, #28]
 2509 14ec 0B20A0E1 		mov	r2, fp
 2510 14f0 0A30A0E1 		mov	r3, sl
 2511 14f4 0170A0E3 		mov	r7, #1
 2512              	.LVL203:
 2513 14f8 0B10A0E3 		mov	r1, #11
 2514 14fc 0400A0E1 		mov	r0, r4
 2515 1500 00E08DE5 		str	lr, [sp, #0]
 2516 1504 04708DE5 		str	r7, [sp, #4]
 2517 1508 FEFFFFEB 		bl	cmdSet
 803:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2518              		.loc 1 803 0
 2519 150c 1C0094E5 		ldr	r0, [r4, #28]
 2520 1510 FEFFFFEB 		bl	_txe_mutex_put
 806:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2521              		.loc 1 806 0
 2522 1514 1C209DE5 		ldr	r2, [sp, #28]
 805:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2523              		.loc 1 805 0
 2524 1518 18309DE5 		ldr	r3, [sp, #24]
 808:../uvc.c      **** 							 break;
 2525              		.loc 1 808 0
 2526 151c FFE0A0E3 		mov	lr, #255
 805:../uvc.c      **** 							 WBMenuCmpArry[0] = Data0;//using for blue part
 2527              		.loc 1 805 0
 2528 1520 8C34C6E5 		strb	r3, [r6, #1164]
 806:../uvc.c      **** 							 WBMenuCmpArry[2] = Data1;//using for red part
 2529              		.loc 1 806 0
 2530 1524 8E24C6E5 		strb	r2, [r6, #1166]
 807:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2531              		.loc 1 807 0
 2532 1528 9872C6E5 		strb	r7, [r6, #664]
 2533 152c 02C0A0E1 		mov	ip, r2
 808:../uvc.c      **** 							 break;
 2534              		.loc 1 808 0
 2535 1530 0E40A0E1 		mov	r4, lr
 2536 1534 8AFDFFEA 		b	.L119
 2537              	.LVL204:
 2538              	.L160:
 785:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2539              		.loc 1 785 0
 2540 1538 A0449FE5 		ldr	r4, .L215+36
 2541 153c 0010E0E3 		mvn	r1, #0
 2542 1540 1C0094E5 		ldr	r0, [r4, #28]
 2543 1544 FEFFFFEB 		bl	_txe_mutex_get
 2544              	.LVL205:
 786:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2545              		.loc 1 786 0
 2546 1548 18C09DE5 		ldr	ip, [sp, #24]
 2547 154c 0610A0E3 		mov	r1, #6
 2548 1550 0920A0E1 		mov	r2, r9
 2549 1554 0A30A0E1 		mov	r3, sl
 2550 1558 0400A0E1 		mov	r0, r4
 2551 155c 00C08DE5 		str	ip, [sp, #0]
 2552 1560 00C0A0E3 		mov	ip, #0
 2553 1564 04C08DE5 		str	ip, [sp, #4]
 2554 1568 FEFFFFEB 		bl	cmdSet
 2555              	.LVL206:
 788:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data0, dataIdx);  //Second
 2556              		.loc 1 788 0
 2557 156c 18E09DE5 		ldr	lr, [sp, #24]
 2558 1570 0A30A0E1 		mov	r3, sl
 2559 1574 0170A0E3 		mov	r7, #1
 2560              	.LVL207:
 2561 1578 0610A0E3 		mov	r1, #6
 2562 157c 0B20A0E1 		mov	r2, fp
 2563 1580 0400A0E1 		mov	r0, r4
 2564 1584 00E08DE5 		str	lr, [sp, #0]
 2565 1588 04708DE5 		str	r7, [sp, #4]
 2566 158c FEFFFFEB 		bl	cmdSet
 789:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2567              		.loc 1 789 0
 2568 1590 1C0094E5 		ldr	r0, [r4, #28]
 2569 1594 FEFFFFEB 		bl	_txe_mutex_put
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2570              		.loc 1 790 0
 2571 1598 18409DE5 		ldr	r4, [sp, #24]
 792:../uvc.c      **** 							 break;
 2572              		.loc 1 792 0
 2573 159c FFE0A0E3 		mov	lr, #255
 790:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2574              		.loc 1 790 0
 2575 15a0 1D42C6E5 		strb	r4, [r6, #541]
 791:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2576              		.loc 1 791 0
 2577 15a4 0430A0E1 		mov	r3, r4
 2578 15a8 2072C6E5 		strb	r7, [r6, #544]
 2579 15ac 1CC09DE5 		ldr	ip, [sp, #28]
 792:../uvc.c      **** 							 break;
 2580              		.loc 1 792 0
 2581 15b0 0E40A0E1 		mov	r4, lr
 2582 15b4 6AFDFFEA 		b	.L119
 2583              	.LVL208:
 2584              	.L159:
 765:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2585              		.loc 1 765 0
 2586 15b8 20449FE5 		ldr	r4, .L215+36
 2587 15bc 0010E0E3 		mvn	r1, #0
 2588 15c0 1C0094E5 		ldr	r0, [r4, #28]
 2589 15c4 FEFFFFEB 		bl	_txe_mutex_get
 2590              	.LVL209:
 766:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, (Data0-GREEN_BASE), dataIdx);  //First
 2591              		.loc 1 766 0
 2592 15c8 18109DE5 		ldr	r1, [sp, #24]
 2593 15cc 00E0A0E3 		mov	lr, #0
 2594 15d0 802041E2 		sub	r2, r1, #128
 2595 15d4 FFC002E2 		and	ip, r2, #255
 2596 15d8 0510A0E3 		mov	r1, #5
 2597 15dc 0920A0E1 		mov	r2, r9
 2598 15e0 0A30A0E1 		mov	r3, sl
 2599 15e4 0400A0E1 		mov	r0, r4
 2600 15e8 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2601 15ec FEFFFFEB 		bl	cmdSet
 2602              	.LVL210:
 768:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data0-MAGENTA_BASE), dataIdx);  //Second
 2603              		.loc 1 768 0
 2604 15f0 18009DE5 		ldr	r0, [sp, #24]
 2605 15f4 0510A0E3 		mov	r1, #5
 2606 15f8 767040E2 		sub	r7, r0, #118
 2607              	.LVL211:
 2608 15fc FFC007E2 		and	ip, r7, #255
 2609 1600 DC20A0E3 		mov	r2, #220
 2610 1604 0170A0E3 		mov	r7, #1
 2611 1608 0A30A0E1 		mov	r3, sl
 2612 160c 0400A0E1 		mov	r0, r4
 2613 1610 00C08DE5 		str	ip, [sp, #0]
 2614 1614 04708DE5 		str	r7, [sp, #4]
 2615 1618 FEFFFFEB 		bl	cmdSet
 2616              	.LVL212:
 770:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data0-YELLOW_BASE), dataIdx);  //Third
 2617              		.loc 1 770 0
 2618 161c 18309DE5 		ldr	r3, [sp, #24]
 2619 1620 DE20A0E3 		mov	r2, #222
 2620 1624 7E1083E2 		add	r1, r3, #126
 2621 1628 FFC001E2 		and	ip, r1, #255
 2622 162c 0A30A0E1 		mov	r3, sl
 2623 1630 0510A0E3 		mov	r1, #5
 2624 1634 0400A0E1 		mov	r0, r4
 2625 1638 00C08DE5 		str	ip, [sp, #0]
 2626 163c 02C0A0E3 		mov	ip, #2
 2627 1640 04C08DE5 		str	ip, [sp, #4]
 2628 1644 FEFFFFEB 		bl	cmdSet
 2629              	.LVL213:
 772:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data0-CYAN_BASE), dataIdx);  //Fourth
 2630              		.loc 1 772 0
 2631 1648 18209DE5 		ldr	r2, [sp, #24]
 2632 164c 0510A0E3 		mov	r1, #5
 2633 1650 720082E2 		add	r0, r2, #114
 2634 1654 FFC000E2 		and	ip, r0, #255
 2635 1658 E020A0E3 		mov	r2, #224
 2636 165c 0A30A0E1 		mov	r3, sl
 2637 1660 0400A0E1 		mov	r0, r4
 2638 1664 00C08DE5 		str	ip, [sp, #0]
 2639 1668 03C0A0E3 		mov	ip, #3
 2640 166c 04C08DE5 		str	ip, [sp, #4]
 2641 1670 FEFFFFEB 		bl	cmdSet
 2642              	.LVL214:
 774:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data0-RED_BASE), dataIdx);  //Fifth
 2643              		.loc 1 774 0
 2644 1674 18309DE5 		ldr	r3, [sp, #24]
 2645 1678 DD20A0E3 		mov	r2, #221
 2646 167c 6F1043E2 		sub	r1, r3, #111
 2647 1680 FFC001E2 		and	ip, r1, #255
 2648 1684 0A30A0E1 		mov	r3, sl
 2649 1688 0510A0E3 		mov	r1, #5
 2650 168c 0400A0E1 		mov	r0, r4
 2651 1690 00C08DE5 		str	ip, [sp, #0]
 2652 1694 04C0A0E3 		mov	ip, #4
 2653 1698 04C08DE5 		str	ip, [sp, #4]
 2654 169c FEFFFFEB 		bl	cmdSet
 2655              	.LVL215:
 776:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, (glEp0Buffer[0]-BLUE_BASE), dataIdx);   //Sixth
 2656              		.loc 1 776 0
 2657 16a0 20239FE5 		ldr	r2, .L215+12
 2658 16a4 05E0A0E3 		mov	lr, #5
 2659 16a8 5800D2E5 		ldrb	r0, [r2, #88]	@ zero_extendqisi2
 2660 16ac 0E10A0E1 		mov	r1, lr
 2661 16b0 7F3080E2 		add	r3, r0, #127
 2662 16b4 FFC003E2 		and	ip, r3, #255
 2663 16b8 0B20A0E1 		mov	r2, fp
 2664 16bc 0A30A0E1 		mov	r3, sl
 2665 16c0 0400A0E1 		mov	r0, r4
 2666 16c4 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2667 16c8 FEFFFFEB 		bl	cmdSet
 777:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2668              		.loc 1 777 0
 2669 16cc 1C0094E5 		ldr	r0, [r4, #28]
 2670 16d0 FEFFFFEB 		bl	_txe_mutex_put
 779:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2671              		.loc 1 779 0
 2672 16d4 EC129FE5 		ldr	r1, .L215+12
 781:../uvc.c      **** 							 break;
 2673              		.loc 1 781 0
 2674 16d8 FFE0A0E3 		mov	lr, #255
 779:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2675              		.loc 1 779 0
 2676 16dc 58C0D1E5 		ldrb	ip, [r1, #88]	@ zero_extendqisi2
 780:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2677              		.loc 1 780 0
 2678 16e0 0872C6E5 		strb	r7, [r6, #520]
 779:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = glEp0Buffer[0] - GREEN_BASE;
 2679              		.loc 1 779 0
 2680 16e4 80204CE2 		sub	r2, ip, #128
 2681 16e8 0522C6E5 		strb	r2, [r6, #517]
 780:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2682              		.loc 1 780 0
 2683 16ec 18309DE5 		ldr	r3, [sp, #24]
 2684 16f0 1CC09DE5 		ldr	ip, [sp, #28]
 781:../uvc.c      **** 							 break;
 2685              		.loc 1 781 0
 2686 16f4 0E40A0E1 		mov	r4, lr
 2687 16f8 19FDFFEA 		b	.L119
 2688              	.LVL216:
 2689              	.L158:
 817:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2690              		.loc 1 817 0
 2691 16fc DC429FE5 		ldr	r4, .L215+36
 811:../uvc.c      **** 							 Data0 = Data0 - 1;
 2692              		.loc 1 811 0
 2693 1700 017043E2 		sub	r7, r3, #1
 2694              	.LVL217:
 2695 1704 FF7007E2 		and	r7, r7, #255
 2696              	.LVL218:
 815:../uvc.c      **** 								 Data0 = 1;
 2697              		.loc 1 815 0
 2698 1708 020057E3 		cmp	r7, #2
 817:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2699              		.loc 1 817 0
 2700 170c 0010E0E3 		mvn	r1, #0
 2701 1710 1C0094E5 		ldr	r0, [r4, #28]
 815:../uvc.c      **** 								 Data0 = 1;
 2702              		.loc 1 815 0
 2703 1714 0170A083 		movhi	r7, #1
 2704              	.LVL219:
 817:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2705              		.loc 1 817 0
 2706 1718 FEFFFFEB 		bl	_txe_mutex_get
 2707              	.LVL220:
 818:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2708              		.loc 1 818 0
 2709 171c 00C0A0E3 		mov	ip, #0
 2710 1720 0A30A0E1 		mov	r3, sl
 2711 1724 0410A0E3 		mov	r1, #4
 2712 1728 0920A0E1 		mov	r2, r9
 2713 172c 0400A0E1 		mov	r0, r4
 2714 1730 80108DE8 		stmia	sp, {r7, ip}	@ phole stm
 2715 1734 FEFFFFEB 		bl	cmdSet
 819:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2716              		.loc 1 819 0
 2717 1738 1C0094E5 		ldr	r0, [r4, #28]
 2718 173c FEFFFFEB 		bl	_txe_mutex_put
 823:../uvc.c      **** 							 break;
 2719              		.loc 1 823 0
 2720 1740 FFE0A0E3 		mov	lr, #255
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2721              		.loc 1 822 0
 2722 1744 0100A0E3 		mov	r0, #1
 821:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2723              		.loc 1 821 0
 2724 1748 ED71C6E5 		strb	r7, [r6, #493]
 822:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2725              		.loc 1 822 0
 2726 174c F001C6E5 		strb	r0, [r6, #496]
 2727 1750 18309DE5 		ldr	r3, [sp, #24]
 2728 1754 1CC09DE5 		ldr	ip, [sp, #28]
 823:../uvc.c      **** 							 break;
 2729              		.loc 1 823 0
 2730 1758 0E40A0E1 		mov	r4, lr
 2731 175c 00FDFFEA 		b	.L119
 2732              	.LVL221:
 2733              	.L157:
 741:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2734              		.loc 1 741 0
 2735 1760 78729FE5 		ldr	r7, .L215+36
 2736              	.LVL222:
 2737 1764 0010E0E3 		mvn	r1, #0
 2738 1768 1C0097E5 		ldr	r0, [r7, #28]
 2739 176c FEFFFFEB 		bl	_txe_mutex_get
 2740              	.LVL223:
 743:../uvc.c      **** 							  if(Data0&0x80){
 2741              		.loc 1 743 0
 2742 1770 18809DE5 		ldr	r8, [sp, #24]
 744:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2743              		.loc 1 744 0
 2744 1774 A601D6E5 		ldrb	r0, [r6, #422]	@ zero_extendqisi2
 743:../uvc.c      **** 							  if(Data0&0x80){
 2745              		.loc 1 743 0
 2746 1778 800018E3 		tst	r8, #128
 746:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2747              		.loc 1 746 0
 2748 177c 2843A001 		moveq	r4, r8, lsr #6
 744:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2749              		.loc 1 744 0
 2750 1780 884CA011 		movne	r4, r8, asl #25
 746:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2751              		.loc 1 746 0
 2752 1784 02408403 		orreq	r4, r4, #2
 744:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2753              		.loc 1 744 0
 2754 1788 0300C013 		bicne	r0, r0, #3
 746:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2755              		.loc 1 746 0
 2756 178c 0300C003 		biceq	r0, r0, #3
 744:../uvc.c      **** 								  Data1 = ((Data0 >> 6)&0x01)|(CtrlParArry[CtrlID][14]&0xfc);
 2757              		.loc 1 744 0
 2758 1790 A44F8011 		orrne	r4, r0, r4, lsr #31
 746:../uvc.c      **** 								  Data1 = ((Data0 >> 6)|0x02)|(CtrlParArry[CtrlID][14]&0xfc);
 2759              		.loc 1 746 0
 2760 1794 00408401 		orreq	r4, r4, r0
 2761              	.LVL224:
 748:../uvc.c      **** 							 Data1 |= ~0x03;
 2762              		.loc 1 748 0
 2763 1798 043FE0E1 		mvn	r3, r4, asl #30
 2764 179c 231FE0E1 		mvn	r1, r3, lsr #30
 2765              	.LVL225:
 749:../uvc.c      **** 							 Data1 &= 0xC7;
 2766              		.loc 1 749 0
 2767 17a0 C7C001E2 		and	ip, r1, #199
 2768              	.LVL226:
 750:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2769              		.loc 1 750 0
 2770 17a4 00E0A0E3 		mov	lr, #0
 2771 17a8 0110A0E3 		mov	r1, #1
 2772 17ac 0B20A0E1 		mov	r2, fp
 2773 17b0 0A30A0E1 		mov	r3, sl
 2774 17b4 24029FE5 		ldr	r0, .L215+36
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2775              		.loc 1 754 0
 2776 17b8 0140A0E1 		mov	r4, r1
 750:../uvc.c      **** 						  	 cmdSet(cmdQuptr, CtrlID, RegAdd1, devAdd, Data1, dataIdx);  //First
 2777              		.loc 1 750 0
 2778 17bc 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2779 17c0 14C08DE5 		str	ip, [sp, #20]
 2780 17c4 FEFFFFEB 		bl	cmdSet
 2781              	.LVL227:
 753:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2782              		.loc 1 753 0
 2783 17c8 18209DE5 		ldr	r2, [sp, #24]
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2784              		.loc 1 754 0
 2785 17cc 0410A0E1 		mov	r1, r4
 753:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2786              		.loc 1 753 0
 2787 17d0 0281A0E1 		mov	r8, r2, asl #2
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2788              		.loc 1 754 0
 2789 17d4 0A30A0E1 		mov	r3, sl
 753:../uvc.c      **** 							 Data0 = (Data0 << 2);
 2790              		.loc 1 753 0
 2791 17d8 FF8008E2 		and	r8, r8, #255
 2792              	.LVL228:
 754:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);   //Second
 2793              		.loc 1 754 0
 2794 17dc 0920A0E1 		mov	r2, r9
 2795 17e0 F8019FE5 		ldr	r0, .L215+36
 2796 17e4 04408DE5 		str	r4, [sp, #4]
 2797 17e8 00808DE5 		str	r8, [sp, #0]
 2798 17ec FEFFFFEB 		bl	cmdSet
 755:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2799              		.loc 1 755 0
 2800 17f0 1C0097E5 		ldr	r0, [r7, #28]
 2801 17f4 FEFFFFEB 		bl	_txe_mutex_put
 757:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2802              		.loc 1 757 0
 2803 17f8 A581C6E5 		strb	r8, [r6, #421]
 758:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2804              		.loc 1 758 0
 2805 17fc 14009DE5 		ldr	r0, [sp, #20]
 761:../uvc.c      **** 							 break;
 2806              		.loc 1 761 0
 2807 1800 FFE0A0E3 		mov	lr, #255
 759:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2808              		.loc 1 759 0
 2809 1804 A841C6E5 		strb	r4, [r6, #424]
 758:../uvc.c      **** 							 CtrlParArry[CtrlID][14] = Data1;
 2810              		.loc 1 758 0
 2811 1808 A601C6E5 		strb	r0, [r6, #422]
 759:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2812              		.loc 1 759 0
 2813 180c 18309DE5 		ldr	r3, [sp, #24]
 2814 1810 1CC09DE5 		ldr	ip, [sp, #28]
 761:../uvc.c      **** 							 break;
 2815              		.loc 1 761 0
 2816 1814 0E40A0E1 		mov	r4, lr
 2817 1818 D1FCFFEA 		b	.L119
 2818              	.LVL229:
 2819              	.L156:
 827:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2820              		.loc 1 827 0
 2821 181c A4219FE5 		ldr	r2, .L215+12
 2822              	.LVL230:
 826:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2823              		.loc 1 826 0
 2824 1820 0110A0E3 		mov	r1, #1
 827:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2825              		.loc 1 827 0
 2826 1824 7820D2E5 		ldrb	r2, [r2, #120]	@ zero_extendqisi2
 825:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2827              		.loc 1 825 0
 2828 1828 8D31C6E5 		strb	r3, [r6, #397]
 827:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2829              		.loc 1 827 0
 2830 182c 010052E3 		cmp	r2, #1
 826:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2831              		.loc 1 826 0
 2832 1830 9011C6E5 		strb	r1, [r6, #400]
 2833 1834 0370A011 		movne	r7, r3
 2834              	.LVL231:
 827:../uvc.c      **** 							 if(CamMode == 1) //mode 720p
 2835              		.loc 1 827 0
 2836 1838 4E00000A 		beq	.L214
 2837              	.LVL232:
 2838              	.L189:
 838:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2839              		.loc 1 838 0
 2840 183c 9C419FE5 		ldr	r4, .L215+36
 2841 1840 0010E0E3 		mvn	r1, #0
 2842 1844 1C0094E5 		ldr	r0, [r4, #28]
 836:../uvc.c      **** 							 CtrlParArry[CamModeIndex][13] = Data0;
 2843              		.loc 1 836 0
 2844 1848 2D74C6E5 		strb	r7, [r6, #1069]
 2845              	.LVL233:
 838:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2846              		.loc 1 838 0
 2847 184c FEFFFFEB 		bl	_txe_mutex_get
 839:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2848              		.loc 1 839 0
 2849 1850 00C0A0E3 		mov	ip, #0
 2850 1854 0C10A0E1 		mov	r1, ip
 2851 1858 0920A0E1 		mov	r2, r9
 2852 185c 0A30A0E1 		mov	r3, sl
 2853 1860 0400A0E1 		mov	r0, r4
 2854 1864 00708DE5 		str	r7, [sp, #0]
 2855 1868 ECFEFFEA 		b	.L206
 2856              	.LVL234:
 2857              	.L155:
 846:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 2858              		.loc 1 846 0
 2859 186c 6C719FE5 		ldr	r7, .L215+36
 2860              	.LVL235:
 2861 1870 0010E0E3 		mvn	r1, #0
 2862 1874 1C0097E5 		ldr	r0, [r7, #28]
 2863 1878 FEFFFFEB 		bl	_txe_mutex_get
 2864              	.LVL236:
 847:../uvc.c      **** 							 cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, Data0, dataIdx);  //First
 2865              		.loc 1 847 0
 2866 187c 18C09DE5 		ldr	ip, [sp, #24]
 2867 1880 00E0A0E3 		mov	lr, #0
 2868 1884 0410A0E1 		mov	r1, r4
 2869 1888 0A30A0E1 		mov	r3, sl
 2870 188c 0920A0E1 		mov	r2, r9
 2871 1890 0700A0E1 		mov	r0, r7
 2872 1894 00508DE8 		stmia	sp, {ip, lr}	@ phole stm
 2873 1898 FEFFFFEB 		bl	cmdSet
 848:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 2874              		.loc 1 848 0
 2875 189c 1C0097E5 		ldr	r0, [r7, #28]
 2876 18a0 FEFFFFEB 		bl	_txe_mutex_put
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2877              		.loc 1 850 0
 2878 18a4 18009DE5 		ldr	r0, [sp, #24]
 2879 18a8 844084E0 		add	r4, r4, r4, asl #1
 2880 18ac 846186E0 		add	r6, r6, r4, asl #3
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2881              		.loc 1 851 0
 2882 18b0 0130A0E3 		mov	r3, #1
 852:../uvc.c      **** 							 break;
 2883              		.loc 1 852 0
 2884 18b4 FFE0A0E3 		mov	lr, #255
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2885              		.loc 1 851 0
 2886 18b8 9031C6E5 		strb	r3, [r6, #400]
 850:../uvc.c      **** 							 CtrlParArry[CtrlID][13] = Data0;
 2887              		.loc 1 850 0
 2888 18bc 8D01C6E5 		strb	r0, [r6, #397]
 851:../uvc.c      **** 							 CtrlParArry[CtrlID][16] = CyTrue;
 2889              		.loc 1 851 0
 2890 18c0 0030A0E1 		mov	r3, r0
 2891 18c4 1CC09DE5 		ldr	ip, [sp, #28]
 852:../uvc.c      **** 							 break;
 2892              		.loc 1 852 0
 2893 18c8 0E40A0E1 		mov	r4, lr
 2894 18cc A4FCFFEA 		b	.L119
 2895              	.LVL237:
 2896              	.L154:
 855:../uvc.c      **** 				   CyU3PDebugPrint (4, "The get data from host fail error code %d.\r\n", apiRetStatus);
 2897              		.loc 1 855 0
 2898 18d0 0400A0E3 		mov	r0, #4
 2899              	.LVL238:
 2900 18d4 10119FE5 		ldr	r1, .L215+48
 2901 18d8 FEFFFFEB 		bl	CyU3PDebugPrint
 2902              	.LVL239:
 2903 18dc FFE0A0E3 		mov	lr, #255
 2904 18e0 0E40A0E1 		mov	r4, lr
 2905 18e4 0EC0A0E1 		mov	ip, lr
 2906 18e8 0E30A0E1 		mov	r3, lr
 2907 18ec 9CFCFFEA 		b	.L119
 2908              	.LVL240:
 2909              	.L213:
 431:../uvc.c      **** 						if(sendData >= 3){
 2910              		.loc 1 431 0
 2911 18f0 020054E3 		cmp	r4, #2
 2912 18f4 04408492 		addls	r4, r4, #4
 2913              	.LVL241:
 2914 18f8 FF400492 		andls	r4, r4, #255
 2915 18fc C3FDFF9A 		bls	.L132
 432:../uvc.c      **** 							CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, se
 2916              		.loc 1 432 0
 2917 1900 0430A0E1 		mov	r3, r4
 2918 1904 0400A0E3 		mov	r0, #4
 2919 1908 E0109FE5 		ldr	r1, .L215+52
 2920 190c FEFFFFEB 		bl	CyU3PDebugPrint
 2921              	.LVL242:
 434:../uvc.c      **** 							CtrlParArry[CtrlID][13] = 0;
 2922              		.loc 1 434 0
 2923 1910 A4309FE5 		ldr	r3, .L215
 2924 1914 0020A0E3 		mov	r2, #0
 2925 1918 0440A0E3 		mov	r4, #4
 2926 191c 2D24C3E5 		strb	r2, [r3, #1069]
 2927              	.LVL243:
 2928 1920 BAFDFFEA 		b	.L132
 2929              	.LVL244:
 2930              	.L173:
 616:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2931              		.loc 1 616 0
 2932 1924 B524D3E5 		ldrb	r2, [r3, #1205]	@ zero_extendqisi2
 2933              	.LVL245:
 615:../uvc.c      **** 								 Data1 = Data0 - 1;
 2934              		.loc 1 615 0
 2935 1928 014041E2 		sub	r4, r1, #1
 616:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2936              		.loc 1 616 0
 2937 192c 040052E3 		cmp	r2, #4
 2938 1930 01005213 		cmpne	r2, #1
 615:../uvc.c      **** 								 Data1 = Data0 - 1;
 2939              		.loc 1 615 0
 2940 1934 FF1004E2 		and	r1, r4, #255
 2941              	.LVL246:
 616:../uvc.c      **** 								 if((CTCtrlParArry[AutoExMCtlID1][13] != 1) && (CTCtrlParArry[AutoExMCtlID1][13] != 4)){
 2942              		.loc 1 616 0
 2943 1938 0300000A 		beq	.L176
 617:../uvc.c      **** 									 if(CTCtrlParArry[AutoExMCtlID1][13] == 8) {
 2944              		.loc 1 617 0
 2945 193c 080052E3 		cmp	r2, #8
 618:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 1; //manual mode
 2946              		.loc 1 618 0
 2947 1940 0120A003 		moveq	r2, #1
 620:../uvc.c      **** 										 CTCtrlParArry[AutoExMCtlID1][13] = 4; //shutter priority
 2948              		.loc 1 620 0
 2949 1944 0420A013 		movne	r2, #4
 2950 1948 B524C3E5 		strb	r2, [r3, #1205]
 2951              	.L176:
 623:../uvc.c      **** 								 if(Data1 < 8){
 2952              		.loc 1 623 0
 2953 194c 070051E3 		cmp	r1, #7
 624:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2954              		.loc 1 624 0
 2955 1950 9C309F95 		ldrls	r3, .L215+56
 627:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2956              		.loc 1 627 0
 2957 1954 0130A083 		movhi	r3, #1
 625:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2958              		.loc 1 625 0
 2959 1958 81008390 		addls	r0, r3, r1, asl #1
 624:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2960              		.loc 1 624 0
 2961 195c 8120D397 		ldrlsb	r2, [r3, r1, asl #1]	@ zero_extendqisi2
 625:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[Data1][1];
 2962              		.loc 1 625 0
 2963 1960 0130D095 		ldrlsb	r3, [r0, #1]	@ zero_extendqisi2
 627:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[7][0];
 2964              		.loc 1 627 0
 2965 1964 E534C685 		strhib	r3, [r6, #1253]
 628:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2966              		.loc 1 628 0
 2967 1968 0030A083 		movhi	r3, #0
 624:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][13] = ExTime[Data1][0];
 2968              		.loc 1 624 0
 2969 196c E524C695 		strlsb	r2, [r6, #1253]
 628:../uvc.c      **** 									 CTCtrlParArry[ExTmACtlID3][14] = ExTime[7][1];
 2970              		.loc 1 628 0
 2971 1970 E634C6E5 		strb	r3, [r6, #1254]
 2972 1974 9CFEFFEA 		b	.L174
 2973              	.LVL247:
 2974              	.L214:
 829:../uvc.c      **** 								 if(Data0 < 3){
 2975              		.loc 1 829 0
 2976 1978 020053E3 		cmp	r3, #2
 830:../uvc.c      **** 					 				 Data0 += 4;
 2977              		.loc 1 830 0
 2978 197c 04708392 		addls	r7, r3, #4
 2979 1980 FF700792 		andls	r7, r7, #255
 829:../uvc.c      **** 								 if(Data0 < 3){
 2980              		.loc 1 829 0
 2981 1984 ACFFFF9A 		bls	.L189
 832:../uvc.c      **** 									CyU3PDebugPrint (4, "back light compensation setting is not correct. %d %d\r\n", CamMode, 
 2982              		.loc 1 832 0
 2983 1988 0400A0E3 		mov	r0, #4
 2984 198c 5C109FE5 		ldr	r1, .L215+52
 2985 1990 18309DE5 		ldr	r3, [sp, #24]
 2986 1994 FEFFFFEB 		bl	CyU3PDebugPrint
 2987              	.LVL248:
 833:../uvc.c      **** 									Data0 = 4; //set to default.
 2988              		.loc 1 833 0
 2989 1998 0470A0E3 		mov	r7, #4
 2990 199c A6FFFFEA 		b	.L189
 2991              	.LVL249:
 2992              	.L204:
 2993 19a0 20009FE5 		ldr	r0, .L215+12
 2994 19a4 88FDFFEA 		b	.L130
 2995              	.LVL250:
 2996              	.L192:
 375:../uvc.c      **** inline void ControlHandle(uint8_t CtrlID){
 2997              		.loc 1 375 0
 2998 19a8 0030A0E3 		mov	r3, #0
 2999 19ac 2EFEFFEA 		b	.L197
 3000              	.LVL251:
 3001              	.L191:
 3002 19b0 10009FE5 		ldr	r0, .L215+12
 3003 19b4 0030A0E3 		mov	r3, #0
 3004 19b8 7CFDFFEA 		b	.L196
 3005              	.L216:
 3006              		.align	2
 3007              	.L215:
 3008 19bc 00000000 		.word	.LANCHOR1
 3009 19c0 00000000 		.word	bRequest
 3010 19c4 40030000 		.word	.LC20
 3011 19c8 00000000 		.word	.LANCHOR0
 3012 19cc 58000000 		.word	.LANCHOR0+88
 3013 19d0 01000100 		.word	65537
 3014 19d4 FF00FF00 		.word	16711935
 3015 19d8 80020000 		.word	.LC16
 3016 19dc BC020000 		.word	.LC17
 3017 19e0 00000000 		.word	cmdQu
 3018 19e4 4C000000 		.word	.LANCHOR0+76
 3019 19e8 E4020000 		.word	.LC18
 3020 19ec 10030000 		.word	.LC19
 3021 19f0 48020000 		.word	.LC15
 3022 19f4 00000000 		.word	.LANCHOR2
 3023              		.cfi_endproc
 3024              	.LFE2:
 3026              		.align	2
 3027              		.global	CTControlHandle
 3029              	CTControlHandle:
 3030              	.LFB3:
 871:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3031              		.loc 1 871 0
 3032              		.cfi_startproc
 3033              		@ args = 0, pretend = 0, frame = 64
 3034              		@ frame_needed = 0, uses_anonymous_args = 0
 3035              	.LVL252:
 3036 19f8 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3037              	.LCFI15:
 3038              		.cfi_def_cfa_offset 36
 890:../uvc.c      ****     reqData = bRequest;
 3039              		.loc 1 890 0
 3040 19fc 60A99FE5 		ldr	sl, .L302
 3041              		.cfi_offset 14, -4
 3042              		.cfi_offset 11, -8
 3043              		.cfi_offset 10, -12
 3044              		.cfi_offset 9, -16
 3045              		.cfi_offset 8, -20
 3046              		.cfi_offset 7, -24
 3047              		.cfi_offset 6, -28
 3048              		.cfi_offset 5, -32
 3049              		.cfi_offset 4, -36
 882:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3050              		.loc 1 882 0
 3051 1a00 60899FE5 		ldr	r8, .L302+4
 890:../uvc.c      ****     reqData = bRequest;
 3052              		.loc 1 890 0
 3053 1a04 0050DAE5 		ldrb	r5, [sl, #0]	@ zero_extendqisi2
 882:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3054              		.loc 1 882 0
 3055 1a08 8090A0E1 		mov	r9, r0, asl #1
 3056 1a0c 002089E0 		add	r2, r9, r0
 3057 1a10 822188E0 		add	r2, r8, r2, asl #3
 892:../uvc.c      ****     switch (bRequest)
 3058              		.loc 1 892 0
 3059 1a14 830055E3 		cmp	r5, #131
 871:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3060              		.loc 1 871 0
 3061 1a18 5CD04DE2 		sub	sp, sp, #92
 3062              	.LCFI16:
 3063              		.cfi_def_cfa_offset 128
 871:../uvc.c      **** inline void CTControlHandle(uint8_t CtrlID){
 3064              		.loc 1 871 0
 3065 1a1c 0060A0E1 		mov	r6, r0
 882:../uvc.c      ****     uint8_t devAdd = CTCtrlParArry[CtrlID][15];
 3066              		.loc 1 882 0
 3067 1a20 9F34D2E5 		ldrb	r3, [r2, #1183]	@ zero_extendqisi2
 3068              	.LVL253:
 883:../uvc.c      ****     RegAdd0 = CTCtrlParArry[CtrlID][0];
 3069              		.loc 1 883 0
 3070 1a24 90B4D2E5 		ldrb	fp, [r2, #1168]	@ zero_extendqisi2
 3071              	.LVL254:
 885:../uvc.c      ****     Len = CTCtrlParArry[CtrlID][2];
 3072              		.loc 1 885 0
 3073 1a28 9274D2E5 		ldrb	r7, [r2, #1170]	@ zero_extendqisi2
 3074              	.LVL255:
 892:../uvc.c      ****     switch (bRequest)
 3075              		.loc 1 892 0
 3076 1a2c 7600000A 		beq	.L222
 3077 1a30 2100009A 		bls	.L297
 3078 1a34 850055E3 		cmp	r5, #133
 3079 1a38 5900000A 		beq	.L224
 3080 1a3c 4E00003A 		bcc	.L223
 3081 1a40 860055E3 		cmp	r5, #134
 3082 1a44 8000000A 		beq	.L225
 3083 1a48 870055E3 		cmp	r5, #135
 3084 1a4c 7600000A 		beq	.L298
 3085              	.L218:
1099:../uvc.c      **** 			  CyU3PUsbStall (0, CyTrue, CyFalse);
 3086              		.loc 1 1099 0
 3087 1a50 0000A0E3 		mov	r0, #0
 3088              	.LVL256:
 3089 1a54 0110A0E3 		mov	r1, #1
 3090 1a58 0020A0E1 		mov	r2, r0
 3091 1a5c FEFFFFEB 		bl	CyU3PUsbStall
 3092              	.LVL257:
 3093 1a60 04499FE5 		ldr	r4, .L302+8
1100:../uvc.c      **** 			  CyU3PDebugPrint (4, "default request (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional deb
 3094              		.loc 1 1100 0
 3095 1a64 0620A0E1 		mov	r2, r6
 3096 1a68 0400A0E3 		mov	r0, #4
 3097 1a6c FC189FE5 		ldr	r1, .L302+12
 3098 1a70 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
 3099 1a74 FEFFFFEB 		bl	CyU3PDebugPrint
1101:../uvc.c      **** 			  break;
 3100              		.loc 1 1101 0
 3101 1a78 FFC0A0E3 		mov	ip, #255
 3102 1a7c 0C60A0E1 		mov	r6, ip
 3103 1a80 0C80A0E1 		mov	r8, ip
 3104              	.LVL258:
 3105              	.L228:
1105:../uvc.c      ****     CyU3PDebugPrint (4, "The Request 0x%x parameter get from host (CT) 0x%x 0x%x 0x%x / send to hos
 3106              		.loc 1 1105 0
 3107 1a84 5AE0D4E5 		ldrb	lr, [r4, #90]	@ zero_extendqisi2
 3108 1a88 08C08DE5 		str	ip, [sp, #8]
 3109 1a8c E0189FE5 		ldr	r1, .L302+16
 3110 1a90 FFC0A0E3 		mov	ip, #255
 3111 1a94 0520A0E1 		mov	r2, r5
 3112 1a98 0830A0E1 		mov	r3, r8
 3113 1a9c 0400A0E3 		mov	r0, #4
 3114 1aa0 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 3115 1aa4 0CC08DE5 		str	ip, [sp, #12]
 3116 1aa8 10E08DE5 		str	lr, [sp, #16]
 3117 1aac 14708DE5 		str	r7, [sp, #20]
 3118 1ab0 FEFFFFEB 		bl	CyU3PDebugPrint
1106:../uvc.c      **** }
 3119              		.loc 1 1106 0
 3120 1ab4 5CD08DE2 		add	sp, sp, #92
 3121 1ab8 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 3122              	.LVL259:
 3123              	.L297:
 892:../uvc.c      ****     switch (bRequest)
 3124              		.loc 1 892 0
 3125 1abc 810055E3 		cmp	r5, #129
 3126 1ac0 4200000A 		beq	.L220
 3127 1ac4 1100009A 		bls	.L299
 921:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3128              		.loc 1 921 0
 3129 1ac8 9C489FE5 		ldr	r4, .L302+8
 3130 1acc 9314D2E5 		ldrb	r1, [r2, #1171]	@ zero_extendqisi2
 922:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3131              		.loc 1 922 0
 3132 1ad0 9464D2E5 		ldrb	r6, [r2, #1172]	@ zero_extendqisi2
 923:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3133              		.loc 1 923 0
 3134 1ad4 0A0050E3 		cmp	r0, #10
 921:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][3];
 3135              		.loc 1 921 0
 3136 1ad8 5810C4E5 		strb	r1, [r4, #88]
 922:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][4];
 3137              		.loc 1 922 0
 3138 1adc 5960C4E5 		strb	r6, [r4, #89]
 923:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;//1;
 3139              		.loc 1 923 0
 3140 1ae0 2C00000A 		beq	.L296
 3141              	.LVL260:
 3142              	.L235:
 957:../uvc.c      **** 			  else glEp0Buffer[2] = 0;
 3143              		.loc 1 957 0
 3144 1ae4 00E0A0E3 		mov	lr, #0
 3145 1ae8 5AE0C4E5 		strb	lr, [r4, #90]
 3146              	.L236:
 958:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3147              		.loc 1 958 0
 3148 1aec 0030A0E3 		mov	r3, #0
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3149              		.loc 1 959 0
 3150 1af0 0700A0E1 		mov	r0, r7
 3151              	.LVL261:
 3152 1af4 7C189FE5 		ldr	r1, .L302+20
 961:../uvc.c      **** 			  break;
 3153              		.loc 1 961 0
 3154 1af8 FF60A0E3 		mov	r6, #255
 958:../uvc.c      **** 			  glEp0Buffer[3] = 0;
 3155              		.loc 1 958 0
 3156 1afc 5B30C4E5 		strb	r3, [r4, #91]
 961:../uvc.c      **** 			  break;
 3157              		.loc 1 961 0
 3158 1b00 0680A0E1 		mov	r8, r6
 959:../uvc.c      **** 			  CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3159              		.loc 1 959 0
 3160 1b04 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3161              	.LVL262:
 3162 1b08 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 961:../uvc.c      **** 			  break;
 3163              		.loc 1 961 0
 3164 1b0c DCFFFFEA 		b	.L228
 3165              	.LVL263:
 3166              	.L299:
 892:../uvc.c      ****     switch (bRequest)
 3167              		.loc 1 892 0
 3168 1b10 010055E3 		cmp	r5, #1
 3169 1b14 CDFFFF1A 		bne	.L218
 963:../uvc.c      **** 			  apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 3170              		.loc 1 963 0
 3171 1b18 4C489FE5 		ldr	r4, .L302+8
 3172 1b1c 56208DE2 		add	r2, sp, #86
 3173 1b20 2000A0E3 		mov	r0, #32
 3174              	.LVL264:
 3175 1b24 581084E2 		add	r1, r4, #88
 3176 1b28 2C308DE5 		str	r3, [sp, #44]
 3177 1b2c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 3178              	.LVL265:
 965:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3179              		.loc 1 965 0
 3180 1b30 5800D4E5 		ldrb	r0, [r4, #88]	@ zero_extendqisi2
 966:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3181              		.loc 1 966 0
 3182 1b34 59C0D4E5 		ldrb	ip, [r4, #89]	@ zero_extendqisi2
 969:../uvc.c      **** 			  switch(CtrlID)
 3183              		.loc 1 969 0
 3184 1b38 012046E2 		sub	r2, r6, #1
 965:../uvc.c      **** 			  Data0 = glEp0Buffer[0];
 3185              		.loc 1 965 0
 3186 1b3c 30008DE5 		str	r0, [sp, #48]
 3187              	.LVL266:
 966:../uvc.c      **** 			  Data1 = glEp0Buffer[1];
 3188              		.loc 1 966 0
 3189 1b40 34C08DE5 		str	ip, [sp, #52]
 3190              	.LVL267:
 969:../uvc.c      **** 			  switch(CtrlID)
 3191              		.loc 1 969 0
 3192 1b44 2C309DE5 		ldr	r3, [sp, #44]
 3193 1b48 090052E3 		cmp	r2, #9
 3194 1b4c 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 3195 1b50 550100EA 		b	.L237
 3196              	.L242:
 3197 1b54 68200000 		.word	.L238
 3198 1b58 AC200000 		.word	.L237
 3199 1b5c 781D0000 		.word	.L239
 3200 1b60 AC200000 		.word	.L237
 3201 1b64 AC200000 		.word	.L237
 3202 1b68 AC200000 		.word	.L237
 3203 1b6c F41C0000 		.word	.L240
 3204 1b70 AC200000 		.word	.L237
 3205 1b74 AC200000 		.word	.L237
 3206 1b78 781C0000 		.word	.L241
 3207              	.LVL268:
 3208              	.L223:
 939:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3209              		.loc 1 939 0
 3210 1b7c E8479FE5 		ldr	r4, .L302+8
 3211 1b80 9784D2E5 		ldrb	r8, [r2, #1175]	@ zero_extendqisi2
 940:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3212              		.loc 1 940 0
 3213 1b84 9824D2E5 		ldrb	r2, [r2, #1176]	@ zero_extendqisi2
 941:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3214              		.loc 1 941 0
 3215 1b88 0A0050E3 		cmp	r0, #10
 939:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][7];
 3216              		.loc 1 939 0
 3217 1b8c 5880C4E5 		strb	r8, [r4, #88]
 940:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][8];
 3218              		.loc 1 940 0
 3219 1b90 5920C4E5 		strb	r2, [r4, #89]
 941:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3220              		.loc 1 941 0
 3221 1b94 D2FFFF1A 		bne	.L235
 3222              	.LVL269:
 3223              	.L296:
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3224              		.loc 1 956 0 discriminator 1
 3225 1b98 0110A0E3 		mov	r1, #1
 3226 1b9c 5A10C4E5 		strb	r1, [r4, #90]
 3227 1ba0 D1FFFFEA 		b	.L236
 3228              	.LVL270:
 3229              	.L224:
 896:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3230              		.loc 1 896 0
 3231 1ba4 C0479FE5 		ldr	r4, .L302+8
 897:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3232              		.loc 1 897 0
 3233 1ba8 0030A0E3 		mov	r3, #0
 3234              	.LVL271:
 898:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3235              		.loc 1 898 0
 3236 1bac 0200A0E3 		mov	r0, #2
 3237              	.LVL272:
 3238 1bb0 581084E2 		add	r1, r4, #88
 900:../uvc.c      **** 			  break;
 3239              		.loc 1 900 0
 3240 1bb4 FF60A0E3 		mov	r6, #255
 896:../uvc.c      **** 			  glEp0Buffer[0] = Len;
 3241              		.loc 1 896 0
 3242 1bb8 5870C4E5 		strb	r7, [r4, #88]
 897:../uvc.c      **** 			  glEp0Buffer[1] = 0;
 3243              		.loc 1 897 0
 3244 1bbc 5930C4E5 		strb	r3, [r4, #89]
 900:../uvc.c      **** 			  break;
 3245              		.loc 1 900 0
 3246 1bc0 0680A0E1 		mov	r8, r6
 898:../uvc.c      **** 			  CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 3247              		.loc 1 898 0
 3248 1bc4 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3249              	.LVL273:
 3250 1bc8 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 900:../uvc.c      **** 			  break;
 3251              		.loc 1 900 0
 3252 1bcc ACFFFFEA 		b	.L228
 3253              	.LVL274:
 3254              	.L220:
 906:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3255              		.loc 1 906 0
 3256 1bd0 94479FE5 		ldr	r4, .L302+8
 3257 1bd4 9DA4D2E5 		ldrb	sl, [r2, #1181]	@ zero_extendqisi2
 907:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3258              		.loc 1 907 0
 3259 1bd8 9EC4D2E5 		ldrb	ip, [r2, #1182]	@ zero_extendqisi2
 908:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3260              		.loc 1 908 0
 3261 1bdc 0080A0E3 		mov	r8, #0
 914:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3262              		.loc 1 914 0
 3263 1be0 0700A0E1 		mov	r0, r7
 3264              	.LVL275:
 3265 1be4 581084E2 		add	r1, r4, #88
 919:../uvc.c      **** 			  break;
 3266              		.loc 1 919 0
 3267 1be8 FF60A0E3 		mov	r6, #255
 907:../uvc.c      **** 					 glEp0Buffer[1] = CTCtrlParArry[CtrlID][14];
 3268              		.loc 1 907 0
 3269 1bec 59C0C4E5 		strb	ip, [r4, #89]
 908:../uvc.c      **** 					 glEp0Buffer[2] = 0;
 3270              		.loc 1 908 0
 3271 1bf0 5A80C4E5 		strb	r8, [r4, #90]
 909:../uvc.c      **** 					 glEp0Buffer[3] = 0;
 3272              		.loc 1 909 0
 3273 1bf4 5B80C4E5 		strb	r8, [r4, #91]
 3274              	.LVL276:
 906:../uvc.c      **** 					 glEp0Buffer[0] = CTCtrlParArry[CtrlID][13];
 3275              		.loc 1 906 0
 3276 1bf8 58A0C4E5 		strb	sl, [r4, #88]
 919:../uvc.c      **** 			  break;
 3277              		.loc 1 919 0
 3278 1bfc 0680A0E1 		mov	r8, r6
 914:../uvc.c      **** 			 CyU3PUsbSendEP0Data (Len, (uint8_t *)glEp0Buffer);
 3279              		.loc 1 914 0
 3280 1c00 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3281              	.LVL277:
 3282 1c04 0AC0A0E1 		mov	ip, sl
 919:../uvc.c      **** 			  break;
 3283              		.loc 1 919 0
 3284 1c08 9DFFFFEA 		b	.L228
 3285              	.LVL278:
 3286              	.L222:
 930:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3287              		.loc 1 930 0
 3288 1c0c 58479FE5 		ldr	r4, .L302+8
 3289 1c10 9534D2E5 		ldrb	r3, [r2, #1173]	@ zero_extendqisi2
 3290              	.LVL279:
 931:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3291              		.loc 1 931 0
 3292 1c14 96E4D2E5 		ldrb	lr, [r2, #1174]	@ zero_extendqisi2
 932:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3293              		.loc 1 932 0
 3294 1c18 0A0050E3 		cmp	r0, #10
 930:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][5];
 3295              		.loc 1 930 0
 3296 1c1c 5830C4E5 		strb	r3, [r4, #88]
 931:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][6];
 3297              		.loc 1 931 0
 3298 1c20 59E0C4E5 		strb	lr, [r4, #89]
 932:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3299              		.loc 1 932 0
 3300 1c24 AEFFFF1A 		bne	.L235
 3301 1c28 DAFFFFEA 		b	.L296
 3302              	.LVL280:
 3303              	.L298:
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3304              		.loc 1 954 0
 3305 1c2c 38479FE5 		ldr	r4, .L302+8
 3306 1c30 9B64D2E5 		ldrb	r6, [r2, #1179]	@ zero_extendqisi2
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3307              		.loc 1 955 0
 3308 1c34 9CC4D2E5 		ldrb	ip, [r2, #1180]	@ zero_extendqisi2
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3309              		.loc 1 956 0
 3310 1c38 0A0050E3 		cmp	r0, #10
 954:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][11];
 3311              		.loc 1 954 0
 3312 1c3c 5860C4E5 		strb	r6, [r4, #88]
 955:../uvc.c      **** 			  glEp0Buffer[1] = CTCtrlParArry[CtrlID][12];
 3313              		.loc 1 955 0
 3314 1c40 59C0C4E5 		strb	ip, [r4, #89]
 956:../uvc.c      **** 			  if(ZmOpRCtlID10 == CtrlID) glEp0Buffer[2] = SPEED;
 3315              		.loc 1 956 0
 3316 1c44 A6FFFF1A 		bne	.L235
 3317 1c48 D2FFFFEA 		b	.L296
 3318              	.L225:
 948:../uvc.c      **** 			  glEp0Buffer[0] = CTCtrlParArry[CtrlID][9];
 3319              		.loc 1 948 0
 3320 1c4c 18479FE5 		ldr	r4, .L302+8
 3321 1c50 9904D2E5 		ldrb	r0, [r2, #1177]	@ zero_extendqisi2
 3322              	.LVL281:
 3323 1c54 0410A0E1 		mov	r1, r4
 3324 1c58 5800E1E5 		strb	r0, [r1, #88]!
 952:../uvc.c      **** 			  break;
 3325              		.loc 1 952 0
 3326 1c5c FF60A0E3 		mov	r6, #255
 949:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3327              		.loc 1 949 0
 3328 1c60 0100A0E3 		mov	r0, #1
 3329 1c64 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 3330              	.LVL282:
 952:../uvc.c      **** 			  break;
 3331              		.loc 1 952 0
 3332 1c68 0680A0E1 		mov	r8, r6
 949:../uvc.c      **** 			  CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 3333              		.loc 1 949 0
 3334 1c6c 58C0D4E5 		ldrb	ip, [r4, #88]	@ zero_extendqisi2
 952:../uvc.c      **** 			  break;
 3335              		.loc 1 952 0
 3336 1c70 0170A0E3 		mov	r7, #1
 3337 1c74 82FFFFEA 		b	.L228
 3338              	.LVL283:
 3339              	.L241:
1078:../uvc.c      **** 					  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3340              		.loc 1 1078 0
 3341 1c78 FC669FE5 		ldr	r6, .L302+24
 3342 1c7c 0010E0E3 		mvn	r1, #0
 3343 1c80 1C0096E5 		ldr	r0, [r6, #28]
 3344 1c84 2C308DE5 		str	r3, [sp, #44]
 3345 1c88 FEFFFFEB 		bl	_txe_mutex_get
1079:../uvc.c      **** 					  if(getData == 1)
 3346              		.loc 1 1079 0
 3347 1c8c 30E09DE5 		ldr	lr, [sp, #48]
 3348 1c90 2C309DE5 		ldr	r3, [sp, #44]
 3349 1c94 01005EE3 		cmp	lr, #1
 3350 1c98 A901000A 		beq	.L300
1081:../uvc.c      **** 					  else if(getData == 0xff)
 3351              		.loc 1 1081 0
 3352 1c9c FF005EE3 		cmp	lr, #255
 3353 1ca0 9E01000A 		beq	.L301
1084:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, STOP, dataIdx);
 3354              		.loc 1 1084 0
 3355 1ca4 0080A0E3 		mov	r8, #0
 3356 1ca8 0600A0E1 		mov	r0, r6
 3357 1cac 1710A0E3 		mov	r1, #23
 3358 1cb0 0B20A0E1 		mov	r2, fp
 3359 1cb4 00808DE5 		str	r8, [sp, #0]
 3360 1cb8 04808DE5 		str	r8, [sp, #4]
 3361 1cbc FEFFFFEB 		bl	cmdSet
 3362              	.L294:
1087:../uvc.c      **** 					  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3363              		.loc 1 1087 0
 3364 1cc0 1C0096E5 		ldr	r0, [r6, #28]
 3365 1cc4 FEFFFFEB 		bl	_txe_mutex_put
1089:../uvc.c      **** 					  CyU3PDebugPrint (4, "Zoom Op receives (CT) 0x%x 0x%x 0x%x\r\n", getData, getData1, glEp0Buff
 3366              		.loc 1 1089 0
 3367 1cc8 30809DE5 		ldr	r8, [sp, #48]
 3368 1ccc 34609DE5 		ldr	r6, [sp, #52]
 3369 1cd0 5AC0D4E5 		ldrb	ip, [r4, #90]	@ zero_extendqisi2
 3370 1cd4 0400A0E3 		mov	r0, #4
 3371 1cd8 A0169FE5 		ldr	r1, .L302+28
 3372 1cdc 0820A0E1 		mov	r2, r8
 3373 1ce0 0630A0E1 		mov	r3, r6
 3374 1ce4 00C08DE5 		str	ip, [sp, #0]
 3375 1ce8 FEFFFFEB 		bl	CyU3PDebugPrint
1090:../uvc.c      **** 					  break;
 3376              		.loc 1 1090 0
 3377 1cec FFC0A0E3 		mov	ip, #255
 3378 1cf0 63FFFFEA 		b	.L228
 3379              	.LVL284:
 3380              	.L240:
1055:../uvc.c      **** 					  if((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 8))//Iris
 3381              		.loc 1 1055 0
 3382 1cf4 B584D8E5 		ldrb	r8, [r8, #1205]	@ zero_extendqisi2
 3383 1cf8 010058E3 		cmp	r8, #1
 3384 1cfc 08005813 		cmpne	r8, #8
 3385 1d00 0000A013 		movne	r0, #0
 3386 1d04 0100A003 		moveq	r0, #1
 3387 1d08 8001001A 		bne	.L291
 3388              	.LVL285:
1058:../uvc.c      **** 							 CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3389              		.loc 1 1058 0
 3390 1d0c 68869FE5 		ldr	r8, .L302+24
 3391 1d10 0010E0E3 		mvn	r1, #0
 3392 1d14 1C0098E5 		ldr	r0, [r8, #28]
 3393 1d18 2C308DE5 		str	r3, [sp, #44]
 3394 1d1c FEFFFFEB 		bl	_txe_mutex_get
1059:../uvc.c      **** 							 cmdSet(cmdQuptr, 22, RegAdd0, devAdd, Data0, dataIdx);  //First
 3395              		.loc 1 1059 0
 3396 1d20 30A09DE5 		ldr	sl, [sp, #48]
 3397 1d24 1610A0E3 		mov	r1, #22
 3398 1d28 0B20A0E1 		mov	r2, fp
 3399 1d2c 2C309DE5 		ldr	r3, [sp, #44]
 3400 1d30 00C0A0E3 		mov	ip, #0
 3401 1d34 0800A0E1 		mov	r0, r8
 3402 1d38 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 3403 1d3c FEFFFFEB 		bl	cmdSet
1060:../uvc.c      **** 							 CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3404              		.loc 1 1060 0
 3405 1d40 1C0098E5 		ldr	r0, [r8, #28]
 3406 1d44 FEFFFFEB 		bl	_txe_mutex_put
1063:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3407              		.loc 1 1063 0
 3408 1d48 18069FE5 		ldr	r0, .L302+4
1064:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3409              		.loc 1 1064 0
 3410 1d4c 34209DE5 		ldr	r2, [sp, #52]
1063:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3411              		.loc 1 1063 0
 3412 1d50 061089E0 		add	r1, r9, r6
 3413 1d54 813180E0 		add	r3, r0, r1, asl #3
1065:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3414              		.loc 1 1065 0
 3415 1d58 0160A0E3 		mov	r6, #1
1063:../uvc.c      **** 							 CTCtrlParArry[CtrlID][13] = Data0;
 3416              		.loc 1 1063 0
 3417 1d5c 9DA4C3E5 		strb	sl, [r3, #1181]
1064:../uvc.c      **** 							 CTCtrlParArry[CtrlID][14] = Data1;
 3418              		.loc 1 1064 0
 3419 1d60 9E24C3E5 		strb	r2, [r3, #1182]
1065:../uvc.c      **** 							 CTCtrlParArry[CtrlID][16] = CyTrue;
 3420              		.loc 1 1065 0
 3421 1d64 A064C3E5 		strb	r6, [r3, #1184]
 3422              	.LVL286:
 3423              	.L292:
1067:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3424              		.loc 1 1067 0
 3425 1d68 5880D4E5 		ldrb	r8, [r4, #88]	@ zero_extendqisi2
 3426 1d6c 5960D4E5 		ldrb	r6, [r4, #89]	@ zero_extendqisi2
1072:../uvc.c      **** 					  break;
 3427              		.loc 1 1072 0
 3428 1d70 FFC0A0E3 		mov	ip, #255
 3429 1d74 42FFFFEA 		b	.L228
 3430              	.LVL287:
 3431              	.L239:
1021:../uvc.c      **** 					  if(((CTCtrlParArry[AutoExMCtlID1][13] == 1) || (CTCtrlParArry[AutoExMCtlID1][13] == 4))
 3432              		.loc 1 1021 0
 3433 1d78 B504D8E5 		ldrb	r0, [r8, #1205]	@ zero_extendqisi2
 3434 1d7c 010050E3 		cmp	r0, #1
 3435 1d80 04005013 		cmpne	r0, #4
 3436 1d84 5C01001A 		bne	.L249
1020:../uvc.c      **** 					  value = (value << 8)|Data0;
 3437              		.loc 1 1020 0
 3438 1d88 30109DE5 		ldr	r1, [sp, #48]
 3439 1d8c 34E09DE5 		ldr	lr, [sp, #52]
 3440 1d90 0E2481E1 		orr	r2, r1, lr, asl #8
1022:../uvc.c      **** 							  && (value < (EXLIMIT+50)))//shutter set accepted
 3441              		.loc 1 1022 0
 3442 1d94 F90052E3 		cmp	r2, #249
 3443 1d98 5701008A 		bhi	.L249
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3444              		.loc 1 1027 0
 3445 1d9c C8A042E2 		sub	sl, r2, #200
 3446 1da0 0AC8A0E1 		mov	ip, sl, asl #16
 3447 1da4 3CC08DE5 		str	ip, [sp, #60]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3448              		.loc 1 1029 0
 3449 1da8 27A062E2 		rsb	sl, r2, #39
 3450 1dac 38A08DE5 		str	sl, [sp, #56]
 3451 1db0 3CA09DE5 		ldr	sl, [sp, #60]
 3452 1db4 C81062E2 		rsb	r1, r2, #200
 3453 1db8 C80052E3 		cmp	r2, #200
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3454              		.loc 1 1027 0
 3455 1dbc 640042E2 		sub	r0, r2, #100
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3456              		.loc 1 1029 0
 3457 1dc0 0118A0E1 		mov	r1, r1, asl #16
 3458 1dc4 64E062E2 		rsb	lr, r2, #100
 3459 1dc8 2A18A081 		movhi	r1, sl, lsr #16
 3460 1dcc 2118A091 		movls	r1, r1, lsr #16
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3461              		.loc 1 1027 0
 3462 1dd0 00C8A0E1 		mov	ip, r0, asl #16
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3463              		.loc 1 1029 0
 3464 1dd4 640052E3 		cmp	r2, #100
 3465 1dd8 0E08A0E1 		mov	r0, lr, asl #16
 3466 1ddc 2C08A081 		movhi	r0, ip, lsr #16
 3467 1de0 38C09DE5 		ldr	ip, [sp, #56]
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3468              		.loc 1 1027 0
 3469 1de4 14A042E2 		sub	sl, r2, #20
 3470 1de8 38A08DE5 		str	sl, [sp, #56]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3471              		.loc 1 1029 0
 3472 1dec 2008A091 		movls	r0, r0, lsr #16
 3473 1df0 14A062E2 		rsb	sl, r2, #20
 3474 1df4 3CA08DE5 		str	sl, [sp, #60]
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3475              		.loc 1 1027 0
 3476 1df8 27E042E2 		sub	lr, r2, #39
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3477              		.loc 1 1029 0
 3478 1dfc 000051E1 		cmp	r1, r0
 3479 1e00 01A0A031 		movcc	sl, r1
 3480 1e04 00A0A021 		movcs	sl, r0
 3481 1e08 0CC8A0E1 		mov	ip, ip, asl #16
 3482 1e0c 270052E3 		cmp	r2, #39
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3483              		.loc 1 1027 0
 3484 1e10 0EE8A0E1 		mov	lr, lr, asl #16
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3485              		.loc 1 1029 0
 3486 1e14 2CE8A091 		movls	lr, ip, lsr #16
 3487 1e18 64C59FE5 		ldr	ip, .L302+32
 3488 1e1c 20A08DE5 		str	sl, [sp, #32]
 3489 1e20 01A06CE0 		rsb	sl, ip, r1
 3490 1e24 2EE8A081 		movhi	lr, lr, lsr #16
 3491 1e28 00C07AE2 		rsbs	ip, sl, #0
 3492 1e2c 0AC0ACE0 		adc	ip, ip, sl
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3493              		.loc 1 1027 0
 3494 1e30 38A09DE5 		ldr	sl, [sp, #56]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3495              		.loc 1 1029 0
 3496 1e34 44C08DE5 		str	ip, [sp, #68]
 3497              	.LVL288:
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3498              		.loc 1 1027 0
 3499 1e38 0AC8A0E1 		mov	ip, sl, asl #16
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3500              		.loc 1 1029 0
 3501 1e3c 3CA09DE5 		ldr	sl, [sp, #60]
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3502              		.loc 1 1027 0
 3503 1e40 4CC08DE5 		str	ip, [sp, #76]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3504              		.loc 1 1029 0
 3505 1e44 0AC8A0E1 		mov	ip, sl, asl #16
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3506              		.loc 1 1027 0
 3507 1e48 0AA042E2 		sub	sl, r2, #10
 3508 1e4c 48A08DE5 		str	sl, [sp, #72]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3509              		.loc 1 1029 0
 3510 1e50 20A09DE5 		ldr	sl, [sp, #32]
 3511 1e54 3CC08DE5 		str	ip, [sp, #60]
 3512 1e58 0A005EE1 		cmp	lr, sl
 3513 1e5c 0EA0A031 		movcc	sl, lr
 3514 1e60 0AC062E2 		rsb	ip, r2, #10
 3515 1e64 40C08DE5 		str	ip, [sp, #64]
 3516 1e68 38A08DE5 		str	sl, [sp, #56]
 3517 1e6c 3CC09DE5 		ldr	ip, [sp, #60]
 3518 1e70 4CA09DE5 		ldr	sl, [sp, #76]
 3519 1e74 140052E3 		cmp	r2, #20
 3520 1e78 2CA8A091 		movls	sl, ip, lsr #16
 3521 1e7c 2AA8A081 		movhi	sl, sl, lsr #16
 3522 1e80 44C09DE5 		ldr	ip, [sp, #68]
 3523 1e84 010050E1 		cmp	r0, r1
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3524              		.loc 1 1027 0
 3525 1e88 48109DE5 		ldr	r1, [sp, #72]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3526              		.loc 1 1029 0
 3527 1e8c 01C0A033 		movcc	ip, #1
 3528 1e90 3CA08DE5 		str	sl, [sp, #60]
 3529 1e94 24C08DE5 		str	ip, [sp, #36]
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3530              		.loc 1 1027 0
 3531 1e98 01A8A0E1 		mov	sl, r1, asl #16
 3532 1e9c 05C042E2 		sub	ip, r2, #5
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3533              		.loc 1 1029 0
 3534 1ea0 051062E2 		rsb	r1, r2, #5
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3535              		.loc 1 1027 0
 3536 1ea4 48A08DE5 		str	sl, [sp, #72]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3537              		.loc 1 1029 0
 3538 1ea8 40009DE5 		ldr	r0, [sp, #64]
 3539 1eac 38A09DE5 		ldr	sl, [sp, #56]
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3540              		.loc 1 1027 0
 3541 1eb0 40C08DE5 		str	ip, [sp, #64]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3542              		.loc 1 1029 0
 3543 1eb4 3CC09DE5 		ldr	ip, [sp, #60]
 3544 1eb8 4C108DE5 		str	r1, [sp, #76]
 3545 1ebc 48109DE5 		ldr	r1, [sp, #72]
 3546 1ec0 0008A0E1 		mov	r0, r0, asl #16
 3547 1ec4 0A005CE1 		cmp	ip, sl
 3548 1ec8 0AC0A021 		movcs	ip, sl
 3549 1ecc 0A0052E3 		cmp	r2, #10
 3550 1ed0 20A09DE5 		ldr	sl, [sp, #32]
 3551 1ed4 2108A081 		movhi	r0, r1, lsr #16
 3552 1ed8 2008A091 		movls	r0, r0, lsr #16
 3553 1edc 48008DE5 		str	r0, [sp, #72]
 3554 1ee0 24009DE5 		ldr	r0, [sp, #36]
 3555 1ee4 0A005EE1 		cmp	lr, sl
 3556 1ee8 0200A033 		movcc	r0, #2
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3557              		.loc 1 1027 0
 3558 1eec 02E042E2 		sub	lr, r2, #2
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3559              		.loc 1 1029 0
 3560 1ef0 44C08DE5 		str	ip, [sp, #68]
 3561 1ef4 24008DE5 		str	r0, [sp, #36]
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3562              		.loc 1 1027 0
 3563 1ef8 40C09DE5 		ldr	ip, [sp, #64]
 3564 1efc 1CE08DE5 		str	lr, [sp, #28]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3565              		.loc 1 1029 0
 3566 1f00 44009DE5 		ldr	r0, [sp, #68]
 3567 1f04 48E09DE5 		ldr	lr, [sp, #72]
 3568 1f08 4C109DE5 		ldr	r1, [sp, #76]
 3569 1f0c 02A062E2 		rsb	sl, r2, #2
 3570 1f10 00005EE1 		cmp	lr, r0
 3571 1f14 00E0A021 		movcs	lr, r0
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3572              		.loc 1 1027 0
 3573 1f18 0CC8A0E1 		mov	ip, ip, asl #16
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3574              		.loc 1 1029 0
 3575 1f1c 050052E3 		cmp	r2, #5
 3576 1f20 40A08DE5 		str	sl, [sp, #64]
 3577 1f24 0118A0E1 		mov	r1, r1, asl #16
 3578 1f28 3CA09DE5 		ldr	sl, [sp, #60]
 3579 1f2c 2C18A081 		movhi	r1, ip, lsr #16
 3580 1f30 38C09DE5 		ldr	ip, [sp, #56]
 3581 1f34 4CE08DE5 		str	lr, [sp, #76]
 3582 1f38 24009DE5 		ldr	r0, [sp, #36]
 3583 1f3c 40E09DE5 		ldr	lr, [sp, #64]
 3584 1f40 2118A091 		movls	r1, r1, lsr #16
 3585 1f44 0C005AE1 		cmp	sl, ip
 3586 1f48 20108DE5 		str	r1, [sp, #32]
 3587 1f4c 0300A033 		movcc	r0, #3
 3588 1f50 38008DE5 		str	r0, [sp, #56]
 3589 1f54 4CA09DE5 		ldr	sl, [sp, #76]
 3590 1f58 0E08A0E1 		mov	r0, lr, asl #16
 3591 1f5c 20E09DE5 		ldr	lr, [sp, #32]
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3592              		.loc 1 1027 0
 3593 1f60 1C109DE5 		ldr	r1, [sp, #28]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3594              		.loc 1 1029 0
 3595 1f64 0A005EE1 		cmp	lr, sl
 3596 1f68 0AE0A021 		movcs	lr, sl
 3597 1f6c 44C09DE5 		ldr	ip, [sp, #68]
 3598 1f70 48A09DE5 		ldr	sl, [sp, #72]
 3599 1f74 020052E3 		cmp	r2, #2
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3600              		.loc 1 1027 0
 3601 1f78 0118A0E1 		mov	r1, r1, asl #16
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3602              		.loc 1 1029 0
 3603 1f7c 2018A091 		movls	r1, r0, lsr #16
 3604 1f80 38009DE5 		ldr	r0, [sp, #56]
 3605 1f84 2118A081 		movhi	r1, r1, lsr #16
 3606 1f88 0C005AE1 		cmp	sl, ip
 3607 1f8c 0400A033 		movcc	r0, #4
 3608 1f90 40008DE5 		str	r0, [sp, #64]
1027:../uvc.c      **** 								diffRd = value-ShutValueArry[i];
 3609              		.loc 1 1027 0
 3610 1f94 010042E2 		sub	r0, r2, #1
 3611 1f98 38008DE5 		str	r0, [sp, #56]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3612              		.loc 1 1029 0
 3613 1f9c 4CA09DE5 		ldr	sl, [sp, #76]
 3614 1fa0 20009DE5 		ldr	r0, [sp, #32]
 3615 1fa4 01C062E2 		rsb	ip, r2, #1
 3616 1fa8 3CC08DE5 		str	ip, [sp, #60]
 3617 1fac 0A0050E1 		cmp	r0, sl
1036:../uvc.c      **** 						  shutter = shutter+index;
 3618              		.loc 1 1036 0
 3619 1fb0 38A09DE5 		ldr	sl, [sp, #56]
 3620 1fb4 3C009DE5 		ldr	r0, [sp, #60]
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3621              		.loc 1 1029 0
 3622 1fb8 40C09DE5 		ldr	ip, [sp, #64]
 3623 1fbc 05C0A033 		movcc	ip, #5
1036:../uvc.c      **** 						  shutter = shutter+index;
 3624              		.loc 1 1036 0
 3625 1fc0 010052E3 		cmp	r2, #1
 3626 1fc4 0028A091 		movls	r2, r0, asl #16
 3627 1fc8 0A28A081 		movhi	r2, sl, asl #16
 3628 1fcc 0E0051E1 		cmp	r1, lr
 3629 1fd0 01A0A031 		movcc	sl, r1
 3630 1fd4 0EA0A021 		movcs	sl, lr
1029:../uvc.c      **** 								diffRd = ShutValueArry[i]-value;
 3631              		.loc 1 1029 0
 3632 1fd8 0E0051E1 		cmp	r1, lr
 3633 1fdc 0C10A021 		movcs	r1, ip
 3634 1fe0 0610A033 		movcc	r1, #6
1036:../uvc.c      **** 						  shutter = shutter+index;
 3635              		.loc 1 1036 0
 3636 1fe4 22085AE1 		cmp	sl, r2, lsr #16
1039:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3637              		.loc 1 1039 0
 3638 1fe8 8CA39FE5 		ldr	sl, .L302+24
1036:../uvc.c      **** 						  shutter = shutter+index;
 3639              		.loc 1 1036 0
 3640 1fec 0120A091 		movls	r2, r1
 3641 1ff0 0720A083 		movhi	r2, #7
 3642 1ff4 012082E2 		add	r2, r2, #1
 3643 1ff8 FFE002E2 		and	lr, r2, #255
1039:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3644              		.loc 1 1039 0
 3645 1ffc 0010E0E3 		mvn	r1, #0
 3646 2000 1C009AE5 		ldr	r0, [sl, #28]
1036:../uvc.c      **** 						  shutter = shutter+index;
 3647              		.loc 1 1036 0
 3648 2004 38E08DE5 		str	lr, [sp, #56]
 3649              	.LVL289:
1039:../uvc.c      **** 						  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3650              		.loc 1 1039 0
 3651 2008 2C308DE5 		str	r3, [sp, #44]
 3652 200c FEFFFFEB 		bl	_txe_mutex_get
1040:../uvc.c      **** 						  cmdSet(cmdQuptr, CtrlID, RegAdd0, devAdd, shutter, dataIdx);  //First
 3653              		.loc 1 1040 0
 3654 2010 38C09DE5 		ldr	ip, [sp, #56]
 3655 2014 0310A0E3 		mov	r1, #3
 3656 2018 0B20A0E1 		mov	r2, fp
 3657 201c 2C309DE5 		ldr	r3, [sp, #44]
 3658 2020 00C08DE5 		str	ip, [sp, #0]
 3659 2024 0A00A0E1 		mov	r0, sl
 3660 2028 00C0A0E3 		mov	ip, #0
 3661 202c 04C08DE5 		str	ip, [sp, #4]
 3662 2030 FEFFFFEB 		bl	cmdSet
1041:../uvc.c      **** 						  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3663              		.loc 1 1041 0
 3664 2034 1C009AE5 		ldr	r0, [sl, #28]
 3665 2038 FEFFFFEB 		bl	_txe_mutex_put
1044:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3666              		.loc 1 1044 0
 3667 203c 30009DE5 		ldr	r0, [sp, #48]
1045:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3668              		.loc 1 1045 0
 3669 2040 34C09DE5 		ldr	ip, [sp, #52]
1047:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3670              		.loc 1 1047 0
 3671 2044 38309DE5 		ldr	r3, [sp, #56]
1044:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3672              		.loc 1 1044 0
 3673 2048 061089E0 		add	r1, r9, r6
 3674 204c 816188E0 		add	r6, r8, r1, asl #3
1046:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3675              		.loc 1 1046 0
 3676 2050 0120A0E3 		mov	r2, #1
1044:../uvc.c      **** 						  CTCtrlParArry[CtrlID][13] = Data0;
 3677              		.loc 1 1044 0
 3678 2054 9D04C6E5 		strb	r0, [r6, #1181]
1045:../uvc.c      **** 						  CTCtrlParArry[CtrlID][14] = Data1;
 3679              		.loc 1 1045 0
 3680 2058 9EC4C6E5 		strb	ip, [r6, #1182]
1046:../uvc.c      **** 						  CTCtrlParArry[CtrlID][16] = CyTrue;
 3681              		.loc 1 1046 0
 3682 205c A024C6E5 		strb	r2, [r6, #1184]
1047:../uvc.c      **** 						  CtrlParArry[ExtShutCtlID0][13] = shutter; //set extension shutter current value
 3683              		.loc 1 1047 0
 3684 2060 0D33C8E5 		strb	r3, [r8, #781]
 3685 2064 3FFFFFEA 		b	.L292
 3686              	.LVL290:
 3687              	.L238:
 974:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3688              		.loc 1 974 0
 3689 2068 062089E0 		add	r2, r9, r6
 3690 206c 826188E0 		add	r6, r8, r2, asl #3
 975:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3691              		.loc 1 975 0
 3692 2070 0110A0E3 		mov	r1, #1
 978:../uvc.c      **** 		  		    switch (getData){
 3693              		.loc 1 978 0
 3694 2074 01E040E2 		sub	lr, r0, #1
 974:../uvc.c      **** 				    CTCtrlParArry[CtrlID][13] = Data0;
 3695              		.loc 1 974 0
 3696 2078 9D04C6E5 		strb	r0, [r6, #1181]
 975:../uvc.c      **** 				    CTCtrlParArry[CtrlID][16] = CyTrue;
 3697              		.loc 1 975 0
 3698 207c A014C6E5 		strb	r1, [r6, #1184]
 3699              	.LVL291:
 978:../uvc.c      **** 		  		    switch (getData){
 3700              		.loc 1 978 0
 3701 2080 07005EE3 		cmp	lr, #7
 3702 2084 0EF19F97 		ldrls	pc, [pc, lr, asl #2]
 3703 2088 970000EA 		b	.L243
 3704              	.L248:
 3705 208c 80220000 		.word	.L244
 3706 2090 E4210000 		.word	.L245
 3707 2094 EC220000 		.word	.L243
 3708 2098 80210000 		.word	.L246
 3709 209c EC220000 		.word	.L243
 3710 20a0 EC220000 		.word	.L243
 3711 20a4 EC220000 		.word	.L243
 3712 20a8 E0200000 		.word	.L247
 3713              	.LVL292:
 3714              	.L237:
1094:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3715              		.loc 1 1094 0
 3716 20ac 0030DAE5 		ldrb	r3, [sl, #0]	@ zero_extendqisi2
1093:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3717              		.loc 1 1093 0
 3718 20b0 30A09DE5 		ldr	sl, [sp, #48]
 3719 20b4 069089E0 		add	r9, r9, r6
 3720 20b8 89E188E0 		add	lr, r8, r9, asl #3
1094:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3721              		.loc 1 1094 0
 3722 20bc 0620A0E1 		mov	r2, r6
 3723 20c0 0400A0E3 		mov	r0, #4
 3724 20c4 BC129FE5 		ldr	r1, .L302+36
1093:../uvc.c      **** 					 CTCtrlParArry[CtrlID][13] = glEp0Buffer[0];
 3725              		.loc 1 1093 0
 3726 20c8 9DA4CEE5 		strb	sl, [lr, #1181]
1094:../uvc.c      **** 					 CyU3PDebugPrint (4, "default selector (CT) 0x%x 0x%x\r\n", CtrlID, bRequest); // additional d
 3727              		.loc 1 1094 0
 3728 20cc FEFFFFEB 		bl	CyU3PDebugPrint
1095:../uvc.c      **** 			  		 break;
 3729              		.loc 1 1095 0
 3730 20d0 FFC0A0E3 		mov	ip, #255
 3731 20d4 0C60A0E1 		mov	r6, ip
 3732 20d8 0C80A0E1 		mov	r8, ip
 3733 20dc 68FEFFEA 		b	.L228
 3734              	.LVL293:
 3735              	.L247:
 997:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3736              		.loc 1 997 0
 3737 20e0 94629FE5 		ldr	r6, .L302+24
 995:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3738              		.loc 1 995 0
 3739 20e4 00A0A0E3 		mov	sl, #0
 997:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3740              		.loc 1 997 0
 3741 20e8 1C0096E5 		ldr	r0, [r6, #28]
 995:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3742              		.loc 1 995 0
 3743 20ec 0DA3C8E5 		strb	sl, [r8, #781]
 3744              	.LVL294:
 997:../uvc.c      **** 			  		    	CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3745              		.loc 1 997 0
 3746 20f0 0010E0E3 		mvn	r1, #0
 3747 20f4 2C308DE5 		str	r3, [sp, #44]
 3748 20f8 FEFFFFEB 		bl	_txe_mutex_get
 998:../uvc.c      **** 			  		    	cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3749              		.loc 1 998 0
 3750 20fc 0B20A0E1 		mov	r2, fp
 3751 2100 2C309DE5 		ldr	r3, [sp, #44]
 3752 2104 1010A0E3 		mov	r1, #16
 3753 2108 0600A0E1 		mov	r0, r6
 3754 210c 00A08DE5 		str	sl, [sp, #0]
 3755 2110 04A08DE5 		str	sl, [sp, #4]
 3756 2114 FEFFFFEB 		bl	cmdSet
 999:../uvc.c      **** 			  		    	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3757              		.loc 1 999 0
 3758 2118 1C0096E5 		ldr	r0, [r6, #28]
 3759 211c FEFFFFEB 		bl	_txe_mutex_put
 3760              	.LVL295:
 3761              	.LBB68:
 3762              	.LBB69:
 369:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3763              		.loc 1 369 0
 3764 2120 0010E0E3 		mvn	r1, #0
 3765 2124 1C0096E5 		ldr	r0, [r6, #28]
 3766 2128 FEFFFFEB 		bl	_txe_mutex_get
 370:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3767              		.loc 1 370 0
 3768 212c 0180A0E3 		mov	r8, #1
 3769 2130 1410A0E3 		mov	r1, #20
 3770 2134 2720A0E3 		mov	r2, #39
 3771 2138 3030A0E3 		mov	r3, #48
 3772 213c 0600A0E1 		mov	r0, r6
 3773 2140 00058DE8 		stmia	sp, {r8, sl}	@ phole stm
 3774 2144 FEFFFFEB 		bl	cmdSet
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3775              		.loc 1 371 0
 3776 2148 02C0A0E3 		mov	ip, #2
 3777 214c 1510A0E3 		mov	r1, #21
 3778 2150 2520A0E3 		mov	r2, #37
 3779 2154 3030A0E3 		mov	r3, #48
 3780 2158 0600A0E1 		mov	r0, r6
 3781 215c 00C08DE5 		str	ip, [sp, #0]
 3782 2160 04A08DE5 		str	sl, [sp, #4]
 3783 2164 FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3784              		.loc 1 372 0
 3785 2168 1C0096E5 		ldr	r0, [r6, #28]
 3786 216c FEFFFFEB 		bl	_txe_mutex_put
 3787              	.LBE69:
 3788              	.LBE68:
1001:../uvc.c      **** 							break;
 3789              		.loc 1 1001 0
 3790 2170 FFC0A0E3 		mov	ip, #255
 3791 2174 0C60A0E1 		mov	r6, ip
 3792 2178 0880A0E3 		mov	r8, #8
 3793 217c 40FEFFEA 		b	.L228
 3794              	.LVL296:
 3795              	.L246:
 3796              	.LBB70:
 3797              	.LBB71:
 369:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3798              		.loc 1 369 0
 3799 2180 F4819FE5 		ldr	r8, .L302+24
 3800 2184 0010E0E3 		mvn	r1, #0
 3801 2188 1C0098E5 		ldr	r0, [r8, #28]
 3802 218c FEFFFFEB 		bl	_txe_mutex_get
 370:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3803              		.loc 1 370 0
 3804 2190 0060A0E3 		mov	r6, #0
 3805 2194 1410A0E3 		mov	r1, #20
 3806 2198 2720A0E3 		mov	r2, #39
 3807 219c 3030A0E3 		mov	r3, #48
 3808 21a0 0800A0E1 		mov	r0, r8
 3809 21a4 00608DE5 		str	r6, [sp, #0]
 3810 21a8 04608DE5 		str	r6, [sp, #4]
 3811 21ac FEFFFFEB 		bl	cmdSet
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3812              		.loc 1 371 0
 3813 21b0 1510A0E3 		mov	r1, #21
 3814 21b4 2520A0E3 		mov	r2, #37
 3815 21b8 3030A0E3 		mov	r3, #48
 3816 21bc 0800A0E1 		mov	r0, r8
 3817 21c0 00608DE5 		str	r6, [sp, #0]
 3818 21c4 04608DE5 		str	r6, [sp, #4]
 3819 21c8 FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3820              		.loc 1 372 0
 3821 21cc 1C0098E5 		ldr	r0, [r8, #28]
 3822 21d0 FEFFFFEB 		bl	_txe_mutex_put
 3823 21d4 FFC0A0E3 		mov	ip, #255
 3824 21d8 0C60A0E1 		mov	r6, ip
 3825 21dc 0480A0E3 		mov	r8, #4
 3826 21e0 27FEFFEA 		b	.L228
 3827              	.LVL297:
 3828              	.L245:
 3829              	.LBE71:
 3830              	.LBE70:
 985:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3831              		.loc 1 985 0
 3832 21e4 90A19FE5 		ldr	sl, .L302+24
 983:../uvc.c      **** 			  		    	CtrlParArry[ExtShutCtlID0][13] = 0; //set shutter is auto.
 3833              		.loc 1 983 0
 3834 21e8 0060A0E3 		mov	r6, #0
 3835 21ec 0D63C8E5 		strb	r6, [r8, #781]
 3836              	.LVL298:
 985:../uvc.c      **** 							CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3837              		.loc 1 985 0
 3838 21f0 0010E0E3 		mvn	r1, #0
 3839 21f4 1C009AE5 		ldr	r0, [sl, #28]
 3840 21f8 2C308DE5 		str	r3, [sp, #44]
 3841 21fc FEFFFFEB 		bl	_txe_mutex_get
 986:../uvc.c      **** 							cmdSet(cmdQuptr, ExtShutCtlID0, RegAdd0, devAdd, 0, dataIdx);  //set shutter value to 0
 3842              		.loc 1 986 0
 3843 2200 0B20A0E1 		mov	r2, fp
 3844 2204 2C309DE5 		ldr	r3, [sp, #44]
 3845 2208 1010A0E3 		mov	r1, #16
 3846 220c 0A00A0E1 		mov	r0, sl
 3847 2210 00608DE5 		str	r6, [sp, #0]
 3848 2214 04608DE5 		str	r6, [sp, #4]
 3849 2218 FEFFFFEB 		bl	cmdSet
 987:../uvc.c      **** 							CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3850              		.loc 1 987 0
 3851 221c 1C009AE5 		ldr	r0, [sl, #28]
 3852 2220 FEFFFFEB 		bl	_txe_mutex_put
 3853              	.LVL299:
 3854              	.LBB72:
 3855              	.LBB73:
 369:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3856              		.loc 1 369 0
 3857 2224 0010E0E3 		mvn	r1, #0
 3858 2228 1C009AE5 		ldr	r0, [sl, #28]
 3859 222c FEFFFFEB 		bl	_txe_mutex_get
 370:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3860              		.loc 1 370 0
 3861 2230 1410A0E3 		mov	r1, #20
 3862 2234 2720A0E3 		mov	r2, #39
 3863 2238 3030A0E3 		mov	r3, #48
 3864 223c 0A00A0E1 		mov	r0, sl
 3865 2240 00608DE5 		str	r6, [sp, #0]
 3866 2244 04608DE5 		str	r6, [sp, #4]
 3867 2248 FEFFFFEB 		bl	cmdSet
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3868              		.loc 1 371 0
 3869 224c 1510A0E3 		mov	r1, #21
 3870 2250 2520A0E3 		mov	r2, #37
 3871 2254 3030A0E3 		mov	r3, #48
 3872 2258 0A00A0E1 		mov	r0, sl
 3873 225c 00608DE5 		str	r6, [sp, #0]
 3874 2260 04608DE5 		str	r6, [sp, #4]
 3875 2264 FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3876              		.loc 1 372 0
 3877 2268 1C009AE5 		ldr	r0, [sl, #28]
 3878 226c FEFFFFEB 		bl	_txe_mutex_put
 3879 2270 FFC0A0E3 		mov	ip, #255
 3880 2274 0C60A0E1 		mov	r6, ip
 3881 2278 0280A0E3 		mov	r8, #2
 3882 227c 00FEFFEA 		b	.L228
 3883              	.LVL300:
 3884              	.L244:
 3885              	.LBE73:
 3886              	.LBE72:
 3887              	.LBB74:
 3888              	.LBB75:
 369:../uvc.c      **** 	  CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 3889              		.loc 1 369 0
 3890 2280 F4609FE5 		ldr	r6, .L302+24
 3891 2284 0010E0E3 		mvn	r1, #0
 3892 2288 1C0096E5 		ldr	r0, [r6, #28]
 3893 228c FEFFFFEB 		bl	_txe_mutex_get
 370:../uvc.c      **** 	  cmdSet(cmdQuptr, 20/*AFIrisMode*/, 0x27, 0x30, isAuto?0:1, dataIdx);  //set Iris Mode for AF Len
 3894              		.loc 1 370 0
 3895 2290 0080A0E3 		mov	r8, #0
 3896 2294 01A0A0E3 		mov	sl, #1
 3897 2298 1410A0E3 		mov	r1, #20
 3898 229c 2720A0E3 		mov	r2, #39
 3899 22a0 3030A0E3 		mov	r3, #48
 3900 22a4 0600A0E1 		mov	r0, r6
 3901 22a8 04808DE5 		str	r8, [sp, #4]
 3902 22ac 00A08DE5 		str	sl, [sp, #0]
 3903 22b0 FEFFFFEB 		bl	cmdSet
 371:../uvc.c      **** 	  cmdSet(cmdQuptr, 21/*noAFIrisMode*/, 0x25, 0x30, isAuto?0:2, dataIdx);  //set Iris Mode value fo
 3904              		.loc 1 371 0
 3905 22b4 02C0A0E3 		mov	ip, #2
 3906 22b8 1510A0E3 		mov	r1, #21
 3907 22bc 2520A0E3 		mov	r2, #37
 3908 22c0 3030A0E3 		mov	r3, #48
 3909 22c4 0600A0E1 		mov	r0, r6
 3910 22c8 00C08DE5 		str	ip, [sp, #0]
 3911 22cc 04808DE5 		str	r8, [sp, #4]
 3912 22d0 FEFFFFEB 		bl	cmdSet
 372:../uvc.c      **** 	  CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 3913              		.loc 1 372 0
 3914 22d4 1C0096E5 		ldr	r0, [r6, #28]
 3915 22d8 FEFFFFEB 		bl	_txe_mutex_put
 3916              	.LBE75:
 3917              	.LBE74:
 981:../uvc.c      **** 							break;
 3918              		.loc 1 981 0
 3919 22dc FFC0A0E3 		mov	ip, #255
 3920 22e0 0C60A0E1 		mov	r6, ip
 3921 22e4 0A80A0E1 		mov	r8, sl
 3922 22e8 E5FDFFEA 		b	.L228
 3923              	.LVL301:
 3924              	.L243:
 978:../uvc.c      **** 		  		    switch (getData){
 3925              		.loc 1 978 0
 3926 22ec FFC0A0E3 		mov	ip, #255
 3927 22f0 0080A0E1 		mov	r8, r0
 3928 22f4 0C60A0E1 		mov	r6, ip
 3929 22f8 E1FDFFEA 		b	.L228
 3930              	.LVL302:
 3931              	.L249:
1049:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3932              		.loc 1 1049 0
 3933 22fc 0000A0E3 		mov	r0, #0
 3934 2300 0110A0E3 		mov	r1, #1
 3935 2304 0020A0E1 		mov	r2, r0
 3936 2308 FEFFFFEB 		bl	CyU3PUsbStall
 3937              	.LVL303:
 3938 230c 95FEFFEA 		b	.L292
 3939              	.LVL304:
 3940              	.L291:
1067:../uvc.c      **** 						  CyU3PUsbStall (0, CyTrue, CyFalse);
 3941              		.loc 1 1067 0
 3942 2310 0110A0E3 		mov	r1, #1
 3943 2314 0020A0E1 		mov	r2, r0
 3944 2318 FEFFFFEB 		bl	CyU3PUsbStall
 3945 231c 91FEFFEA 		b	.L292
 3946              	.LVL305:
 3947              	.L301:
1082:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, WIDEDATA, dataIdx);  //wide-angle direction
 3948              		.loc 1 1082 0
 3949 2320 08E0A0E3 		mov	lr, #8
 3950 2324 00C0A0E3 		mov	ip, #0
 3951 2328 0600A0E1 		mov	r0, r6
 3952 232c 1710A0E3 		mov	r1, #23
 3953 2330 0B20A0E1 		mov	r2, fp
 3954 2334 00E08DE5 		str	lr, [sp, #0]
 3955 2338 04C08DE5 		str	ip, [sp, #4]
 3956 233c FEFFFFEB 		bl	cmdSet
 3957 2340 5EFEFFEA 		b	.L294
 3958              	.L300:
1080:../uvc.c      **** 						  cmdSet(cmdQuptr, 23, RegAdd0, devAdd, TELEDATA, dataIdx);  //telephoto direction
 3959              		.loc 1 1080 0
 3960 2344 0480A0E3 		mov	r8, #4
 3961 2348 00E0A0E3 		mov	lr, #0
 3962 234c 0600A0E1 		mov	r0, r6
 3963 2350 1710A0E3 		mov	r1, #23
 3964 2354 0B20A0E1 		mov	r2, fp
 3965 2358 00418DE8 		stmia	sp, {r8, lr}	@ phole stm
 3966 235c FEFFFFEB 		bl	cmdSet
 3967 2360 56FEFFEA 		b	.L294
 3968              	.L303:
 3969              		.align	2
 3970              	.L302:
 3971 2364 00000000 		.word	bRequest
 3972 2368 00000000 		.word	.LANCHOR1
 3973 236c 00000000 		.word	.LANCHOR0
 3974 2370 DC030000 		.word	.LC23
 3975 2374 00040000 		.word	.LC24
 3976 2378 58000000 		.word	.LANCHOR0+88
 3977 237c 00000000 		.word	cmdQu
 3978 2380 90030000 		.word	.LC21
 3979 2384 FFFF0000 		.word	65535
 3980 2388 B8030000 		.word	.LC22
 3981              		.cfi_endproc
 3982              	.LFE3:
 3984              		.align	2
 3985              		.global	UVCAppEP0Thread_Entry
 3987              	UVCAppEP0Thread_Entry:
 3988              	.LFB24:
3060:../uvc.c      **** {
 3989              		.loc 1 3060 0
 3990              		.cfi_startproc
 3991              		@ args = 0, pretend = 0, frame = 32
 3992              		@ frame_needed = 0, uses_anonymous_args = 0
 3993              	.LVL306:
 3994 238c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 3995              	.LCFI17:
 3996              		.cfi_def_cfa_offset 36
 3997 2390 F0499FE5 		ldr	r4, .L453
 3998              		.cfi_offset 14, -4
 3999              		.cfi_offset 11, -8
 4000              		.cfi_offset 10, -12
 4001              		.cfi_offset 9, -16
 4002              		.cfi_offset 8, -20
 4003              		.cfi_offset 7, -24
 4004              		.cfi_offset 6, -28
 4005              		.cfi_offset 5, -32
 4006              		.cfi_offset 4, -36
 4007 2394 F0699FE5 		ldr	r6, .L453+4
 4008 2398 F0899FE5 		ldr	r8, .L453+8
 4009 239c F0999FE5 		ldr	r9, .L453+12
 4010 23a0 F0A99FE5 		ldr	sl, .L453+16
 4011 23a4 F0799FE5 		ldr	r7, .L453+20
 4012 23a8 3CD04DE2 		sub	sp, sp, #60
 4013              	.LCFI18:
 4014              		.cfi_def_cfa_offset 96
 4015              	.LVL307:
3082:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventFlag,
 4016              		.loc 1 3082 0
 4017 23ac 0450A0E1 		mov	r5, r4
 4018              	.LVL308:
 4019              	.L429:
 4020 23b0 00C0E0E3 		mvn	ip, #0
 4021 23b4 CC099FE5 		ldr	r0, .L453
 4022 23b8 4C10A0E3 		mov	r1, #76
 4023 23bc 0120A0E3 		mov	r2, #1
 4024 23c0 30308DE2 		add	r3, sp, #48
 4025 23c4 00C08DE5 		str	ip, [sp, #0]
 4026 23c8 FEFFFFEB 		bl	_txe_event_flags_get
 4027 23cc 000050E3 		cmp	r0, #0
 4028 23d0 3000001A 		bne	.L305
3086:../uvc.c      ****             if (!isUsbConnected)
 4029              		.loc 1 3086 0
 4030 23d4 3C3095E5 		ldr	r3, [r5, #60]
 4031 23d8 000053E3 		cmp	r3, #0
 4032 23dc 8900000A 		beq	.L443
 4033              	.L306:
3095:../uvc.c      ****             if((eventFlag & eventMask) & ~VD_FX_INT_STA_EVENT)
 4034              		.loc 1 3095 0
 4035 23e0 30309DE5 		ldr	r3, [sp, #48]
 4036 23e4 0C0013E3 		tst	r3, #12
 4037 23e8 7200001A 		bne	.L444
 4038              	.L307:
3102:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT)
 4039              		.loc 1 3102 0
 4040 23ec 040013E3 		tst	r3, #4
 4041 23f0 1C00000A 		beq	.L308
3104:../uvc.c      ****             	switch ((wIndex >> 8))
 4042              		.loc 1 3104 0
 4043 23f4 B0E0DAE1 		ldrh	lr, [sl, #0]
 4044 23f8 2E24A0E1 		mov	r2, lr, lsr #8
 4045 23fc 030052E3 		cmp	r2, #3
 4046 2400 02F19F97 		ldrls	pc, [pc, r2, asl #2]
 4047 2404 120000EA 		b	.L309
 4048              	.L314:
 4049 2408 54240000 		.word	.L309
 4050 240c 38250000 		.word	.L311
 4051 2410 18240000 		.word	.L312
 4052 2414 74250000 		.word	.L313
 4053              	.L312:
 4054              	.LBB90:
 4055              	.LBB92:
2391:../uvc.c      ****     switch (wValue)
 4056              		.loc 1 2391 0
 4057 2418 B020D9E1 		ldrh	r2, [r9, #0]
 4058 241c 060C52E3 		cmp	r2, #1536
 4059 2420 DA01000A 		beq	.L320
 4060 2424 CC00008A 		bhi	.L326
 4061 2428 030C52E3 		cmp	r2, #768
 4062 242c D301000A 		beq	.L318
 4063 2430 CA01008A 		bhi	.L327
 4064 2434 010C52E3 		cmp	r2, #256
 4065 2438 6901000A 		beq	.L316
 4066 243c 020C52E3 		cmp	r2, #512
 4067 2440 6301000A 		beq	.L445
 4068              	.L329:
 4069              	.LBE92:
 4070              	.LBE90:
 4071              	.LBB95:
 4072              	.LBB99:
2523:../uvc.c      ****         	CyU3PDebugPrint (4, "The default setup request value 0x%x 0x%x\r\n", wValue, bRequest); //
 4073              		.loc 1 2523 0
 4074 2444 54199FE5 		ldr	r1, .L453+24
 4075 2448 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4076 244c 0400A0E3 		mov	r0, #4
 4077 2450 FEFFFFEB 		bl	CyU3PDebugPrint
 4078              	.L309:
 4079              	.LBE99:
 4080              	.LBE95:
3125:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4081              		.loc 1 3125 0
 4082 2454 0000A0E3 		mov	r0, #0
 4083 2458 0110A0E3 		mov	r1, #1
 4084 245c 0020A0E1 		mov	r2, r0
 4085 2460 FEFFFFEB 		bl	CyU3PUsbStall
 4086 2464 30309DE5 		ldr	r3, [sp, #48]
 4087              	.L308:
3130:../uvc.c      ****             if (eventFlag & CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT)
 4088              		.loc 1 3130 0
 4089 2468 080013E3 		tst	r3, #8
 4090 246c 0700000A 		beq	.L371
3134:../uvc.c      ****                 if (wIndex != CY_FX_UVC_STREAM_INTERFACE)
 4091              		.loc 1 3134 0
 4092 2470 B030DAE1 		ldrh	r3, [sl, #0]
 4093 2474 010053E3 		cmp	r3, #1
 4094 2478 6800000A 		beq	.L372
 4095              	.L373:
 4096              	.LBB104:
 4097              	.LBB110:
3049:../uvc.c      ****             CyU3PUsbStall (0, CyTrue, CyFalse);
 4098              		.loc 1 3049 0
 4099 247c 0000A0E3 		mov	r0, #0
 4100 2480 0110A0E3 		mov	r1, #1
 4101 2484 0020A0E1 		mov	r2, r0
 4102 2488 FEFFFFEB 		bl	CyU3PUsbStall
 4103              	.L433:
 4104 248c 30309DE5 		ldr	r3, [sp, #48]
 4105              	.L371:
 4106              	.LBE110:
 4107              	.LBE104:
3145:../uvc.c      ****             if (eventFlag & VD_FX_INT_STA_EVENT)
 4108              		.loc 1 3145 0
 4109 2490 400013E3 		tst	r3, #64
 4110 2494 0100001A 		bne	.L446
 4111              	.L305:
3358:../uvc.c      ****         CyU3PThreadRelinquish ();
 4112              		.loc 1 3358 0
 4113 2498 FEFFFFEB 		bl	_txe_thread_relinquish
3359:../uvc.c      ****     }
 4114              		.loc 1 3359 0
 4115 249c C3FFFFEA 		b	.L429
 4116              	.L446:
3150:../uvc.c      ****             	CyU3PGpioSimpleGetValue (SENSOR_SNAPSHOT_GPIO, valueptr);// get button value 1:release
 4117              		.loc 1 3150 0
 4118 24a0 1800A0E3 		mov	r0, #24
 4119 24a4 2C108DE2 		add	r1, sp, #44
 4120 24a8 FEFFFFEB 		bl	CyU3PGpioSimpleGetValue
3155:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4121              		.loc 1 3155 0
 4122 24ac 2C209DE5 		ldr	r2, [sp, #44]
 4123 24b0 000052E3 		cmp	r2, #0
 4124 24b4 6D00000A 		beq	.L424
3155:../uvc.c      **** 				if(value&&(!snapButFlag)){
 4125              		.loc 1 3155 0 is_stmt 0 discriminator 1
 4126 24b8 5F36D6E5 		ldrb	r3, [r6, #1631]	@ zero_extendqisi2
 4127 24bc 000053E3 		cmp	r3, #0
 4128 24c0 F4FFFF1A 		bne	.L305
3157:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4129              		.loc 1 3157 0 is_stmt 1
 4130 24c4 002097E5 		ldr	r2, [r7, #0]
 4131 24c8 02B0A0E3 		mov	fp, #2
 4132 24cc 00B0C2E5 		strb	fp, [r2, #0]
3158:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4133              		.loc 1 3158 0
 4134 24d0 001097E5 		ldr	r1, [r7, #0]
 4135 24d4 01B0A0E3 		mov	fp, #1
 4136 24d8 01B0C1E5 		strb	fp, [r1, #1]
3159:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4137              		.loc 1 3159 0
 4138 24dc 000097E5 		ldr	r0, [r7, #0]
3163:../uvc.c      **** 					interStabuf.size   = 1024;
 4139              		.loc 1 3163 0
 4140 24e0 01EBA0E3 		mov	lr, #1024	@ movhi
3159:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4141              		.loc 1 3159 0
 4142 24e4 0230C0E5 		strb	r3, [r0, #2]
3160:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4143              		.loc 1 3160 0
 4144 24e8 00C097E5 		ldr	ip, [r7, #0]
3169:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4145              		.loc 1 3169 0
 4146 24ec 0010E0E3 		mvn	r1, #0
3160:../uvc.c      **** 					glInterStaBuffer[3] = 0x00; //button release
 4147              		.loc 1 3160 0
 4148 24f0 0330CCE5 		strb	r3, [ip, #3]
3162:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4149              		.loc 1 3162 0
 4150 24f4 002097E5 		ldr	r2, [r7, #0]
3166:../uvc.c      **** 					interStabuf.count = 4;
 4151              		.loc 1 3166 0
 4152 24f8 04C0A0E3 		mov	ip, #4	@ movhi
3169:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4153              		.loc 1 3169 0
 4154 24fc A0089FE5 		ldr	r0, .L453+28
3162:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4155              		.loc 1 3162 0
 4156 2500 20208DE5 		str	r2, [sp, #32]
3163:../uvc.c      **** 					interStabuf.size   = 1024;
 4157              		.loc 1 3163 0
 4158 2504 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3164:../uvc.c      **** 					interStabuf.status = 0;
 4159              		.loc 1 3164 0
 4160 2508 B832CDE1 		strh	r3, [sp, #40]	@ movhi
3166:../uvc.c      **** 					interStabuf.count = 4;
 4161              		.loc 1 3166 0
 4162 250c B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
3169:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4163              		.loc 1 3169 0
 4164 2510 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3172:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4165              		.loc 1 3172 0
 4166 2514 88089FE5 		ldr	r0, .L453+28
 4167 2518 20108DE2 		add	r1, sp, #32
 4168 251c FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4169              	.LVL309:
3173:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4170              		.loc 1 3173 0
 4171 2520 002050E2 		subs	r2, r0, #0
 4172 2524 6801001A 		bne	.L447
3178:../uvc.c      **** 					snapButFlag = 1;//snap button is masked.
 4173              		.loc 1 3178 0
 4174 2528 5C389FE5 		ldr	r3, .L453+4
 4175 252c 5FB6C3E5 		strb	fp, [r3, #1631]
3358:../uvc.c      ****         CyU3PThreadRelinquish ();
 4176              		.loc 1 3358 0
 4177 2530 FEFFFFEB 		bl	_txe_thread_relinquish
 4178              	.LVL310:
 4179 2534 9DFFFFEA 		b	.L429
 4180              	.L311:
 4181              	.LBB116:
 4182              	.LBB100:
2466:../uvc.c      ****     switch (wValue)
 4183              		.loc 1 2466 0
 4184 2538 B020D9E1 		ldrh	r2, [r9, #0]
 4185 253c 060C52E3 		cmp	r2, #1536
 4186 2540 D600000A 		beq	.L335
 4187 2544 8F00008A 		bhi	.L341
 4188 2548 030C52E3 		cmp	r2, #768
 4189 254c 1801000A 		beq	.L332
 4190 2550 0F01008A 		bhi	.L342
 4191 2554 010C52E3 		cmp	r2, #256
 4192 2558 5701000A 		beq	.L330
 4193 255c 020C52E3 		cmp	r2, #512
 4194 2560 B7FFFF1A 		bne	.L329
 4195              	.LVL311:
2474:../uvc.c      ****    			CTControlHandle(AutoExMCtlID1);
 4196              		.loc 1 2474 0
 4197 2564 0100A0E3 		mov	r0, #1
 4198 2568 FEFFFFEB 		bl	CTControlHandle
 4199              	.LVL312:
 4200 256c 30309DE5 		ldr	r3, [sp, #48]
 4201 2570 BCFFFFEA 		b	.L308
 4202              	.L313:
 4203              	.LBE100:
 4204              	.LBE116:
 4205              	.LBB117:
 4206              	.LBB122:
2691:../uvc.c      ****     switch (wValue)
 4207              		.loc 1 2691 0
 4208 2574 B020D9E1 		ldrh	r2, [r9, #0]
 4209 2578 090C52E3 		cmp	r2, #2304
 4210 257c F301000A 		beq	.L356
 4211 2580 8800008A 		bhi	.L365
 4212 2584 010B52E3 		cmp	r2, #1024
 4213 2588 F401000A 		beq	.L351
 4214 258c 8801008A 		bhi	.L366
 4215 2590 020C52E3 		cmp	r2, #512
 4216 2594 E901000A 		beq	.L349
 4217 2598 030C52E3 		cmp	r2, #768
 4218 259c C801000A 		beq	.L350
 4219 25a0 010C52E3 		cmp	r2, #256
 4220 25a4 AAFFFF1A 		bne	.L309
 4221              	.LVL313:
2695:../uvc.c      ****       		ControlHandle(ExtShutCtlID0);
 4222              		.loc 1 2695 0
 4223 25a8 1000A0E3 		mov	r0, #16
 4224 25ac FEFFFFEB 		bl	ControlHandle
 4225              	.LVL314:
 4226 25b0 30309DE5 		ldr	r3, [sp, #48]
 4227 25b4 ABFFFFEA 		b	.L308
 4228              	.L444:
 4229              	.LBE122:
 4230              	.LBE117:
3096:../uvc.c      ****             CyU3PDebugPrint (4, "USB speed = %d evenflag = 0x%x bmReqType = 0x%x\r\n"
 4231              		.loc 1 3096 0
 4232 25b8 E8B79FE5 		ldr	fp, .L453+32
 4233 25bc B0C0D9E1 		ldrh	ip, [r9, #0]
 4234 25c0 B000DAE1 		ldrh	r0, [sl, #0]
 4235 25c4 E0179FE5 		ldr	r1, .L453+36
 4236 25c8 00E0DBE5 		ldrb	lr, [fp, #0]	@ zero_extendqisi2
 4237 25cc 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4238 25d0 0C008DE5 		str	r0, [sp, #12]
 4239 25d4 08C08DE5 		str	ip, [sp, #8]
 4240 25d8 B0C0D1E1 		ldrh	ip, [r1, #0]
 4241 25dc 4820D4E5 		ldrb	r2, [r4, #72]	@ zero_extendqisi2
 4242 25e0 04B08DE5 		str	fp, [sp, #4]
 4243 25e4 0400A0E3 		mov	r0, #4
 4244 25e8 C0179FE5 		ldr	r1, .L453+40
 4245 25ec 00B0A0E3 		mov	fp, #0
 4246 25f0 00E08DE5 		str	lr, [sp, #0]
 4247 25f4 10C08DE5 		str	ip, [sp, #16]
 4248 25f8 14B08DE5 		str	fp, [sp, #20]
 4249 25fc FEFFFFEB 		bl	CyU3PDebugPrint
 4250 2600 30309DE5 		ldr	r3, [sp, #48]
 4251 2604 78FFFFEA 		b	.L307
 4252              	.L443:
3088:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4253              		.loc 1 3088 0
 4254 2608 FEFFFFEB 		bl	CyU3PUsbGetSpeed
3089:../uvc.c      ****                 if (usbSpeed != CY_U3P_NOT_CONNECTED)
 4255              		.loc 1 3089 0
 4256 260c 000050E3 		cmp	r0, #0
3088:../uvc.c      ****                 usbSpeed = CyU3PUsbGetSpeed ();
 4257              		.loc 1 3088 0
 4258 2610 4800C5E5 		strb	r0, [r5, #72]
3091:../uvc.c      ****                     isUsbConnected = CyTrue;
 4259              		.loc 1 3091 0
 4260 2614 0100A013 		movne	r0, #1
 4261 2618 3C008515 		strne	r0, [r5, #60]
 4262 261c 6FFFFFEA 		b	.L306
 4263              	.L372:
 4264              	.LVL315:
 4265              	.LBB127:
 4266              	.LBB109:
2786:../uvc.c      ****     switch (wValue)
 4267              		.loc 1 2786 0
 4268 2620 B020D9E1 		ldrh	r2, [r9, #0]
 4269 2624 030C52E3 		cmp	r2, #768
 4270 2628 8200000A 		beq	.L376
 4271 262c 3300008A 		bhi	.L379
 4272 2630 010C52E3 		cmp	r2, #256
 4273 2634 8C00000A 		beq	.L374
 4274 2638 020C52E3 		cmp	r2, #512
 4275 263c 8EFFFF1A 		bne	.L373
2838:../uvc.c      ****             switch (bRequest)
 4276              		.loc 1 2838 0
 4277 2640 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4278 2644 810053E3 		cmp	r3, #129
 4279 2648 8C00000A 		beq	.L418
 4280 264c 2701008A 		bhi	.L394
 4281 2650 010053E3 		cmp	r3, #1
 4282 2654 8901000A 		beq	.L448
 4283              	.L398:
2937:../uvc.c      ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 4284              		.loc 1 2937 0
 4285 2658 0000A0E3 		mov	r0, #0
 4286 265c 0110A0E3 		mov	r1, #1
 4287 2660 0020A0E1 		mov	r2, r0
 4288 2664 FEFFFFEB 		bl	CyU3PUsbStall
 4289 2668 30309DE5 		ldr	r3, [sp, #48]
 4290 266c 87FFFFEA 		b	.L371
 4291              	.LVL316:
 4292              	.L424:
 4293              	.LBE109:
 4294              	.LBE127:
3179:../uvc.c      **** 				}else if(snapButFlag&&(!value)){
 4295              		.loc 1 3179 0
 4296 2670 5FE6D6E5 		ldrb	lr, [r6, #1631]	@ zero_extendqisi2
 4297 2674 00005EE3 		cmp	lr, #0
 4298 2678 86FFFF0A 		beq	.L305
3181:../uvc.c      **** 					glInterStaBuffer[0] = 0x02;  //VS interface
 4299              		.loc 1 3181 0
 4300 267c 003097E5 		ldr	r3, [r7, #0]
 4301 2680 02B0A0E3 		mov	fp, #2
 4302 2684 00B0C3E5 		strb	fp, [r3, #0]
3182:../uvc.c      **** 					glInterStaBuffer[1] = 0x01;  //number of VS interface
 4303              		.loc 1 3182 0
 4304 2688 001097E5 		ldr	r1, [r7, #0]
 4305 268c 01B0A0E3 		mov	fp, #1
 4306 2690 01B0C1E5 		strb	fp, [r1, #1]
3183:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4307              		.loc 1 3183 0
 4308 2694 000097E5 		ldr	r0, [r7, #0]
3187:../uvc.c      **** 					interStabuf.size   = 1024;
 4309              		.loc 1 3187 0
 4310 2698 01EBA0E3 		mov	lr, #1024	@ movhi
3183:../uvc.c      **** 					glInterStaBuffer[2] = 0x00;
 4311              		.loc 1 3183 0
 4312 269c 0220C0E5 		strb	r2, [r0, #2]
3184:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4313              		.loc 1 3184 0
 4314 26a0 00C097E5 		ldr	ip, [r7, #0]
3193:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4315              		.loc 1 3193 0
 4316 26a4 0010E0E3 		mvn	r1, #0
3184:../uvc.c      **** 					glInterStaBuffer[3] = 0x01; //button release
 4317              		.loc 1 3184 0
 4318 26a8 03B0CCE5 		strb	fp, [ip, #3]
3186:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4319              		.loc 1 3186 0
 4320 26ac 003097E5 		ldr	r3, [r7, #0]
3188:../uvc.c      **** 					interStabuf.status = 0;
 4321              		.loc 1 3188 0
 4322 26b0 02C0A0E1 		mov	ip, r2	@ movhi
 4323 26b4 B822CDE1 		strh	r2, [sp, #40]	@ movhi
3193:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4324              		.loc 1 3193 0
 4325 26b8 E4069FE5 		ldr	r0, .L453+28
3190:../uvc.c      **** 					interStabuf.count = 4;
 4326              		.loc 1 3190 0
 4327 26bc 0420A0E3 		mov	r2, #4	@ movhi
3186:../uvc.c      **** 					interStabuf.buffer = glInterStaBuffer;
 4328              		.loc 1 3186 0
 4329 26c0 20308DE5 		str	r3, [sp, #32]
3190:../uvc.c      **** 					interStabuf.count = 4;
 4330              		.loc 1 3190 0
 4331 26c4 B422CDE1 		strh	r2, [sp, #36]	@ movhi
3187:../uvc.c      **** 					interStabuf.size   = 1024;
 4332              		.loc 1 3187 0
 4333 26c8 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
3193:../uvc.c      **** 					CyU3PDmaChannelWaitForCompletion(&glChHandleInterStat, CYU3P_WAIT_FOREVER);
 4334              		.loc 1 3193 0
 4335 26cc 1CC08DE5 		str	ip, [sp, #28]
 4336 26d0 FEFFFFEB 		bl	CyU3PDmaChannelWaitForCompletion
3196:../uvc.c      **** 					apiRetStatus = CyU3PDmaChannelSetupSendBuffer (&glChHandleInterStat, &interStabuf);
 4337              		.loc 1 3196 0
 4338 26d4 C8069FE5 		ldr	r0, .L453+28
 4339 26d8 20108DE2 		add	r1, sp, #32
 4340 26dc FEFFFFEB 		bl	CyU3PDmaChannelSetupSendBuffer
 4341              	.LVL317:
3197:../uvc.c      **** 					if (apiRetStatus != CY_U3P_SUCCESS)
 4342              		.loc 1 3197 0
 4343 26e0 1C309DE5 		ldr	r3, [sp, #28]
 4344 26e4 002050E2 		subs	r2, r0, #0
 4345 26e8 C100001A 		bne	.L449
3203:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4346              		.loc 1 3203 0
 4347 26ec 98269FE5 		ldr	r2, .L453+4
3204:../uvc.c      **** 					stiflag = CyTrue;
 4348              		.loc 1 3204 0
 4349 26f0 9CB084E5 		str	fp, [r4, #156]
3203:../uvc.c      **** 					snapButFlag = 0; //snap button is not masked.
 4350              		.loc 1 3203 0
 4351 26f4 5F36C2E5 		strb	r3, [r2, #1631]
3358:../uvc.c      ****         CyU3PThreadRelinquish ();
 4352              		.loc 1 3358 0
 4353 26f8 FEFFFFEB 		bl	_txe_thread_relinquish
 4354              	.LVL318:
 4355 26fc 2BFFFFEA 		b	.L429
 4356              	.LVL319:
 4357              	.L379:
 4358              	.LBB128:
 4359              	.LBB111:
2786:../uvc.c      ****     switch (wValue)
 4360              		.loc 1 2786 0
 4361 2700 010B52E3 		cmp	r2, #1024
 4362 2704 3900000A 		beq	.L377
 4363 2708 050C52E3 		cmp	r2, #1280
 4364 270c 5AFFFF1A 		bne	.L373
2998:../uvc.c      ****                 switch (bRequest)
 4365              		.loc 1 2998 0
 4366 2710 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4367 2714 810052E3 		cmp	r2, #129
 4368 2718 5800000A 		beq	.L418
 4369 271c 1F01008A 		bhi	.L421
 4370 2720 010052E3 		cmp	r2, #1
 4371 2724 54FFFF1A 		bne	.L373
3023:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4372              		.loc 1 3023 0
 4373 2728 2000A0E3 		mov	r0, #32
 4374 272c 80169FE5 		ldr	r1, .L453+44
 4375 2730 36208DE2 		add	r2, sp, #54
 4376 2734 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4377              	.LVL320:
3025:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4378              		.loc 1 3025 0
 4379 2738 000050E3 		cmp	r0, #0
 4380 273c 8B01001A 		bne	.L423
3035:../uvc.c      ****                             CyU3PDebugPrint (4, "Get UVC still trigger control %d %d\r\n", readCoun
 4381              		.loc 1 3035 0
 4382 2740 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 4383 2744 040080E2 		add	r0, r0, #4
 4384              	.LVL321:
 4385 2748 68169FE5 		ldr	r1, .L453+48
 4386 274c B623DDE1 		ldrh	r2, [sp, #54]
 4387 2750 FEFFFFEB 		bl	CyU3PDebugPrint
 4388              	.LVL322:
 4389 2754 30309DE5 		ldr	r3, [sp, #48]
 4390 2758 4CFFFFEA 		b	.L371
 4391              	.L326:
 4392              	.LBE111:
 4393              	.LBE128:
 4394              	.LBB129:
 4395              	.LBB93:
2391:../uvc.c      ****     switch (wValue)
 4396              		.loc 1 2391 0
 4397 275c 0A0C52E3 		cmp	r2, #2560
 4398 2760 F600000A 		beq	.L323
 4399 2764 EB00008A 		bhi	.L328
 4400 2768 070C52E3 		cmp	r2, #1792
 4401 276c E500000A 		beq	.L321
 4402 2770 020B52E3 		cmp	r2, #2048
 4403 2774 32FFFF1A 		bne	.L329
 4404              	.LVL323:
2422:../uvc.c      ****           		ControlHandle(ShapCtlID7);
 4405              		.loc 1 2422 0
 4406 2778 0700A0E3 		mov	r0, #7
 4407 277c FEFFFFEB 		bl	ControlHandle
 4408              	.LVL324:
 4409 2780 30309DE5 		ldr	r3, [sp, #48]
 4410 2784 37FFFFEA 		b	.L308
 4411              	.L341:
 4412              	.LBE93:
 4413              	.LBE129:
 4414              	.LBB130:
 4415              	.LBB98:
2466:../uvc.c      ****     switch (wValue)
 4416              		.loc 1 2466 0
 4417 2788 090C52E3 		cmp	r2, #2304
 4418 278c 2701000A 		beq	.L337
 4419 2790 1C01008A 		bhi	.L343
 4420 2794 070C52E3 		cmp	r2, #1792
 4421 2798 0E01000A 		beq	.L336
 4422 279c 020B52E3 		cmp	r2, #2048
 4423 27a0 27FFFF1A 		bne	.L329
 4424 27a4 2FFFFFEA 		b	.L308
 4425              	.L365:
 4426              	.LBE98:
 4427              	.LBE130:
 4428              	.LBB131:
 4429              	.LBB121:
2691:../uvc.c      ****     switch (wValue)
 4430              		.loc 1 2691 0
 4431 27a8 0F0C52E3 		cmp	r2, #3840
 4432 27ac 5F01000A 		beq	.L360
 4433 27b0 3E00008A 		bhi	.L368
 4434 27b4 0B0C52E3 		cmp	r2, #2816
 4435 27b8 5801000A 		beq	.L358
 4436 27bc 0D0C52E3 		cmp	r2, #3328
 4437 27c0 5201000A 		beq	.L359
 4438 27c4 0A0C52E3 		cmp	r2, #2560
 4439 27c8 21FFFF1A 		bne	.L309
2730:../uvc.c      ****     		if(CamMode == 1){//only 720p support
 4440              		.loc 1 2730 0
 4441 27cc 7830D4E5 		ldrb	r3, [r4, #120]	@ zero_extendqisi2
 4442 27d0 010053E3 		cmp	r3, #1
 4443 27d4 2501000A 		beq	.L450
2734:../uvc.c      ****     			CyU3PDebugPrint (4, "The host command is not correct for 1080p camera 0x%x 0x%x\r\n", wValue
 4444              		.loc 1 2734 0
 4445 27d8 0030D8E5 		ldrb	r3, [r8, #0]	@ zero_extendqisi2
 4446 27dc 0400A0E3 		mov	r0, #4
 4447 27e0 D4159FE5 		ldr	r1, .L453+52
 4448 27e4 FEFFFFEB 		bl	CyU3PDebugPrint
 4449 27e8 30309DE5 		ldr	r3, [sp, #48]
 4450 27ec 1DFFFFEA 		b	.L308
 4451              	.LVL325:
 4452              	.L377:
 4453              	.LBE121:
 4454              	.LBE131:
 4455              	.LBB132:
 4456              	.LBB108:
2943:../uvc.c      ****                 switch (bRequest)
 4457              		.loc 1 2943 0
 4458 27f0 00B0D8E5 		ldrb	fp, [r8, #0]	@ zero_extendqisi2
 4459 27f4 81005BE3 		cmp	fp, #129
 4460 27f8 1300000A 		beq	.L409
 4461 27fc 8500008A 		bhi	.L412
 4462 2800 01005BE3 		cmp	fp, #1
 4463 2804 1CFFFF1A 		bne	.L373
2968:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4464              		.loc 1 2968 0
 4465 2808 36208DE2 		add	r2, sp, #54
 4466 280c 2000A0E3 		mov	r0, #32
 4467 2810 9C159FE5 		ldr	r1, .L453+44
 4468 2814 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4469              	.LVL326:
2970:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4470              		.loc 1 2970 0
 4471 2818 002050E2 		subs	r2, r0, #0
 4472 281c 1AFFFF1A 		bne	.L433
2983:../uvc.c      ****                             apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CY
 4473              		.loc 1 2983 0
 4474 2820 60059FE5 		ldr	r0, .L453
 4475              	.LVL327:
 4476 2824 0B10A0E1 		mov	r1, fp
 4477 2828 FEFFFFEB 		bl	_txe_event_flags_set
 4478              	.LVL328:
2984:../uvc.c      ****                             if (apiRetStatus != CY_U3P_SUCCESS)
 4479              		.loc 1 2984 0
 4480 282c 002050E2 		subs	r2, r0, #0
 4481 2830 15FFFF0A 		beq	.L433
 4482 2834 1D0100EA 		b	.L415
 4483              	.LVL329:
 4484              	.L376:
2894:../uvc.c      ****                 switch (bRequest)
 4485              		.loc 1 2894 0
 4486 2838 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4487 283c 830052E3 		cmp	r2, #131
 4488 2840 9800008A 		bhi	.L403
 4489 2844 810052E3 		cmp	r2, #129
 4490 2848 7D00003A 		bcc	.L451
 4491              	.L409:
2955:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4492              		.loc 1 2955 0
 4493 284c 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
2957:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4494              		.loc 1 2957 0
 4495 2850 0B00A0E3 		mov	r0, #11
2955:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4496              		.loc 1 2955 0
 4497 2854 030053E3 		cmp	r3, #3
2957:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4498              		.loc 1 2957 0
 4499 2858 60159F05 		ldreq	r1, .L453+56
2961:../uvc.c      ****                             CyU3PUsbSendEP0Data (VD_FX_UVC_MAX_STLPROBE_SETTING, (uint8_t *)glProbe
 4500              		.loc 1 2961 0
 4501 285c 60159F15 		ldrne	r1, .L453+60
 4502 2860 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4503 2864 30309DE5 		ldr	r3, [sp, #48]
 4504 2868 08FFFFEA 		b	.L371
 4505              	.L374:
2789:../uvc.c      ****             switch (bRequest)
 4506              		.loc 1 2789 0
 4507 286c 0020D8E5 		ldrb	r2, [r8, #0]	@ zero_extendqisi2
 4508 2870 830052E3 		cmp	r2, #131
 4509 2874 2F00008A 		bhi	.L385
 4510 2878 810052E3 		cmp	r2, #129
 4511 287c 1400003A 		bcc	.L452
 4512              	.L418:
3010:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4513              		.loc 1 3010 0
 4514 2880 48B0D4E5 		ldrb	fp, [r4, #72]	@ zero_extendqisi2
3012:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4515              		.loc 1 3012 0
 4516 2884 1A00A0E3 		mov	r0, #26
3010:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4517              		.loc 1 3010 0
 4518 2888 03005BE3 		cmp	fp, #3
3012:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4519              		.loc 1 3012 0
 4520 288c 34159F05 		ldreq	r1, .L453+64
3016:../uvc.c      ****                             CyU3PUsbSendEP0Data (CY_FX_UVC_MAX_PROBE_SETTING, (uint8_t *)glProbeCtr
 4521              		.loc 1 3016 0
 4522 2890 34159F15 		ldrne	r1, .L453+68
 4523 2894 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4524 2898 30309DE5 		ldr	r3, [sp, #48]
 4525 289c FBFEFFEA 		b	.L371
 4526              	.LVL330:
 4527              	.L335:
 4528              	.LBE108:
 4529              	.LBE132:
 4530              	.LBB133:
 4531              	.LBB101:
2492:../uvc.c      ****      		CTControlHandle(FocACtlID5);
 4532              		.loc 1 2492 0
 4533 28a0 0500A0E3 		mov	r0, #5
 4534 28a4 FEFFFFEB 		bl	CTControlHandle
 4535              	.LVL331:
 4536 28a8 30309DE5 		ldr	r3, [sp, #48]
 4537 28ac EDFEFFEA 		b	.L308
 4538              	.L368:
 4539              	.LBE101:
 4540              	.LBE133:
 4541              	.LBB134:
 4542              	.LBB123:
2691:../uvc.c      ****     switch (wValue)
 4543              		.loc 1 2691 0
 4544 28b0 110C52E3 		cmp	r2, #4352
 4545 28b4 E900000A 		beq	.L362
 4546 28b8 2D00008A 		bhi	.L369
 4547 28bc 010A52E3 		cmp	r2, #4096
 4548 28c0 E3FEFF1A 		bne	.L309
 4549              	.LVL332:
2754:../uvc.c      ****       		ControlHandle(ExtI2CCtlID15);
 4550              		.loc 1 2754 0
 4551 28c4 1F00A0E3 		mov	r0, #31
 4552 28c8 FEFFFFEB 		bl	ControlHandle
 4553              	.LVL333:
 4554 28cc 30309DE5 		ldr	r3, [sp, #48]
 4555 28d0 E4FEFFEA 		b	.L308
 4556              	.LVL334:
 4557              	.L452:
 4558              	.LBE123:
 4559              	.LBE134:
 4560              	.LBB135:
 4561              	.LBB112:
2789:../uvc.c      ****             switch (bRequest)
 4562              		.loc 1 2789 0
 4563 28d4 010052E3 		cmp	r2, #1
 4564 28d8 5EFFFF1A 		bne	.L398
2814:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4565              		.loc 1 2814 0
 4566 28dc 2000A0E3 		mov	r0, #32
 4567 28e0 CC149FE5 		ldr	r1, .L453+44
 4568 28e4 36208DE2 		add	r2, sp, #54
 4569 28e8 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4570              	.LVL335:
2816:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 4571              		.loc 1 2816 0
 4572 28ec 000050E3 		cmp	r0, #0
 4573 28f0 E5FEFF1A 		bne	.L433
2818:../uvc.c      ****                         if (usbSpeed == CY_U3P_SUPER_SPEED)
 4574              		.loc 1 2818 0
 4575 28f4 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4576 28f8 030051E3 		cmp	r1, #3
 4577 28fc E2FEFF1A 		bne	.L433
2825:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4578              		.loc 1 2825 0
 4579 2900 8130D4E5 		ldrb	r3, [r4, #129]	@ zero_extendqisi2
2822:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4580              		.loc 1 2822 0
 4581 2904 7EE0D4E5 		ldrb	lr, [r4, #126]	@ zero_extendqisi2
2823:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4582              		.loc 1 2823 0
 4583 2908 7FC0D4E5 		ldrb	ip, [r4, #127]	@ zero_extendqisi2
2824:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4584              		.loc 1 2824 0
 4585 290c 8000D4E5 		ldrb	r0, [r4, #128]	@ zero_extendqisi2
 4586              	.LVL336:
2826:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4587              		.loc 1 2826 0
 4588 2910 8220D4E5 		ldrb	r2, [r4, #130]	@ zero_extendqisi2
2827:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4589              		.loc 1 2827 0
 4590 2914 83B0D4E5 		ldrb	fp, [r4, #131]	@ zero_extendqisi2
2825:../uvc.c      ****                             glProbeCtrl[5] = glCommitCtrl[5];
 4591              		.loc 1 2825 0
 4592 2918 1536C6E5 		strb	r3, [r6, #1557]
2822:../uvc.c      ****                             glProbeCtrl[2] = glCommitCtrl[2];
 4593              		.loc 1 2822 0
 4594 291c 12E6C6E5 		strb	lr, [r6, #1554]
2823:../uvc.c      ****                             glProbeCtrl[3] = glCommitCtrl[3];
 4595              		.loc 1 2823 0
 4596 2920 13C6C6E5 		strb	ip, [r6, #1555]
2824:../uvc.c      ****                             glProbeCtrl[4] = glCommitCtrl[4];
 4597              		.loc 1 2824 0
 4598 2924 1406C6E5 		strb	r0, [r6, #1556]
2826:../uvc.c      ****                             glProbeCtrl[6] = glCommitCtrl[6];
 4599              		.loc 1 2826 0
 4600 2928 1626C6E5 		strb	r2, [r6, #1558]
2827:../uvc.c      ****                             glProbeCtrl[7] = glCommitCtrl[7];
 4601              		.loc 1 2827 0
 4602 292c 17B6C6E5 		strb	fp, [r6, #1559]
 4603 2930 30309DE5 		ldr	r3, [sp, #48]
 4604 2934 D5FEFFEA 		b	.L371
 4605              	.LVL337:
 4606              	.L385:
2789:../uvc.c      ****             switch (bRequest)
 4607              		.loc 1 2789 0
 4608 2938 860052E3 		cmp	r2, #134
 4609 293c 3900000A 		beq	.L436
 4610 2940 870052E3 		cmp	r2, #135
 4611 2944 CDFFFF0A 		beq	.L418
 4612              	.L442:
2894:../uvc.c      ****                 switch (bRequest)
 4613              		.loc 1 2894 0
 4614 2948 850052E3 		cmp	r2, #133
 4615 294c 41FFFF1A 		bne	.L398
 4616              	.L410:
2952:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4617              		.loc 1 2952 0
 4618 2950 78149FE5 		ldr	r1, .L453+72
 4619 2954 0200A0E3 		mov	r0, #2
2950:../uvc.c      ****                         glEp0Buffer[0] = CY_FX_UVC_MAX_PROBE_SETTING;
 4620              		.loc 1 2950 0
 4621 2958 1A30A0E3 		mov	r3, #26
 4622              	.L434:
3006:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4623              		.loc 1 3006 0
 4624 295c 0020A0E3 		mov	r2, #0
3005:../uvc.c      ****                         glEp0Buffer[0] = 1;//CY_FX_UVC_MAX_PROBE_SETTING;
 4625              		.loc 1 3005 0
 4626 2960 5830C4E5 		strb	r3, [r4, #88]
3006:../uvc.c      ****                         glEp0Buffer[1] = 0;
 4627              		.loc 1 3006 0
 4628 2964 5920C4E5 		strb	r2, [r4, #89]
3007:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 4629              		.loc 1 3007 0
 4630 2968 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4631 296c 30309DE5 		ldr	r3, [sp, #48]
 4632 2970 C6FEFFEA 		b	.L371
 4633              	.LVL338:
 4634              	.L369:
 4635              	.LBE112:
 4636              	.LBE135:
 4637              	.LBB136:
 4638              	.LBB120:
2691:../uvc.c      ****     switch (wValue)
 4639              		.loc 1 2691 0
 4640 2974 120C52E3 		cmp	r2, #4608
 4641 2978 E000000A 		beq	.L363
 4642 297c 130C52E3 		cmp	r2, #4864
 4643 2980 B3FEFF1A 		bne	.L309
 4644              	.LVL339:
2766:../uvc.c      ****       		ControlHandle(Ext1BLCGridCtlID2);
 4645              		.loc 1 2766 0
 4646 2984 2200A0E3 		mov	r0, #34
 4647 2988 FEFFFFEB 		bl	ControlHandle
 4648              	.LVL340:
 4649 298c 30309DE5 		ldr	r3, [sp, #48]
 4650 2990 B4FEFFEA 		b	.L308
 4651              	.L342:
 4652              	.LBE120:
 4653              	.LBE136:
 4654              	.LBB137:
 4655              	.LBB97:
2466:../uvc.c      ****     switch (wValue)
 4656              		.loc 1 2466 0
 4657 2994 010B52E3 		cmp	r2, #1024
 4658 2998 0900000A 		beq	.L333
 4659 299c 050C52E3 		cmp	r2, #1280
 4660 29a0 A7FEFF1A 		bne	.L329
 4661              	.LVL341:
2488:../uvc.c      ****       		CTControlHandle(ExTmRCtlID4);
 4662              		.loc 1 2488 0
 4663 29a4 0400A0E3 		mov	r0, #4
 4664 29a8 FEFFFFEB 		bl	CTControlHandle
 4665              	.LVL342:
 4666 29ac 30309DE5 		ldr	r3, [sp, #48]
 4667 29b0 ACFEFFEA 		b	.L308
 4668              	.L332:
 4669              	.LVL343:
2478:../uvc.c      **** 			CTControlHandle(AutoExPCtlID2);
 4670              		.loc 1 2478 0
 4671 29b4 0200A0E3 		mov	r0, #2
 4672 29b8 FEFFFFEB 		bl	CTControlHandle
 4673              	.LVL344:
 4674 29bc 30309DE5 		ldr	r3, [sp, #48]
 4675 29c0 A8FEFFEA 		b	.L308
 4676              	.L333:
 4677              	.LVL345:
2483:../uvc.c      **** 			CTControlHandle(ExTmACtlID3);
 4678              		.loc 1 2483 0
 4679 29c4 0300A0E3 		mov	r0, #3
 4680 29c8 FEFFFFEB 		bl	CTControlHandle
 4681              	.LVL346:
 4682 29cc 30309DE5 		ldr	r3, [sp, #48]
 4683 29d0 A4FEFFEA 		b	.L308
 4684              	.L445:
 4685              	.LVL347:
 4686              	.LBE97:
 4687              	.LBE137:
 4688              	.LBB138:
 4689              	.LBB91:
2399:../uvc.c      ****    			ControlHandle(BrgtCtlID1);
 4690              		.loc 1 2399 0
 4691 29d4 0100A0E3 		mov	r0, #1
 4692 29d8 FEFFFFEB 		bl	ControlHandle
 4693              	.LVL348:
 4694 29dc 30309DE5 		ldr	r3, [sp, #48]
 4695 29e0 A0FEFFEA 		b	.L308
 4696              	.L316:
 4697              	.LVL349:
2395:../uvc.c      ****     		ControlHandle(BLCCtlID0);
 4698              		.loc 1 2395 0
 4699 29e4 0000A0E3 		mov	r0, #0
 4700 29e8 FEFFFFEB 		bl	ControlHandle
 4701              	.LVL350:
 4702 29ec 30309DE5 		ldr	r3, [sp, #48]
 4703 29f0 9CFEFFEA 		b	.L308
 4704              	.LVL351:
 4705              	.L449:
 4706              	.LBE91:
 4707              	.LBE138:
3199:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4708              		.loc 1 3199 0
 4709 29f4 0400A0E3 		mov	r0, #4
 4710              	.LVL352:
 4711 29f8 D4139FE5 		ldr	r1, .L453+76
 4712 29fc FEFFFFEB 		bl	CyU3PDebugPrint
 4713              	.LVL353:
 4714              	.L428:
 4715              	.LBB139:
 4716              	.LBB140:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4717              		.loc 1 1213 0
 4718 2a00 D0139FE5 		ldr	r1, .L453+80
 4719 2a04 0400A0E3 		mov	r0, #4
 4720 2a08 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 4721              		.loc 1 1214 0
 4722 2a0c FA0FA0E3 		mov	r0, #1000
 4723 2a10 FEFFFFEB 		bl	_tx_thread_sleep
 4724 2a14 F9FFFFEA 		b	.L428
 4725              	.LVL354:
 4726              	.L412:
 4727              	.LBE140:
 4728              	.LBE139:
 4729              	.LBB141:
 4730              	.LBB107:
2943:../uvc.c      ****                 switch (bRequest)
 4731              		.loc 1 2943 0
 4732 2a18 85005BE3 		cmp	fp, #133
 4733 2a1c CBFFFF0A 		beq	.L410
 4734 2a20 86005BE3 		cmp	fp, #134
 4735 2a24 94FEFF1A 		bne	.L373
 4736              	.L436:
2947:../uvc.c      ****                         CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4737              		.loc 1 2947 0
 4738 2a28 0300A0E1 		mov	r0, r3
 4739              	.L431:
2842:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4740              		.loc 1 2842 0
 4741 2a2c 9C139FE5 		ldr	r1, .L453+72
2841:../uvc.c      ****                     glEp0Buffer[0] = 3;                        /* GET/SET requests are supported. *
 4742              		.loc 1 2841 0
 4743 2a30 03B0A0E3 		mov	fp, #3
 4744 2a34 58B0C4E5 		strb	fp, [r4, #88]
2842:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4745              		.loc 1 2842 0
 4746 2a38 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 4747 2a3c 30309DE5 		ldr	r3, [sp, #48]
 4748 2a40 92FEFFEA 		b	.L371
 4749              	.L451:
2894:../uvc.c      ****                 switch (bRequest)
 4750              		.loc 1 2894 0
 4751 2a44 010052E3 		cmp	r2, #1
 4752 2a48 02FFFF1A 		bne	.L398
2919:../uvc.c      ****                         apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 4753              		.loc 1 2919 0
 4754 2a4c 2000A0E3 		mov	r0, #32
 4755 2a50 5C139FE5 		ldr	r1, .L453+44
 4756 2a54 36208DE2 		add	r2, sp, #54
 4757 2a58 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 4758              	.LVL355:
2921:../uvc.c      ****                         if (apiRetStatus == CY_U3P_SUCCESS)
 4759              		.loc 1 2921 0
 4760 2a5c 000050E3 		cmp	r0, #0
 4761 2a60 89FEFF1A 		bne	.L433
2923:../uvc.c      ****                             if (usbSpeed == CY_U3P_SUPER_SPEED)
 4762              		.loc 1 2923 0
 4763 2a64 4810D5E5 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 4764 2a68 030051E3 		cmp	r1, #3
 4765 2a6c 86FEFF1A 		bne	.L433
2932:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4766              		.loc 1 2932 0
 4767 2a70 8230D5E5 		ldrb	r3, [r5, #130]	@ zero_extendqisi2
2927:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4768              		.loc 1 2927 0
 4769 2a74 7DE0D5E5 		ldrb	lr, [r5, #125]	@ zero_extendqisi2
2928:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4770              		.loc 1 2928 0
 4771 2a78 7EC0D5E5 		ldrb	ip, [r5, #126]	@ zero_extendqisi2
2929:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4772              		.loc 1 2929 0
 4773 2a7c 7F00D5E5 		ldrb	r0, [r5, #127]	@ zero_extendqisi2
 4774              	.LVL356:
2930:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4775              		.loc 1 2930 0
 4776 2a80 80B0D5E5 		ldrb	fp, [r5, #128]	@ zero_extendqisi2
2931:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4777              		.loc 1 2931 0
 4778 2a84 8120D5E5 		ldrb	r2, [r5, #129]	@ zero_extendqisi2
2932:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4779              		.loc 1 2932 0
 4780 2a88 4E36C6E5 		strb	r3, [r6, #1614]
2927:../uvc.c      ****                             	glProbeStilCtrl[1] = glCommitCtrl[1];
 4781              		.loc 1 2927 0
 4782 2a8c 49E6C6E5 		strb	lr, [r6, #1609]
2928:../uvc.c      ****                             	glProbeStilCtrl[2] = glCommitCtrl[2];
 4783              		.loc 1 2928 0
 4784 2a90 4AC6C6E5 		strb	ip, [r6, #1610]
2929:../uvc.c      ****                             	glProbeStilCtrl[3] = glCommitCtrl[3];
 4785              		.loc 1 2929 0
 4786 2a94 4B06C6E5 		strb	r0, [r6, #1611]
2930:../uvc.c      ****                             	glProbeStilCtrl[4] = glCommitCtrl[4];
 4787              		.loc 1 2930 0
 4788 2a98 4CB6C6E5 		strb	fp, [r6, #1612]
2931:../uvc.c      ****                             	glProbeStilCtrl[5] = glCommitCtrl[5];
 4789              		.loc 1 2931 0
 4790 2a9c 4D26C6E5 		strb	r2, [r6, #1613]
2932:../uvc.c      ****                             	glProbeStilCtrl[6] = glCommitCtrl[6];
 4791              		.loc 1 2932 0
 4792 2aa0 30309DE5 		ldr	r3, [sp, #48]
 4793 2aa4 79FEFFEA 		b	.L371
 4794              	.LVL357:
 4795              	.L403:
2894:../uvc.c      ****                 switch (bRequest)
 4796              		.loc 1 2894 0
 4797 2aa8 860052E3 		cmp	r2, #134
 4798 2aac DDFFFF0A 		beq	.L436
 4799 2ab0 870052E3 		cmp	r2, #135
 4800 2ab4 A3FFFF1A 		bne	.L442
 4801 2ab8 63FFFFEA 		b	.L409
 4802              	.LVL358:
 4803              	.L330:
 4804              	.LBE107:
 4805              	.LBE141:
 4806              	.LBB142:
 4807              	.LBB102:
2470:../uvc.c      ****     		CTControlHandle(ScanMCtlID0);
 4808              		.loc 1 2470 0
 4809 2abc 0000A0E3 		mov	r0, #0
 4810 2ac0 FEFFFFEB 		bl	CTControlHandle
 4811              	.LVL359:
 4812 2ac4 30309DE5 		ldr	r3, [sp, #48]
 4813 2ac8 66FEFFEA 		b	.L308
 4814              	.LVL360:
 4815              	.L447:
 4816              	.LBE102:
 4817              	.LBE142:
3175:../uvc.c      **** 						CyU3PDebugPrint (4, "Failed to send interrupt status, Error code = %d\r\n", apiRetStatus);
 4818              		.loc 1 3175 0
 4819 2acc 0400A0E3 		mov	r0, #4
 4820              	.LVL361:
 4821 2ad0 FC129FE5 		ldr	r1, .L453+76
 4822 2ad4 FEFFFFEB 		bl	CyU3PDebugPrint
 4823              	.LVL362:
 4824              	.L426:
 4825              	.LBB143:
 4826              	.LBB144:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 4827              		.loc 1 1213 0
 4828 2ad8 F8129FE5 		ldr	r1, .L453+80
 4829 2adc 0400A0E3 		mov	r0, #4
 4830 2ae0 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 4831              		.loc 1 1214 0
 4832 2ae4 FA0FA0E3 		mov	r0, #1000
 4833 2ae8 FEFFFFEB 		bl	_tx_thread_sleep
 4834 2aec F9FFFFEA 		b	.L426
 4835              	.LVL363:
 4836              	.L394:
 4837              	.LBE144:
 4838              	.LBE143:
 4839              	.LBB145:
 4840              	.LBB113:
2838:../uvc.c      ****             switch (bRequest)
 4841              		.loc 1 2838 0
 4842 2af0 850053E3 		cmp	r3, #133
 4843 2af4 95FFFF0A 		beq	.L410
 4844 2af8 860053E3 		cmp	r3, #134
 4845 2afc D5FEFF1A 		bne	.L398
 4846              	.L437:
2842:../uvc.c      ****                     CyU3PUsbSendEP0Data (1, (uint8_t *)glEp0Buffer);
 4847              		.loc 1 2842 0
 4848 2b00 0100A0E3 		mov	r0, #1
 4849 2b04 C8FFFFEA 		b	.L431
 4850              	.LVL364:
 4851              	.L321:
 4852              	.LBE113:
 4853              	.LBE145:
 4854              	.LBB146:
 4855              	.LBB94:
2418:../uvc.c      ****           		ControlHandle(SaturCtlID6);
 4856              		.loc 1 2418 0
 4857 2b08 0600A0E3 		mov	r0, #6
 4858 2b0c FEFFFFEB 		bl	ControlHandle
 4859              	.LVL365:
 4860 2b10 30309DE5 		ldr	r3, [sp, #48]
 4861 2b14 53FEFFEA 		b	.L308
 4862              	.L328:
2391:../uvc.c      ****     switch (wValue)
 4863              		.loc 1 2391 0
 4864 2b18 0D0C52E3 		cmp	r2, #3328
 4865 2b1c 0700000A 		beq	.L323
 4866 2b20 0E0C52E3 		cmp	r2, #3584
 4867 2b24 0900000A 		beq	.L325
 4868 2b28 030B52E3 		cmp	r2, #3072
 4869 2b2c 44FEFF1A 		bne	.L329
 4870              	.LVL366:
2432:../uvc.c      ****     		ControlHandle(WBTLevCtlID11);
 4871              		.loc 1 2432 0
 4872 2b30 0B00A0E3 		mov	r0, #11
 4873 2b34 FEFFFFEB 		bl	ControlHandle
 4874              	.LVL367:
 4875 2b38 30309DE5 		ldr	r3, [sp, #48]
 4876 2b3c 49FEFFEA 		b	.L308
 4877              	.L323:
 4878              	.LVL368:
2428:../uvc.c      ****     		ControlHandle(WBTMdCtlID9);
 4879              		.loc 1 2428 0
 4880 2b40 0900A0E3 		mov	r0, #9
 4881 2b44 FEFFFFEB 		bl	ControlHandle
 4882              	.LVL369:
 4883 2b48 30309DE5 		ldr	r3, [sp, #48]
 4884 2b4c 45FEFFEA 		b	.L308
 4885              	.L325:
 4886              	.LVL370:
2436:../uvc.c      ****     		ControlHandle(DigZmCtlID14);
 4887              		.loc 1 2436 0
 4888 2b50 0E00A0E3 		mov	r0, #14
 4889 2b54 FEFFFFEB 		bl	ControlHandle
 4890              	.LVL371:
 4891 2b58 30309DE5 		ldr	r3, [sp, #48]
 4892 2b5c 41FEFFEA 		b	.L308
 4893              	.L327:
2391:../uvc.c      ****     switch (wValue)
 4894              		.loc 1 2391 0
 4895 2b60 010B52E3 		cmp	r2, #1024
 4896 2b64 3FFEFF0A 		beq	.L308
 4897 2b68 050C52E3 		cmp	r2, #1280
 4898 2b6c 34FEFF1A 		bne	.L329
 4899              	.LVL372:
2410:../uvc.c      ****       		ControlHandle(MFreqCtlID4);
 4900              		.loc 1 2410 0
 4901 2b70 0400A0E3 		mov	r0, #4
 4902 2b74 FEFFFFEB 		bl	ControlHandle
 4903              	.LVL373:
 4904 2b78 30309DE5 		ldr	r3, [sp, #48]
 4905 2b7c 39FEFFEA 		b	.L308
 4906              	.L318:
 4907              	.LVL374:
2403:../uvc.c      **** 			ControlHandle(ConsCtlID2);
 4908              		.loc 1 2403 0
 4909 2b80 0200A0E3 		mov	r0, #2
 4910 2b84 FEFFFFEB 		bl	ControlHandle
 4911              	.LVL375:
 4912 2b88 30309DE5 		ldr	r3, [sp, #48]
 4913 2b8c 35FEFFEA 		b	.L308
 4914              	.L320:
 4915              	.LVL376:
2414:../uvc.c      ****      		ControlHandle(HueCtlID5);
 4916              		.loc 1 2414 0
 4917 2b90 0500A0E3 		mov	r0, #5
 4918 2b94 FEFFFFEB 		bl	ControlHandle
 4919              	.LVL377:
 4920 2b98 30309DE5 		ldr	r3, [sp, #48]
 4921 2b9c 31FEFFEA 		b	.L308
 4922              	.LVL378:
 4923              	.L421:
 4924              	.LBE94:
 4925              	.LBE146:
 4926              	.LBB147:
 4927              	.LBB106:
2998:../uvc.c      ****                 switch (bRequest)
 4928              		.loc 1 2998 0
 4929 2ba0 850052E3 		cmp	r2, #133
 4930 2ba4 5200000A 		beq	.L419
 4931 2ba8 860052E3 		cmp	r2, #134
 4932 2bac 32FEFF1A 		bne	.L373
 4933 2bb0 D2FFFFEA 		b	.L437
 4934              	.LVL379:
 4935              	.L366:
 4936              	.LBE106:
 4937              	.LBE147:
 4938              	.LBB148:
 4939              	.LBB124:
2691:../uvc.c      ****     switch (wValue)
 4940              		.loc 1 2691 0
 4941 2bb4 060C52E3 		cmp	r2, #1536
 4942 2bb8 4900000A 		beq	.L353
 4943 2bbc 0900008A 		bhi	.L367
 4944 2bc0 050C52E3 		cmp	r2, #1280
 4945 2bc4 22FEFF1A 		bne	.L309
 4946              	.LVL380:
2711:../uvc.c      ****       		ControlHandle(Ext3DNReduLvCtlID4);
 4947              		.loc 1 2711 0
 4948 2bc8 1400A0E3 		mov	r0, #20
 4949 2bcc FEFFFFEB 		bl	ControlHandle
 4950              	.LVL381:
 4951 2bd0 30309DE5 		ldr	r3, [sp, #48]
 4952 2bd4 23FEFFEA 		b	.L308
 4953              	.L336:
 4954              	.LVL382:
 4955              	.LBE124:
 4956              	.LBE148:
 4957              	.LBB149:
 4958              	.LBB96:
2496:../uvc.c      ****           		CTControlHandle(FocRCtlID6);
 4959              		.loc 1 2496 0
 4960 2bd8 0600A0E3 		mov	r0, #6
 4961 2bdc FEFFFFEB 		bl	CTControlHandle
 4962              	.LVL383:
 4963 2be0 30309DE5 		ldr	r3, [sp, #48]
 4964 2be4 1FFEFFEA 		b	.L308
 4965              	.L367:
 4966              	.LBE96:
 4967              	.LBE149:
 4968              	.LBB150:
 4969              	.LBB119:
2691:../uvc.c      ****     switch (wValue)
 4970              		.loc 1 2691 0
 4971 2be8 070C52E3 		cmp	r2, #1792
 4972 2bec 3800000A 		beq	.L354
 4973 2bf0 020B52E3 		cmp	r2, #2048
 4974 2bf4 16FEFF1A 		bne	.L309
 4975              	.LVL384:
2723:../uvc.c      ****       		ControlHandle(ExtDNlevCtlID7);
 4976              		.loc 1 2723 0
 4977 2bf8 1700A0E3 		mov	r0, #23
 4978 2bfc FEFFFFEB 		bl	ControlHandle
 4979              	.LVL385:
 4980 2c00 30309DE5 		ldr	r3, [sp, #48]
 4981 2c04 17FEFFEA 		b	.L308
 4982              	.L343:
 4983              	.LBE119:
 4984              	.LBE150:
 4985              	.LBB151:
 4986              	.LBB103:
2466:../uvc.c      ****     switch (wValue)
 4987              		.loc 1 2466 0
 4988 2c08 0B0C52E3 		cmp	r2, #2816
 4989 2c0c 0F00000A 		beq	.L339
 4990 2c10 030B52E3 		cmp	r2, #3072
 4991 2c14 0900000A 		beq	.L340
 4992 2c18 0A0C52E3 		cmp	r2, #2560
 4993 2c1c 08FEFF1A 		bne	.L329
 4994              	.LVL386:
2507:../uvc.c      ****     		CTControlHandle(IriRCtlID8);
 4995              		.loc 1 2507 0
 4996 2c20 0800A0E3 		mov	r0, #8
 4997 2c24 FEFFFFEB 		bl	CTControlHandle
 4998              	.LVL387:
 4999 2c28 30309DE5 		ldr	r3, [sp, #48]
 5000 2c2c 0DFEFFEA 		b	.L308
 5001              	.L337:
 5002              	.LVL388:
2502:../uvc.c      ****      		CTControlHandle(IriACtlID7);
 5003              		.loc 1 2502 0
 5004 2c30 0700A0E3 		mov	r0, #7
 5005 2c34 FEFFFFEB 		bl	CTControlHandle
 5006              	.LVL389:
 5007 2c38 30309DE5 		ldr	r3, [sp, #48]
 5008 2c3c 09FEFFEA 		b	.L308
 5009              	.L340:
 5010              	.LVL390:
2515:../uvc.c      ****     		CTControlHandle(ZmOpRCtlID10);
 5011              		.loc 1 2515 0
 5012 2c40 0A00A0E3 		mov	r0, #10
 5013 2c44 FEFFFFEB 		bl	CTControlHandle
 5014              	.LVL391:
 5015 2c48 30309DE5 		ldr	r3, [sp, #48]
 5016 2c4c 05FEFFEA 		b	.L308
 5017              	.L339:
 5018              	.LVL392:
2511:../uvc.c      ****     		CTControlHandle(ZmOpACtlID9);
 5019              		.loc 1 2511 0
 5020 2c50 0900A0E3 		mov	r0, #9
 5021 2c54 FEFFFFEB 		bl	CTControlHandle
 5022              	.LVL393:
 5023 2c58 30309DE5 		ldr	r3, [sp, #48]
 5024 2c5c 01FEFFEA 		b	.L308
 5025              	.L362:
 5026              	.LVL394:
 5027              	.LBE103:
 5028              	.LBE151:
 5029              	.LBB152:
 5030              	.LBB125:
2758:../uvc.c      ****       		ControlHandle(Ext1BLCRangeCtlID0);
 5031              		.loc 1 2758 0
 5032 2c60 2000A0E3 		mov	r0, #32
 5033 2c64 FEFFFFEB 		bl	ControlHandle
 5034              	.LVL395:
 5035 2c68 30309DE5 		ldr	r3, [sp, #48]
 5036 2c6c FDFDFFEA 		b	.L308
 5037              	.L450:
 5038              	.LVL396:
2732:../uvc.c      **** 				ControlHandle(ExtAexModCtlID9);
 5039              		.loc 1 2732 0
 5040 2c70 1900A0E3 		mov	r0, #25
 5041 2c74 FEFFFFEB 		bl	ControlHandle
 5042              	.LVL397:
 5043 2c78 30309DE5 		ldr	r3, [sp, #48]
 5044 2c7c F9FDFFEA 		b	.L308
 5045              	.LVL398:
 5046              	.L448:
 5047              	.LBE125:
 5048              	.LBE152:
 5049              	.LBB153:
 5050              	.LBB114:
2863:../uvc.c      ****                     apiRetStatus = CyU3PUsbGetEP0Data (CY_FX_UVC_MAX_PROBE_SETTING_ALIGNED,
 5051              		.loc 1 2863 0
 5052 2c80 2000A0E3 		mov	r0, #32
 5053 2c84 28119FE5 		ldr	r1, .L453+44
 5054 2c88 36208DE2 		add	r2, sp, #54
 5055 2c8c FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 5056              	.LVL399:
2865:../uvc.c      ****                     if (apiRetStatus == CY_U3P_SUCCESS)
 5057              		.loc 1 2865 0
 5058 2c90 000050E3 		cmp	r0, #0
 5059 2c94 FCFDFF1A 		bne	.L433
2878:../uvc.c      ****                         apiRetStatus = CyU3PEventSet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_
 5060              		.loc 1 2878 0
 5061 2c98 0020A0E3 		mov	r2, #0
 5062 2c9c E4009FE5 		ldr	r0, .L453
 5063              	.LVL400:
 5064 2ca0 0110A0E3 		mov	r1, #1
 5065 2ca4 FEFFFFEB 		bl	_txe_event_flags_set
 5066              	.LVL401:
2879:../uvc.c      ****                         if (apiRetStatus != CY_U3P_SUCCESS)
 5067              		.loc 1 2879 0
 5068 2ca8 002050E2 		subs	r2, r0, #0
 5069 2cac F6FDFF0A 		beq	.L433
 5070              	.L415:
2986:../uvc.c      ****                                 CyU3PDebugPrint (4, "Set CY_FX_UVC_STREAM_EVENT failed %x\n", apiRe
 5071              		.loc 1 2986 0
 5072 2cb0 0400A0E3 		mov	r0, #4
 5073              	.LVL402:
 5074 2cb4 20119FE5 		ldr	r1, .L453+84
 5075 2cb8 FEFFFFEB 		bl	CyU3PDebugPrint
 5076              	.LVL403:
 5077 2cbc 30309DE5 		ldr	r3, [sp, #48]
 5078 2cc0 F2FDFFEA 		b	.L371
 5079              	.L350:
 5080              	.LVL404:
 5081              	.LBE114:
 5082              	.LBE153:
 5083              	.LBB154:
 5084              	.LBB118:
2703:../uvc.c      ****       		ControlHandle(ExtMirrCtlID2);
 5085              		.loc 1 2703 0
 5086 2cc4 1200A0E3 		mov	r0, #18
 5087 2cc8 FEFFFFEB 		bl	ControlHandle
 5088              	.LVL405:
 5089 2ccc 30309DE5 		ldr	r3, [sp, #48]
 5090 2cd0 E4FDFFEA 		b	.L308
 5091              	.L354:
 5092              	.LVL406:
2719:../uvc.c      ****       		ControlHandle(ExtDNDelytlID6);
 5093              		.loc 1 2719 0
 5094 2cd4 1600A0E3 		mov	r0, #22
 5095 2cd8 FEFFFFEB 		bl	ControlHandle
 5096              	.LVL407:
 5097 2cdc 30309DE5 		ldr	r3, [sp, #48]
 5098 2ce0 E0FDFFEA 		b	.L308
 5099              	.L353:
 5100              	.LVL408:
2715:../uvc.c      ****       		ControlHandle(ExtDNModCtlID5);
 5101              		.loc 1 2715 0
 5102 2ce4 1500A0E3 		mov	r0, #21
 5103 2ce8 FEFFFFEB 		bl	ControlHandle
 5104              	.LVL409:
 5105 2cec 30309DE5 		ldr	r3, [sp, #48]
 5106 2cf0 DCFDFFEA 		b	.L308
 5107              	.LVL410:
 5108              	.L419:
 5109              	.LBE118:
 5110              	.LBE154:
 5111              	.LBB155:
 5112              	.LBB105:
3007:../uvc.c      ****                         CyU3PUsbSendEP0Data (2, (uint8_t *)glEp0Buffer);
 5113              		.loc 1 3007 0
 5114 2cf4 0200A0E3 		mov	r0, #2
 5115 2cf8 D0109FE5 		ldr	r1, .L453+72
 5116 2cfc 16FFFFEA 		b	.L434
 5117              	.LVL411:
 5118              	.L363:
 5119              	.LBE105:
 5120              	.LBE155:
 5121              	.LBB156:
 5122              	.LBB126:
2762:../uvc.c      ****       		ControlHandle(Ext1BLCWeightCtlID1);
 5123              		.loc 1 2762 0
 5124 2d00 2100A0E3 		mov	r0, #33
 5125 2d04 FEFFFFEB 		bl	ControlHandle
 5126              	.LVL412:
 5127 2d08 30309DE5 		ldr	r3, [sp, #48]
 5128 2d0c D5FDFFEA 		b	.L308
 5129              	.L359:
 5130              	.LVL413:
2742:../uvc.c      ****       		ControlHandle(ExtCamMCtlID12);
 5131              		.loc 1 2742 0
 5132 2d10 1C00A0E3 		mov	r0, #28
 5133 2d14 FEFFFFEB 		bl	ControlHandle
 5134              	.LVL414:
 5135 2d18 30309DE5 		ldr	r3, [sp, #48]
 5136 2d1c D1FDFFEA 		b	.L308
 5137              	.L358:
 5138              	.LVL415:
2738:../uvc.c      ****       		ControlHandle(ExtExRefCtlID10);
 5139              		.loc 1 2738 0
 5140 2d20 1A00A0E3 		mov	r0, #26
 5141 2d24 FEFFFFEB 		bl	ControlHandle
 5142              	.LVL416:
 5143 2d28 30309DE5 		ldr	r3, [sp, #48]
 5144 2d2c CDFDFFEA 		b	.L308
 5145              	.L360:
 5146              	.LVL417:
2750:../uvc.c      ****       		ControlHandle(ExtSensorParCtlID14);
 5147              		.loc 1 2750 0
 5148 2d30 1E00A0E3 		mov	r0, #30
 5149 2d34 FEFFFFEB 		bl	ControlHandle
 5150              	.LVL418:
 5151 2d38 30309DE5 		ldr	r3, [sp, #48]
 5152 2d3c C9FDFFEA 		b	.L308
 5153              	.L349:
 5154              	.LVL419:
2699:../uvc.c      ****       		ControlHandle(ExtSenCtlID1);
 5155              		.loc 1 2699 0
 5156 2d40 1100A0E3 		mov	r0, #17
 5157 2d44 FEFFFFEB 		bl	ControlHandle
 5158              	.LVL420:
 5159 2d48 30309DE5 		ldr	r3, [sp, #48]
 5160 2d4c C5FDFFEA 		b	.L308
 5161              	.L356:
 5162              	.LVL421:
2727:../uvc.c      ****       		ControlHandle(ExtNDlevCtlID8);
 5163              		.loc 1 2727 0
 5164 2d50 1800A0E3 		mov	r0, #24
 5165 2d54 FEFFFFEB 		bl	ControlHandle
 5166              	.LVL422:
 5167 2d58 30309DE5 		ldr	r3, [sp, #48]
 5168 2d5c C1FDFFEA 		b	.L308
 5169              	.L351:
 5170              	.LVL423:
2707:../uvc.c      ****       		ControlHandle(Ext3DNReduMCtlID3);
 5171              		.loc 1 2707 0
 5172 2d60 1300A0E3 		mov	r0, #19
 5173 2d64 FEFFFFEB 		bl	ControlHandle
 5174              	.LVL424:
 5175 2d68 30309DE5 		ldr	r3, [sp, #48]
 5176 2d6c BDFDFFEA 		b	.L308
 5177              	.LVL425:
 5178              	.L423:
 5179              	.LBE126:
 5180              	.LBE156:
 5181              	.LBB157:
 5182              	.LBB115:
3037:../uvc.c      ****                         	CyU3PDebugPrint (4, "UVC still trigger control fail %d %d\r\n", readCount,
 5183              		.loc 1 3037 0
 5184 2d70 68109FE5 		ldr	r1, .L453+88
 5185 2d74 B623DDE1 		ldrh	r2, [sp, #54]
 5186 2d78 7C30D4E5 		ldrb	r3, [r4, #124]	@ zero_extendqisi2
 5187 2d7c 0400A0E3 		mov	r0, #4
 5188              	.LVL426:
 5189 2d80 FEFFFFEB 		bl	CyU3PDebugPrint
 5190 2d84 BCFDFFEA 		b	.L373
 5191              	.L454:
 5192              		.align	2
 5193              	.L453:
 5194 2d88 00000000 		.word	.LANCHOR0
 5195 2d8c 00000000 		.word	.LANCHOR1
 5196 2d90 00000000 		.word	bRequest
 5197 2d94 00000000 		.word	wValue
 5198 2d98 00000000 		.word	wIndex
 5199 2d9c 00000000 		.word	glInterStaBuffer
 5200 2da0 E0040000 		.word	.LC26
 5201 2da4 00000000 		.word	glChHandleInterStat
 5202 2da8 00000000 		.word	bmReqType
 5203 2dac 00000000 		.word	wLength
 5204 2db0 64040000 		.word	.LC25
 5205 2db4 7C000000 		.word	.LANCHOR0+124
 5206 2db8 74050000 		.word	.LC29
 5207 2dbc 0C050000 		.word	.LC27
 5208 2dc0 48060000 		.word	.LANCHOR1+1608
 5209 2dc4 54060000 		.word	.LANCHOR1+1620
 5210 2dc8 10060000 		.word	.LANCHOR1+1552
 5211 2dcc 2C060000 		.word	.LANCHOR1+1580
 5212 2dd0 58000000 		.word	.LANCHOR0+88
 5213 2dd4 C4050000 		.word	.LC31
 5214 2dd8 D4010000 		.word	.LC12
 5215 2ddc 4C050000 		.word	.LC28
 5216 2de0 9C050000 		.word	.LC30
 5217              	.LBE115:
 5218              	.LBE157:
 5219              		.cfi_endproc
 5220              	.LFE24:
 5222              		.align	2
 5223              		.global	CamDefSet
 5225              	CamDefSet:
 5226              	.LFB4:
1110:../uvc.c      **** {
 5227              		.loc 1 1110 0
 5228              		.cfi_startproc
 5229              		@ args = 0, pretend = 0, frame = 24
 5230              		@ frame_needed = 0, uses_anonymous_args = 0
 5231              	.LVL427:
 5232 2de4 F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5233              	.LCFI19:
 5234              		.cfi_def_cfa_offset 36
1116:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5235              		.loc 1 1116 0
 5236 2de8 AC429FE5 		ldr	r4, .L458
 5237              		.cfi_offset 14, -4
 5238              		.cfi_offset 11, -8
 5239              		.cfi_offset 10, -12
 5240              		.cfi_offset 9, -16
 5241              		.cfi_offset 8, -20
 5242              		.cfi_offset 7, -24
 5243              		.cfi_offset 6, -28
 5244              		.cfi_offset 5, -32
 5245              		.cfi_offset 4, -36
1121:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5246              		.loc 1 1121 0
 5247 2dec AC229FE5 		ldr	r2, .L458+4
1118:../uvc.c      ****     Data0 = CtrlParArry[CtrlID][11];
 5248              		.loc 1 1118 0
 5249 2df0 A391D4E5 		ldrb	r9, [r4, #419]	@ zero_extendqisi2
1110:../uvc.c      **** {
 5250              		.loc 1 1110 0
 5251 2df4 2CD04DE2 		sub	sp, sp, #44
 5252              	.LCFI20:
 5253              		.cfi_def_cfa_offset 80
1121:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5254              		.loc 1 1121 0
 5255 2df8 1C0092E5 		ldr	r0, [r2, #28]
 5256 2dfc 0010E0E3 		mvn	r1, #0
1123:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5257              		.loc 1 1123 0
 5258 2e00 2963A0E1 		mov	r6, r9, lsr #6
1117:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5259              		.loc 1 1117 0
 5260 2e04 A771D4E5 		ldrb	r7, [r4, #423]	@ zero_extendqisi2
1116:../uvc.c      ****     RegAdd = CtrlParArry[CtrlID][1];
 5261              		.loc 1 1116 0
 5262 2e08 99A1D4E5 		ldrb	sl, [r4, #409]	@ zero_extendqisi2
 5263              	.LVL428:
1121:../uvc.c      ****     CyU3PMutexGet(cmdQuptr->ringMux, CYU3P_WAIT_FOREVER);       //get mutex
 5264              		.loc 1 1121 0
 5265 2e0c FEFFFFEB 		bl	_txe_mutex_get
1122:../uvc.c      ****     if(Data1&0x80){
 5266              		.loc 1 1122 0
 5267 2e10 800019E3 		tst	r9, #128
1123:../uvc.c      ****     	Data1 = (((Data1 >> 6)&0x01)|0xC4);
 5268              		.loc 1 1123 0
 5269 2e14 01600612 		andne	r6, r6, #1
 5270 2e18 0660E011 		mvnne	r6, r6
 5271 2e1c 3B600612 		andne	r6, r6, #59
 5272 2e20 0660E011 		mvnne	r6, r6
 5273 2e24 FF600612 		andne	r6, r6, #255
 5274              	.LVL429:
1125:../uvc.c      ****     	Data1 = (((Data1 >> 6)|0x02)|0xC4);
 5275              		.loc 1 1125 0
 5276 2e28 C6608603 		orreq	r6, r6, #198
 5277              	.LVL430:
1129:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5278              		.loc 1 1129 0
 5279 2e2c 0080A0E3 		mov	r8, #0
 5280 2e30 0A20A0E1 		mov	r2, sl
 5281 2e34 0730A0E1 		mov	r3, r7
 5282 2e38 0110A0E3 		mov	r1, #1
1127:../uvc.c      ****     Data0 = (Data0 << 2);
 5283              		.loc 1 1127 0
 5284 2e3c 0951A0E1 		mov	r5, r9, asl #2
1129:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5285              		.loc 1 1129 0
 5286 2e40 58029FE5 		ldr	r0, .L458+4
1132:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5287              		.loc 1 1132 0
 5288 2e44 0190A0E3 		mov	r9, #1
 5289              	.LVL431:
1127:../uvc.c      ****     Data0 = (Data0 << 2);
 5290              		.loc 1 1127 0
 5291 2e48 FF5005E2 		and	r5, r5, #255
 5292              	.LVL432:
1129:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data1, First); //brightness
 5293              		.loc 1 1129 0
 5294 2e4c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5295 2e50 FEFFFFEB 		bl	cmdSet
 5296              	.LVL433:
1132:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data0, Second);
 5297              		.loc 1 1132 0
 5298 2e54 9821D4E5 		ldrb	r2, [r4, #408]	@ zero_extendqisi2
 5299 2e58 0910A0E1 		mov	r1, r9
 5300 2e5c 0730A0E1 		mov	r3, r7
 5301 2e60 38029FE5 		ldr	r0, .L458+4
 5302 2e64 20028DE8 		stmia	sp, {r5, r9}	@ phole stm
 5303 2e68 FEFFFFEB 		bl	cmdSet
 5304              	.LVL434:
1135:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5305              		.loc 1 1135 0
 5306 2e6c 0620A0E1 		mov	r2, r6
 5307 2e70 0530A0E1 		mov	r3, r5
 5308 2e74 28129FE5 		ldr	r1, .L458+8
 5309 2e78 0400A0E3 		mov	r0, #4
1134:../uvc.c      **** 	CtrlParArry[CtrlID][14] = Data1;
 5310              		.loc 1 1134 0
 5311 2e7c A661C4E5 		strb	r6, [r4, #422]
1133:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5312              		.loc 1 1133 0
 5313 2e80 A551C4E5 		strb	r5, [r4, #421]
1135:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data1, Data0);
 5314              		.loc 1 1135 0
 5315 2e84 FEFFFFEB 		bl	CyU3PDebugPrint
 5316              	.LVL435:
1140:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5317              		.loc 1 1140 0
 5318 2e88 BBB1D4E5 		ldrb	fp, [r4, #443]	@ zero_extendqisi2
 5319              	.LVL436:
1141:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //contrast
 5320              		.loc 1 1141 0
 5321 2e8c B021D4E5 		ldrb	r2, [r4, #432]	@ zero_extendqisi2
 5322 2e90 BF31D4E5 		ldrb	r3, [r4, #447]	@ zero_extendqisi2
 5323 2e94 0210A0E3 		mov	r1, #2
 5324 2e98 00029FE5 		ldr	r0, .L458+4
 5325 2e9c 00B08DE5 		str	fp, [sp, #0]
 5326 2ea0 04808DE5 		str	r8, [sp, #4]
 5327 2ea4 FEFFFFEB 		bl	cmdSet
 5328              	.LVL437:
1143:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5329              		.loc 1 1143 0
 5330 2ea8 0B20A0E1 		mov	r2, fp
 5331 2eac 0530A0E1 		mov	r3, r5
 5332 2eb0 EC119FE5 		ldr	r1, .L458+8
 5333 2eb4 0400A0E3 		mov	r0, #4
1142:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5334              		.loc 1 1142 0
 5335 2eb8 BD51C4E5 		strb	r5, [r4, #445]
1143:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5336              		.loc 1 1143 0
 5337 2ebc FEFFFFEB 		bl	CyU3PDebugPrint
 5338              	.LVL438:
1148:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5339              		.loc 1 1148 0
 5340 2ec0 0372D4E5 		ldrb	r7, [r4, #515]	@ zero_extendqisi2
1147:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5341              		.loc 1 1147 0
 5342 2ec4 0762D4E5 		ldrb	r6, [r4, #519]	@ zero_extendqisi2
 5343              	.LVL439:
1149:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5344              		.loc 1 1149 0
 5345 2ec8 80B047E2 		sub	fp, r7, #128
 5346 2ecc FF100BE2 		and	r1, fp, #255
 5347 2ed0 14108DE5 		str	r1, [sp, #20]
 5348 2ed4 14C09DE5 		ldr	ip, [sp, #20]
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5349              		.loc 1 1150 0
 5350 2ed8 760047E2 		sub	r0, r7, #118
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5351              		.loc 1 1151 0
 5352 2edc 7EE087E2 		add	lr, r7, #126
1149:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5353              		.loc 1 1149 0
 5354 2ee0 0630A0E1 		mov	r3, r6
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5355              		.loc 1 1150 0
 5356 2ee4 18008DE5 		str	r0, [sp, #24]
1149:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5357              		.loc 1 1149 0
 5358 2ee8 0510A0E3 		mov	r1, #5
 5359 2eec DF20A0E3 		mov	r2, #223
 5360 2ef0 A8019FE5 		ldr	r0, .L458+4
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5361              		.loc 1 1151 0
 5362 2ef4 1CE08DE5 		str	lr, [sp, #28]
1149:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegGr, devAdd, (Data-GREEN_BASE), First);
 5363              		.loc 1 1149 0
 5364 2ef8 00C08DE5 		str	ip, [sp, #0]
 5365 2efc 04808DE5 		str	r8, [sp, #4]
 5366 2f00 FEFFFFEB 		bl	cmdSet
 5367              	.LVL440:
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5368              		.loc 1 1150 0
 5369 2f04 18A09DE5 		ldr	sl, [sp, #24]
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5370              		.loc 1 1152 0
 5371 2f08 72E087E2 		add	lr, r7, #114
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5372              		.loc 1 1150 0
 5373 2f0c FFC00AE2 		and	ip, sl, #255
 5374 2f10 0630A0E1 		mov	r3, r6
 5375 2f14 0510A0E3 		mov	r1, #5
 5376 2f18 DC20A0E3 		mov	r2, #220
 5377 2f1c 7C019FE5 		ldr	r0, .L458+4
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5378              		.loc 1 1152 0
 5379 2f20 20E08DE5 		str	lr, [sp, #32]
1150:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegMg, devAdd, (Data-MAGENTA_BASE), Second);
 5380              		.loc 1 1150 0
 5381 2f24 00C08DE5 		str	ip, [sp, #0]
 5382 2f28 04908DE5 		str	r9, [sp, #4]
 5383 2f2c FEFFFFEB 		bl	cmdSet
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5384              		.loc 1 1151 0
 5385 2f30 1C009DE5 		ldr	r0, [sp, #28]
 5386 2f34 02E0A0E3 		mov	lr, #2
 5387 2f38 FFC000E2 		and	ip, r0, #255
 5388 2f3c 0630A0E1 		mov	r3, r6
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5389              		.loc 1 1153 0
 5390 2f40 6FA047E2 		sub	sl, r7, #111
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5391              		.loc 1 1151 0
 5392 2f44 0510A0E3 		mov	r1, #5
 5393 2f48 DE20A0E3 		mov	r2, #222
 5394 2f4c 4C019FE5 		ldr	r0, .L458+4
 5395 2f50 04E08DE5 		str	lr, [sp, #4]
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5396              		.loc 1 1153 0
 5397 2f54 24A08DE5 		str	sl, [sp, #36]
1151:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegYel, devAdd, (Data-YELLOW_BASE), Third);
 5398              		.loc 1 1151 0
 5399 2f58 00C08DE5 		str	ip, [sp, #0]
 5400 2f5c FEFFFFEB 		bl	cmdSet
1152:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegCy, devAdd, (Data-CYAN_BASE), Fourth);
 5401              		.loc 1 1152 0
 5402 2f60 20A09DE5 		ldr	sl, [sp, #32]
 5403 2f64 0630A0E1 		mov	r3, r6
 5404 2f68 FFC00AE2 		and	ip, sl, #255
 5405 2f6c 00C08DE5 		str	ip, [sp, #0]
 5406 2f70 0510A0E3 		mov	r1, #5
 5407 2f74 03C0A0E3 		mov	ip, #3
 5408 2f78 E020A0E3 		mov	r2, #224
 5409 2f7c 1C019FE5 		ldr	r0, .L458+4
 5410 2f80 04C08DE5 		str	ip, [sp, #4]
 5411 2f84 FEFFFFEB 		bl	cmdSet
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5412              		.loc 1 1153 0
 5413 2f88 24009DE5 		ldr	r0, [sp, #36]
 5414 2f8c 04A0A0E3 		mov	sl, #4
 5415 2f90 FFC000E2 		and	ip, r0, #255
 5416 2f94 0630A0E1 		mov	r3, r6
 5417 2f98 0510A0E3 		mov	r1, #5
 5418 2f9c DD20A0E3 		mov	r2, #221
 5419 2fa0 F8009FE5 		ldr	r0, .L458+4
 5420 2fa4 00C08DE5 		str	ip, [sp, #0]
1154:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5421              		.loc 1 1154 0
 5422 2fa8 7F7087E2 		add	r7, r7, #127
 5423              	.LVL441:
1153:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegRed, devAdd, (Data-RED_BASE), Fifth);
 5424              		.loc 1 1153 0
 5425 2fac 04A08DE5 		str	sl, [sp, #4]
 5426 2fb0 FEFFFFEB 		bl	cmdSet
1154:../uvc.c      ****     cmdSet(cmdQuptr, CtrlID, HuectrlRegBlu, devAdd, (Data-BLUE_BASE), Sixth);
 5427              		.loc 1 1154 0
 5428 2fb4 05E0A0E3 		mov	lr, #5
 5429 2fb8 0E10A0E1 		mov	r1, lr
 5430 2fbc 0630A0E1 		mov	r3, r6
 5431 2fc0 E120A0E3 		mov	r2, #225
 5432 2fc4 FF6007E2 		and	r6, r7, #255
 5433              	.LVL442:
 5434 2fc8 D0009FE5 		ldr	r0, .L458+4
 5435 2fcc 40408DE8 		stmia	sp, {r6, lr}	@ phole stm
 5436 2fd0 FEFFFFEB 		bl	cmdSet
 5437              	.LVL443:
1155:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5438              		.loc 1 1155 0
 5439 2fd4 14C09DE5 		ldr	ip, [sp, #20]
1156:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5440              		.loc 1 1156 0
 5441 2fd8 24E09DE5 		ldr	lr, [sp, #36]
 5442 2fdc 1C609DE5 		ldr	r6, [sp, #28]
1155:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data-GREEN_BASE;
 5443              		.loc 1 1155 0
 5444 2fe0 05C2C4E5 		strb	ip, [r4, #517]
1156:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x.\r\n",
 5445              		.loc 1 1156 0
 5446 2fe4 20C09DE5 		ldr	ip, [sp, #32]
 5447 2fe8 0B20A0E1 		mov	r2, fp
 5448 2fec 18309DE5 		ldr	r3, [sp, #24]
 5449 2ff0 B0109FE5 		ldr	r1, .L458+12
 5450 2ff4 0A00A0E1 		mov	r0, sl
 5451 2ff8 40508DE8 		stmia	sp, {r6, ip, lr}	@ phole stm
 5452 2ffc 0C708DE5 		str	r7, [sp, #12]
 5453 3000 FEFFFFEB 		bl	CyU3PDebugPrint
 5454              	.LVL444:
1160:../uvc.c      ****     devAdd = CtrlParArry[CtrlID][15];
 5455              		.loc 1 1160 0
 5456 3004 1F72D4E5 		ldrb	r7, [r4, #543]	@ zero_extendqisi2
 5457              	.LVL445:
1161:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5458              		.loc 1 1161 0
 5459 3008 1B62D4E5 		ldrb	r6, [r4, #539]	@ zero_extendqisi2
 5460              	.LVL446:
1162:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegR, devAdd, Data, First); //saturation
 5461              		.loc 1 1162 0
 5462 300c 0730A0E1 		mov	r3, r7
 5463 3010 0610A0E3 		mov	r1, #6
 5464 3014 8520A0E3 		mov	r2, #133
 5465 3018 80009FE5 		ldr	r0, .L458+4
 5466 301c 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5467 3020 FEFFFFEB 		bl	cmdSet
1163:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, SaturationRegB, devAdd, Data, Second); //saturation
 5468              		.loc 1 1163 0
 5469 3024 0730A0E1 		mov	r3, r7
 5470 3028 0610A0E3 		mov	r1, #6
 5471 302c 8620A0E3 		mov	r2, #134
 5472 3030 68009FE5 		ldr	r0, .L458+4
 5473 3034 40028DE8 		stmia	sp, {r6, r9}	@ phole stm
 5474 3038 FEFFFFEB 		bl	cmdSet
1165:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5475              		.loc 1 1165 0
 5476 303c 0620A0E1 		mov	r2, r6
 5477 3040 0530A0E1 		mov	r3, r5
 5478 3044 58109FE5 		ldr	r1, .L458+8
 5479 3048 0A00A0E1 		mov	r0, sl
1164:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data;
 5480              		.loc 1 1164 0
 5481 304c 1D62C4E5 		strb	r6, [r4, #541]
1165:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5482              		.loc 1 1165 0
 5483 3050 FEFFFFEB 		bl	CyU3PDebugPrint
 5484              	.LVL447:
1170:../uvc.c      ****     Data = CtrlParArry[CtrlID][11];
 5485              		.loc 1 1170 0
 5486 3054 3362D4E5 		ldrb	r6, [r4, #563]	@ zero_extendqisi2
 5487              	.LVL448:
1171:../uvc.c      **** 	cmdSet(cmdQuptr, CtrlID, RegAdd, devAdd, Data, First); //shapness
 5488              		.loc 1 1171 0
 5489 3058 2822D4E5 		ldrb	r2, [r4, #552]	@ zero_extendqisi2
 5490 305c 3732D4E5 		ldrb	r3, [r4, #567]	@ zero_extendqisi2
 5491 3060 0710A0E3 		mov	r1, #7
 5492 3064 34009FE5 		ldr	r0, .L458+4
 5493 3068 40018DE8 		stmia	sp, {r6, r8}	@ phole stm
 5494 306c FEFFFFEB 		bl	cmdSet
 5495              	.LVL449:
1173:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5496              		.loc 1 1173 0
 5497 3070 0530A0E1 		mov	r3, r5
 5498 3074 0A00A0E1 		mov	r0, sl
 5499 3078 24109FE5 		ldr	r1, .L458+8
 5500 307c 0620A0E1 		mov	r2, r6
1172:../uvc.c      **** 	CtrlParArry[CtrlID][13] = Data0;
 5501              		.loc 1 1172 0
 5502 3080 3552C4E5 		strb	r5, [r4, #565]
1173:../uvc.c      **** 	CyU3PDebugPrint (4, "The set def data 0x%x, 0x%x.\r\n", Data, Data0);
 5503              		.loc 1 1173 0
 5504 3084 FEFFFFEB 		bl	CyU3PDebugPrint
1175:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5505              		.loc 1 1175 0
 5506 3088 10309FE5 		ldr	r3, .L458+4
 5507 308c 1C0093E5 		ldr	r0, [r3, #28]
1178:../uvc.c      **** }
 5508              		.loc 1 1178 0
 5509 3090 2CD08DE2 		add	sp, sp, #44
 5510 3094 F04FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
1175:../uvc.c      **** 	CyU3PMutexPut(cmdQuptr->ringMux);  //release the command queue mutex
 5511              		.loc 1 1175 0
 5512 3098 FEFFFFEA 		b	_txe_mutex_put
 5513              	.L459:
 5514              		.align	2
 5515              	.L458:
 5516 309c 00000000 		.word	.LANCHOR1
 5517 30a0 00000000 		.word	cmdQu
 5518 30a4 F8050000 		.word	.LC32
 5519 30a8 18060000 		.word	.LC33
 5520              		.cfi_endproc
 5521              	.LFE4:
 5523              		.align	2
 5524              		.global	CyFxUVCAddHeader
 5526              	CyFxUVCAddHeader:
 5527              	.LFB5:
1186:../uvc.c      **** {
 5528              		.loc 1 1186 0
 5529              		.cfi_startproc
 5530              		@ args = 0, pretend = 0, frame = 0
 5531              		@ frame_needed = 0, uses_anonymous_args = 0
 5532              	.LVL450:
 5533 30ac 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 5534              	.LCFI21:
 5535              		.cfi_def_cfa_offset 16
1188:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5536              		.loc 1 1188 0
 5537 30b0 0C20A0E3 		mov	r2, #12
1186:../uvc.c      **** {
 5538              		.loc 1 1186 0
 5539 30b4 0150A0E1 		mov	r5, r1
 5540              		.cfi_offset 14, -4
 5541              		.cfi_offset 5, -8
 5542              		.cfi_offset 4, -12
 5543              		.cfi_offset 3, -16
1188:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5544              		.loc 1 1188 0
 5545 30b8 18109FE5 		ldr	r1, .L462
 5546              	.LVL451:
1186:../uvc.c      **** {
 5547              		.loc 1 1186 0
 5548 30bc 0040A0E1 		mov	r4, r0
1188:../uvc.c      ****     CyU3PMemCopy (buffer_p, (uint8_t *)glUVCHeader, CY_FX_UVC_MAX_HEADER);
 5549              		.loc 1 1188 0
 5550 30c0 FEFFFFEB 		bl	CyU3PMemCopy
 5551              	.LVL452:
1191:../uvc.c      ****     if (frameInd & CY_FX_UVC_HEADER_EOF)
 5552              		.loc 1 1191 0
 5553 30c4 020015E3 		tst	r5, #2
1193:../uvc.c      ****         buffer_p[1] |= CY_FX_UVC_HEADER_EOF;
 5554              		.loc 1 1193 0
 5555 30c8 0130D415 		ldrneb	r3, [r4, #1]	@ zero_extendqisi2
 5556 30cc 02308313 		orrne	r3, r3, #2
 5557 30d0 0130C415 		strneb	r3, [r4, #1]
 5558 30d4 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 5559              	.L463:
 5560              		.align	2
 5561              	.L462:
 5562 30d8 80040000 		.word	.LANCHOR1+1152
 5563              		.cfi_endproc
 5564              	.LFE5:
 5566              		.align	2
 5567              		.global	CyFxAppErrorHandler
 5569              	CyFxAppErrorHandler:
 5570              	.LFB6:
1203:../uvc.c      **** {
 5571              		.loc 1 1203 0
 5572              		.cfi_startproc
 5573              		@ args = 0, pretend = 0, frame = 0
 5574              		@ frame_needed = 0, uses_anonymous_args = 0
 5575              	.LVL453:
 5576 30dc 08402DE9 		stmfd	sp!, {r3, lr}
 5577              	.LCFI22:
 5578              		.cfi_def_cfa_offset 8
 5579              	.LVL454:
 5580              	.L465:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 5581              		.loc 1 1213 0 discriminator 1
 5582 30e0 10109FE5 		ldr	r1, .L466
 5583 30e4 0400A0E3 		mov	r0, #4
 5584              		.cfi_offset 14, -4
 5585              		.cfi_offset 3, -8
 5586 30e8 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 5587              		.loc 1 1214 0 discriminator 1
 5588 30ec FA0FA0E3 		mov	r0, #1000
 5589 30f0 FEFFFFEB 		bl	_tx_thread_sleep
 5590 30f4 F9FFFFEA 		b	.L465
 5591              	.L467:
 5592              		.align	2
 5593              	.L466:
 5594 30f8 D4010000 		.word	.LC12
 5595              		.cfi_endproc
 5596              	.LFE6:
 5598              		.align	2
 5599              		.global	UVCAppThread_Entry
 5601              	UVCAppThread_Entry:
 5602              	.LFB18:
2157:../uvc.c      **** {
 5603              		.loc 1 2157 0
 5604              		.cfi_startproc
 5605              		@ args = 0, pretend = 0, frame = 176
 5606              		@ frame_needed = 0, uses_anonymous_args = 0
 5607              	.LVL455:
 5608 30fc F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 5609              	.LCFI23:
 5610              		.cfi_def_cfa_offset 28
 5611 3100 BCD04DE2 		sub	sp, sp, #188
 5612              	.LCFI24:
 5613              		.cfi_def_cfa_offset 216
 5614              	.LBB210:
 5615              	.LBB211:
1615:../uvc.c      ****     apiRetStatus = CyU3PUartInit ();
 5616              		.loc 1 1615 0
 5617              		.cfi_offset 14, -4
 5618              		.cfi_offset 10, -8
 5619              		.cfi_offset 8, -12
 5620              		.cfi_offset 7, -16
 5621              		.cfi_offset 6, -20
 5622              		.cfi_offset 5, -24
 5623              		.cfi_offset 4, -28
 5624 3104 FEFFFFEB 		bl	CyU3PUartInit
 5625              	.LVL456:
1616:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5626              		.loc 1 1616 0
 5627 3108 004050E2 		subs	r4, r0, #0
 5628 310c 0400000A 		beq	.L469
1618:../uvc.c      ****         CyU3PDebugPrint (4, "UART initialization failed!\n");
 5629              		.loc 1 1618 0
 5630 3110 0400A0E3 		mov	r0, #4
 5631              	.LVL457:
 5632 3114 A81A9FE5 		ldr	r1, .L559
 5633 3118 FEFFFFEB 		bl	CyU3PDebugPrint
1619:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5634              		.loc 1 1619 0
 5635 311c 0400A0E1 		mov	r0, r4
 5636 3120 FEFFFFEB 		bl	CyFxAppErrorHandler
 5637              	.L469:
1623:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5638              		.loc 1 1623 0
 5639 3124 9CCA9FE5 		ldr	ip, .L559+4
1625:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5640              		.loc 1 1625 0
 5641 3128 0030A0E3 		mov	r3, #0
1624:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5642              		.loc 1 1624 0
 5643 312c 0120A0E3 		mov	r2, #1
1632:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5644              		.loc 1 1632 0
 5645 3130 50008DE2 		add	r0, sp, #80
 5646 3134 0310A0E1 		mov	r1, r3
1623:../uvc.c      ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 5647              		.loc 1 1623 0
 5648 3138 60C08DE5 		str	ip, [sp, #96]
1624:../uvc.c      ****     uartConfig.stopBit  = CY_U3P_UART_ONE_STOP_BIT;
 5649              		.loc 1 1624 0
 5650 313c 6420CDE5 		strb	r2, [sp, #100]
1625:../uvc.c      ****     uartConfig.parity   = CY_U3P_UART_NO_PARITY;
 5651              		.loc 1 1625 0
 5652 3140 6530CDE5 		strb	r3, [sp, #101]
1626:../uvc.c      ****     uartConfig.txEnable = CyTrue;
 5653              		.loc 1 1626 0
 5654 3144 50208DE5 		str	r2, [sp, #80]
1627:../uvc.c      ****     uartConfig.rxEnable = CyFalse;
 5655              		.loc 1 1627 0
 5656 3148 54308DE5 		str	r3, [sp, #84]
1628:../uvc.c      ****     uartConfig.flowCtrl = CyFalse;
 5657              		.loc 1 1628 0
 5658 314c 58308DE5 		str	r3, [sp, #88]
1629:../uvc.c      ****     uartConfig.isDma    = CyTrue;
 5659              		.loc 1 1629 0
 5660 3150 5C208DE5 		str	r2, [sp, #92]
1632:../uvc.c      ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 5661              		.loc 1 1632 0
 5662 3154 FEFFFFEB 		bl	CyU3PUartSetConfig
 5663              	.LVL458:
1633:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5664              		.loc 1 1633 0
 5665 3158 000050E3 		cmp	r0, #0
 5666 315c 0000000A 		beq	.L470
1635:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5667              		.loc 1 1635 0
 5668 3160 FEFFFFEB 		bl	CyFxAppErrorHandler
 5669              	.LVL459:
 5670              	.L470:
1639:../uvc.c      ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 5671              		.loc 1 1639 0
 5672 3164 0000E0E3 		mvn	r0, #0
 5673 3168 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 5674              	.LVL460:
1640:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5675              		.loc 1 1640 0
 5676 316c 000050E3 		cmp	r0, #0
 5677 3170 0000000A 		beq	.L471
1642:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5678              		.loc 1 1642 0
 5679 3174 FEFFFFEB 		bl	CyFxAppErrorHandler
 5680              	.LVL461:
 5681              	.L471:
1646:../uvc.c      ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 4);
 5682              		.loc 1 1646 0
 5683 3178 0300A0E3 		mov	r0, #3
 5684 317c 0410A0E3 		mov	r1, #4
 5685 3180 FEFFFFEB 		bl	CyU3PDebugInit
 5686              	.LVL462:
1647:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5687              		.loc 1 1647 0
 5688 3184 000050E3 		cmp	r0, #0
 5689 3188 0000000A 		beq	.L472
1649:../uvc.c      ****         CyFxAppErrorHandler (apiRetStatus);
 5690              		.loc 1 1649 0
 5691 318c FEFFFFEB 		bl	CyFxAppErrorHandler
 5692              	.LVL463:
 5693              	.L472:
1653:../uvc.c      ****     CyU3PDebugPreamble (CyFalse);
 5694              		.loc 1 1653 0
 5695 3190 0000A0E3 		mov	r0, #0
 5696 3194 FEFFFFEB 		bl	CyU3PDebugPreamble
 5697              	.LVL464:
 5698              	.LBE211:
 5699              	.LBE210:
2172:../uvc.c      **** 		CyU3PThreadSleep(500);
 5700              		.loc 1 2172 0
 5701 3198 7D0FA0E3 		mov	r0, #500
 5702 319c FEFFFFEB 		bl	_tx_thread_sleep
 5703              	.LVL465:
 5704 31a0 7D0FA0E3 		mov	r0, #500
 5705 31a4 FEFFFFEB 		bl	_tx_thread_sleep
 5706 31a8 7D0FA0E3 		mov	r0, #500
 5707 31ac FEFFFFEB 		bl	_tx_thread_sleep
 5708 31b0 7D0FA0E3 		mov	r0, #500
 5709 31b4 FEFFFFEB 		bl	_tx_thread_sleep
 5710 31b8 7D0FA0E3 		mov	r0, #500
 5711 31bc FEFFFFEB 		bl	_tx_thread_sleep
 5712 31c0 7D0FA0E3 		mov	r0, #500
 5713 31c4 FEFFFFEB 		bl	_tx_thread_sleep
 5714              	.LBB212:
 5715              	.LBB213:
1663:../uvc.c      ****     status = CyU3PI2cInit ();
 5716              		.loc 1 1663 0
 5717 31c8 FEFFFFEB 		bl	CyU3PI2cInit
 5718              	.LVL466:
1664:../uvc.c      ****     if (status != CY_U3P_SUCCESS)
 5719              		.loc 1 1664 0
 5720 31cc 004050E2 		subs	r4, r0, #0
 5721 31d0 0400000A 		beq	.L473
1666:../uvc.c      ****         CyU3PDebugPrint (4, "I2C initialization failed!\n");
 5722              		.loc 1 1666 0
 5723 31d4 0400A0E3 		mov	r0, #4
 5724              	.LVL467:
 5725 31d8 EC199FE5 		ldr	r1, .L559+8
 5726 31dc FEFFFFEB 		bl	CyU3PDebugPrint
1667:../uvc.c      ****         CyFxAppErrorHandler (status);
 5727              		.loc 1 1667 0
 5728 31e0 0400A0E1 		mov	r0, r4
 5729 31e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 5730              	.L473:
1671:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5731              		.loc 1 1671 0
 5732 31e8 E0699FE5 		ldr	r6, .L559+12
1672:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5733              		.loc 1 1672 0
 5734 31ec 0050A0E3 		mov	r5, #0
1673:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5735              		.loc 1 1673 0
 5736 31f0 0040E0E3 		mvn	r4, #0
 5737              	.LVL468:
1676:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5738              		.loc 1 1676 0
 5739 31f4 8C008DE2 		add	r0, sp, #140
 5740 31f8 0510A0E1 		mov	r1, r5
1673:../uvc.c      ****     i2cConfig.busTimeout = 0xffffffffU;
 5741              		.loc 1 1673 0
 5742 31fc 94408DE5 		str	r4, [sp, #148]
1674:../uvc.c      ****     i2cConfig.dmaTimeout = 0xffff;
 5743              		.loc 1 1674 0
 5744 3200 B849CDE1 		strh	r4, [sp, #152]	@ movhi
1671:../uvc.c      ****     i2cConfig.bitRate    = 100000;      /*  100 KHz */
 5745              		.loc 1 1671 0
 5746 3204 8C608DE5 		str	r6, [sp, #140]
1672:../uvc.c      ****     i2cConfig.isDma      = CyFalse;
 5747              		.loc 1 1672 0
 5748 3208 90508DE5 		str	r5, [sp, #144]
1676:../uvc.c      ****     status = CyU3PI2cSetConfig (&i2cConfig, 0);
 5749              		.loc 1 1676 0
 5750 320c FEFFFFEB 		bl	CyU3PI2cSetConfig
 5751              	.LVL469:
1677:../uvc.c      ****     if (CY_U3P_SUCCESS != status)
 5752              		.loc 1 1677 0
 5753 3210 004050E2 		subs	r4, r0, #0
 5754 3214 0400000A 		beq	.L474
1679:../uvc.c      ****         CyU3PDebugPrint (4, "I2C configuration failed!\n");
 5755              		.loc 1 1679 0
 5756 3218 0400A0E3 		mov	r0, #4
 5757              	.LVL470:
 5758 321c B0199FE5 		ldr	r1, .L559+16
 5759 3220 FEFFFFEB 		bl	CyU3PDebugPrint
1680:../uvc.c      ****         CyFxAppErrorHandler (status);
 5760              		.loc 1 1680 0
 5761 3224 0400A0E1 		mov	r0, r4
 5762 3228 FEFFFFEB 		bl	CyFxAppErrorHandler
 5763              	.L474:
 5764              	.LBE213:
 5765              	.LBE212:
 5766              	.LBB214:
 5767              	.LBB217:
1750:../uvc.c      ****     apiRetStatus = CyU3PEventCreate (&glFxUVCEvent);
 5768              		.loc 1 1750 0
 5769 322c A4699FE5 		ldr	r6, .L559+20
 5770 3230 2820A0E3 		mov	r2, #40
 5771 3234 0010A0E3 		mov	r1, #0
 5772 3238 0600A0E1 		mov	r0, r6
 5773 323c FEFFFFEB 		bl	_txe_event_flags_create
 5774              	.LVL471:
1751:../uvc.c      ****     if (apiRetStatus != 0)
 5775              		.loc 1 1751 0
 5776 3240 002050E2 		subs	r2, r0, #0
 5777 3244 F200001A 		bne	.L536
1765:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5778              		.loc 1 1765 0
 5779 3248 0250A0E3 		mov	r5, #2
1772:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5780              		.loc 1 1772 0
 5781 324c 0210A0E1 		mov	r1, r2
1761:../uvc.c      ****     isUsbConnected = CyFalse;
 5782              		.loc 1 1761 0
 5783 3250 3C2086E5 		str	r2, [r6, #60]
1762:../uvc.c      ****     clearFeatureRqtReceived = CyFalse;
 5784              		.loc 1 1762 0
 5785 3254 402086E5 		str	r2, [r6, #64]
1768:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5786              		.loc 1 1768 0
 5787 3258 0370A0E3 		mov	r7, #3
1772:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5788              		.loc 1 1772 0
 5789 325c 9C008DE2 		add	r0, sp, #156
 5790              	.LVL472:
1767:../uvc.c      ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_2;
 5791              		.loc 1 1767 0
 5792 3260 A420CDE5 		strb	r2, [sp, #164]
1769:../uvc.c      ****     gpioClock.halfDiv    = 0;
 5793              		.loc 1 1769 0
 5794 3264 A0208DE5 		str	r2, [sp, #160]
1765:../uvc.c      ****     gpioClock.fastClkDiv = 2;
 5795              		.loc 1 1765 0
 5796 3268 9C50CDE5 		strb	r5, [sp, #156]
1766:../uvc.c      ****     gpioClock.slowClkDiv = 2;
 5797              		.loc 1 1766 0
 5798 326c 9D50CDE5 		strb	r5, [sp, #157]
1768:../uvc.c      ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK;
 5799              		.loc 1 1768 0
 5800 3270 A570CDE5 		strb	r7, [sp, #165]
1772:../uvc.c      ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 5801              		.loc 1 1772 0
 5802 3274 FEFFFFEB 		bl	CyU3PGpioInit
 5803              	.LVL473:
1773:../uvc.c      ****     if (apiRetStatus != 0)
 5804              		.loc 1 1773 0
 5805 3278 002050E2 		subs	r2, r0, #0
 5806 327c F600001A 		bne	.L537
1781:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_RESET_GPIO, CyTrue);
 5807              		.loc 1 1781 0
 5808 3280 1600A0E3 		mov	r0, #22
 5809              	.LVL474:
 5810 3284 0110A0E3 		mov	r1, #1
 5811 3288 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5812              	.LVL475:
1782:../uvc.c      ****     if (apiRetStatus != 0)
 5813              		.loc 1 1782 0
 5814 328c 002050E2 		subs	r2, r0, #0
 5815 3290 E800001A 		bne	.L538
1787:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_POWER_GPIO, CyTrue);
 5816              		.loc 1 1787 0
 5817 3294 1400A0E3 		mov	r0, #20
 5818              	.LVL476:
 5819 3298 0110A0E3 		mov	r1, #1
 5820 329c FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5821              	.LVL477:
1788:../uvc.c      ****     if (apiRetStatus != 0)
 5822              		.loc 1 1788 0
 5823 32a0 002050E2 		subs	r2, r0, #0
 5824 32a4 F500001A 		bne	.L539
1793:../uvc.c      ****     apiRetStatus = CyU3PDeviceGpioOverride (SENSOR_SNAPSHOT_GPIO, CyTrue);
 5825              		.loc 1 1793 0
 5826 32a8 1800A0E3 		mov	r0, #24
 5827              	.LVL478:
 5828 32ac 0110A0E3 		mov	r1, #1
 5829 32b0 FEFFFFEB 		bl	CyU3PDeviceGpioOverride
 5830              	.LVL479:
1794:../uvc.c      ****     if (apiRetStatus != 0)
 5831              		.loc 1 1794 0
 5832 32b4 002050E2 		subs	r2, r0, #0
 5833 32b8 F401001A 		bne	.L540
1801:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5834              		.loc 1 1801 0
 5835 32bc 0140A0E3 		mov	r4, #1
 5836              	.LVL480:
1806:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5837              		.loc 1 1806 0
 5838 32c0 1600A0E3 		mov	r0, #22
 5839              	.LVL481:
 5840 32c4 68108DE2 		add	r1, sp, #104
1804:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5841              		.loc 1 1804 0
 5842 32c8 74208DE5 		str	r2, [sp, #116]
1805:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5843              		.loc 1 1805 0
 5844 32cc 7820CDE5 		strb	r2, [sp, #120]
1801:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5845              		.loc 1 1801 0
 5846 32d0 68408DE5 		str	r4, [sp, #104]
1802:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5847              		.loc 1 1802 0
 5848 32d4 6C408DE5 		str	r4, [sp, #108]
1803:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5849              		.loc 1 1803 0
 5850 32d8 70408DE5 		str	r4, [sp, #112]
1806:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_RESET_GPIO, &gpioConfig);
 5851              		.loc 1 1806 0
 5852 32dc FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5853              	.LVL482:
1807:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5854              		.loc 1 1807 0
 5855 32e0 002050E2 		subs	r2, r0, #0
 5856 32e4 E001001A 		bne	.L541
1820:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5857              		.loc 1 1820 0
 5858 32e8 1400A0E3 		mov	r0, #20
 5859              	.LVL483:
 5860 32ec 68108DE2 		add	r1, sp, #104
1818:../uvc.c      ****     gpioConfig.inputEn     = CyFalse;
 5861              		.loc 1 1818 0
 5862 32f0 74208DE5 		str	r2, [sp, #116]
1819:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5863              		.loc 1 1819 0
 5864 32f4 7820CDE5 		strb	r2, [sp, #120]
1815:../uvc.c      ****     gpioConfig.outValue    = CyTrue;
 5865              		.loc 1 1815 0
 5866 32f8 68408DE5 		str	r4, [sp, #104]
1816:../uvc.c      ****     gpioConfig.driveLowEn  = CyTrue;
 5867              		.loc 1 1816 0
 5868 32fc 6C408DE5 		str	r4, [sp, #108]
1817:../uvc.c      ****     gpioConfig.driveHighEn = CyTrue;
 5869              		.loc 1 1817 0
 5870 3300 70408DE5 		str	r4, [sp, #112]
1820:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_POWER_GPIO, &gpioConfig);
 5871              		.loc 1 1820 0
 5872 3304 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5873              	.LVL484:
1821:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5874              		.loc 1 1821 0
 5875 3308 002050E2 		subs	r2, r0, #0
 5876 330c E801001A 		bne	.L542
1834:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5877              		.loc 1 1834 0
 5878 3310 1800A0E3 		mov	r0, #24
 5879              	.LVL485:
 5880 3314 68108DE2 		add	r1, sp, #104
1829:../uvc.c      ****     gpioConfig.outValue    = CyFalse;
 5881              		.loc 1 1829 0
 5882 3318 68208DE5 		str	r2, [sp, #104]
1830:../uvc.c      ****     gpioConfig.driveLowEn  = CyFalse;
 5883              		.loc 1 1830 0
 5884 331c 6C208DE5 		str	r2, [sp, #108]
1831:../uvc.c      ****     gpioConfig.driveHighEn = CyFalse;
 5885              		.loc 1 1831 0
 5886 3320 70208DE5 		str	r2, [sp, #112]
1833:../uvc.c      ****     gpioConfig.intrMode    = CY_U3P_GPIO_NO_INTR;
 5887              		.loc 1 1833 0
 5888 3324 7820CDE5 		strb	r2, [sp, #120]
1832:../uvc.c      ****     gpioConfig.inputEn     = CyTrue;
 5889              		.loc 1 1832 0
 5890 3328 74408DE5 		str	r4, [sp, #116]
1834:../uvc.c      ****     apiRetStatus           = CyU3PGpioSetSimpleConfig (SENSOR_SNAPSHOT_GPIO, &gpioConfig);
 5891              		.loc 1 1834 0
 5892 332c FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 5893              	.LVL486:
1835:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5894              		.loc 1 1835 0
 5895 3330 002050E2 		subs	r2, r0, #0
 5896 3334 C301001A 		bne	.L543
1847:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5897              		.loc 1 1847 0
 5898 3338 0400A0E1 		mov	r0, r4
 5899              	.LVL487:
 5900 333c 7C108DE2 		add	r1, sp, #124
1844:../uvc.c      ****     pibclock.isDllEnable = CyFalse;
 5901              		.loc 1 1844 0
 5902 3340 84208DE5 		str	r2, [sp, #132]
1845:../uvc.c      ****     pibclock.isHalfDiv   = CyFalse;
 5903              		.loc 1 1845 0
 5904 3344 80208DE5 		str	r2, [sp, #128]
1842:../uvc.c      ****     pibclock.clkDiv      = 2;
 5905              		.loc 1 1842 0
 5906 3348 BC57CDE1 		strh	r5, [sp, #124]	@ movhi
1843:../uvc.c      ****     pibclock.clkSrc      = CY_U3P_SYS_CLK;
 5907              		.loc 1 1843 0
 5908 334c 8870CDE5 		strb	r7, [sp, #136]
1847:../uvc.c      ****     apiRetStatus = CyU3PPibInit (CyTrue, &pibclock);
 5909              		.loc 1 1847 0
 5910 3350 FEFFFFEB 		bl	CyU3PPibInit
 5911              	.LVL488:
1848:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5912              		.loc 1 1848 0
 5913 3354 002050E2 		subs	r2, r0, #0
 5914 3358 B101001A 		bne	.L544
1855:../uvc.c      ****     CyU3PGpifRegisterCallback (CyFxGpifCB);
 5915              		.loc 1 1855 0
 5916 335c 78089FE5 		ldr	r0, .L559+24
 5917              	.LVL489:
 5918 3360 FEFFFFEB 		bl	CyU3PGpifRegisterCallback
 5919              	.LVL490:
1863:../uvc.c      ****     SensorReset ();
 5920              		.loc 1 1863 0
 5921 3364 FEFFFFEB 		bl	SensorReset
1864:../uvc.c      ****     SensorInit ();
 5922              		.loc 1 1864 0
 5923 3368 FEFFFFEB 		bl	SensorInit
1867:../uvc.c      ****     apiRetStatus = CyU3PUsbStart ();
 5924              		.loc 1 1867 0
 5925 336c FEFFFFEB 		bl	CyU3PUsbStart
 5926              	.LVL491:
1868:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 5927              		.loc 1 1868 0
 5928 3370 002050E2 		subs	r2, r0, #0
 5929 3374 A101001A 		bne	.L545
1874:../uvc.c      ****     CyU3PUsbRegisterSetupCallback (CyFxUVCApplnUSBSetupCB, CyFalse);
 5930              		.loc 1 1874 0
 5931 3378 0010A0E3 		mov	r1, #0
 5932 337c 5C089FE5 		ldr	r0, .L559+28
 5933              	.LVL492:
 5934 3380 FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 5935              	.LVL493:
1877:../uvc.c      ****     CyU3PUsbRegisterEventCallback (CyFxUVCApplnUSBEventCB);
 5936              		.loc 1 1877 0
 5937 3384 58089FE5 		ldr	r0, .L559+32
 5938 3388 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
1883:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscr);
 5939              		.loc 1 1883 0
 5940 338c 0010A0E3 		mov	r1, #0
 5941 3390 50289FE5 		ldr	r2, .L559+36
 5942 3394 0100A0E3 		mov	r0, #1
 5943 3398 FEFFFFEB 		bl	CyU3PUsbSetDesc
1884:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSBDeviceDscrSS);
 5944              		.loc 1 1884 0
 5945 339c 0000A0E3 		mov	r0, #0
 5946 33a0 0010A0E1 		mov	r1, r0
 5947 33a4 40289FE5 		ldr	r2, .L559+40
 5948 33a8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1887:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQualDscr);
 5949              		.loc 1 1887 0
 5950 33ac 0010A0E3 		mov	r1, #0
 5951 33b0 38289FE5 		ldr	r2, .L559+44
 5952 33b4 0200A0E3 		mov	r0, #2
 5953 33b8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1888:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 5954              		.loc 1 1888 0
 5955 33bc 0010A0E3 		mov	r1, #0
 5956 33c0 2C289FE5 		ldr	r2, .L559+48
 5957 33c4 0700A0E3 		mov	r0, #7
 5958 33c8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1891:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfigDscr);
 5959              		.loc 1 1891 0
 5960 33cc 0010A0E3 		mov	r1, #0
 5961 33d0 20289FE5 		ldr	r2, .L559+52
 5962 33d4 0400A0E3 		mov	r0, #4
 5963 33d8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1892:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfigDscr);
 5964              		.loc 1 1892 0
 5965 33dc 0010A0E3 		mov	r1, #0
 5966 33e0 14289FE5 		ldr	r2, .L559+56
 5967 33e4 0300A0E3 		mov	r0, #3
 5968 33e8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1893:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfigDscr);
 5969              		.loc 1 1893 0
 5970 33ec 0010A0E3 		mov	r1, #0
 5971 33f0 08289FE5 		ldr	r2, .L559+60
 5972 33f4 0600A0E3 		mov	r0, #6
 5973 33f8 FEFFFFEB 		bl	CyU3PUsbSetDesc
1896:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDscr);
 5974              		.loc 1 1896 0
 5975 33fc 0010A0E3 		mov	r1, #0
 5976 3400 FC279FE5 		ldr	r2, .L559+64
 5977 3404 0500A0E3 		mov	r0, #5
 5978 3408 FEFFFFEB 		bl	CyU3PUsbSetDesc
1897:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDscr);
 5979              		.loc 1 1897 0
 5980 340c 0110A0E3 		mov	r1, #1
 5981 3410 F0279FE5 		ldr	r2, .L559+68
 5982 3414 0500A0E3 		mov	r0, #5
 5983 3418 FEFFFFEB 		bl	CyU3PUsbSetDesc
1898:../uvc.c      ****     CyU3PUsbSetDesc (CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 5984              		.loc 1 1898 0
 5985 341c 0210A0E3 		mov	r1, #2
 5986 3420 E4279FE5 		ldr	r2, .L559+72
 5987 3424 0500A0E3 		mov	r0, #5
 5988 3428 FEFFFFEB 		bl	CyU3PUsbSetDesc
1908:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 5989              		.loc 1 1908 0
 5990 342c 0070A0E3 		mov	r7, #0
1905:../uvc.c      ****     endPointConfig.enable   = 1;
 5991              		.loc 1 1905 0
 5992 3430 0140A0E3 		mov	r4, #1
1906:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 5993              		.loc 1 1906 0
 5994 3434 03A0A0E3 		mov	sl, #3
1911:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 5995              		.loc 1 1911 0
 5996 3438 8200A0E3 		mov	r0, #130
 5997 343c A8108DE2 		add	r1, sp, #168
1907:../uvc.c      ****     endPointConfig.pcktSize = 64;
 5998              		.loc 1 1907 0
 5999 3440 4080A0E3 		mov	r8, #64	@ movhi
1906:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_INTR;
 6000              		.loc 1 1906 0
 6001 3444 ACA0CDE5 		strb	sl, [sp, #172]
1905:../uvc.c      ****     endPointConfig.enable   = 1;
 6002              		.loc 1 1905 0
 6003 3448 A8408DE5 		str	r4, [sp, #168]
1907:../uvc.c      ****     endPointConfig.pcktSize = 64;
 6004              		.loc 1 1907 0
 6005 344c B08BCDE1 		strh	r8, [sp, #176]	@ movhi
1908:../uvc.c      ****     endPointConfig.isoPkts  = 0;
 6006              		.loc 1 1908 0
 6007 3450 B370CDE5 		strb	r7, [sp, #179]
1909:../uvc.c      ****     endPointConfig.streams  = 0;
 6008              		.loc 1 1909 0
 6009 3454 BE7ACDE1 		strh	r7, [sp, #174]	@ movhi
1910:../uvc.c      ****     endPointConfig.burstLen = 1;
 6010              		.loc 1 1910 0
 6011 3458 B240CDE5 		strb	r4, [sp, #178]
1911:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_CONTROL_STATUS, &endPointConfig);
 6012              		.loc 1 1911 0
 6013 345c FEFFFFEB 		bl	CyU3PSetEpConfig
 6014              	.LVL494:
1909:../uvc.c      ****     endPointConfig.streams  = 0;
 6015              		.loc 1 1909 0
 6016 3460 07A0A0E1 		mov	sl, r7	@ movhi
1912:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6017              		.loc 1 1912 0
 6018 3464 003050E2 		subs	r3, r0, #0
 6019 3468 5A01001A 		bne	.L546
1922:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6020              		.loc 1 1922 0
 6021 346c 9CC79FE5 		ldr	ip, .L559+76
1923:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6022              		.loc 1 1923 0
 6023 3470 9CE79FE5 		ldr	lr, .L559+80
1920:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6024              		.loc 1 1920 0
 6025 3474 015BA0E3 		mov	r5, #1024	@ movhi
1929:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6026              		.loc 1 1929 0
 6027 3478 1070A0E3 		mov	r7, #16
1931:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6028              		.loc 1 1931 0
 6029 347c 94079FE5 		ldr	r0, .L559+84
 6030              	.LVL495:
 6031 3480 0410A0E3 		mov	r1, #4
 6032 3484 34208DE2 		add	r2, sp, #52
1920:../uvc.c      ****     dmaInterConfig.size           = 1024;
 6033              		.loc 1 1920 0
 6034 3488 B453CDE1 		strh	r5, [sp, #52]	@ movhi
1921:../uvc.c      ****     dmaInterConfig.count          = 1;
 6035              		.loc 1 1921 0
 6036 348c B643CDE1 		strh	r4, [sp, #54]	@ movhi
1922:../uvc.c      ****     dmaInterConfig.prodSckId      = CY_U3P_CPU_SOCKET_PROD;
 6037              		.loc 1 1922 0
 6038 3490 B8C3CDE1 		strh	ip, [sp, #56]	@ movhi
1923:../uvc.c      ****     dmaInterConfig.consSckId      = CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_CONTROL_STATUS_SOCKET;
 6039              		.loc 1 1923 0
 6040 3494 BAE3CDE1 		strh	lr, [sp, #58]	@ movhi
1924:../uvc.c      ****     dmaInterConfig.prodAvailCount = 0;
 6041              		.loc 1 1924 0
 6042 3498 BC33CDE1 		strh	r3, [sp, #60]	@ movhi
1925:../uvc.c      ****     dmaInterConfig.prodHeader     = 0;
 6043              		.loc 1 1925 0
 6044 349c BE33CDE1 		strh	r3, [sp, #62]	@ movhi
1926:../uvc.c      ****     dmaInterConfig.prodFooter     = 0;
 6045              		.loc 1 1926 0
 6046 34a0 B034CDE1 		strh	r3, [sp, #64]	@ movhi
1927:../uvc.c      ****     dmaInterConfig.consHeader     = 0;
 6047              		.loc 1 1927 0
 6048 34a4 B234CDE1 		strh	r3, [sp, #66]	@ movhi
1928:../uvc.c      ****     dmaInterConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6049              		.loc 1 1928 0
 6050 34a8 44A0CDE5 		strb	sl, [sp, #68]
1929:../uvc.c      ****     dmaInterConfig.notification   = CY_U3P_DMA_CB_CONS_EVENT;
 6051              		.loc 1 1929 0
 6052 34ac 48708DE5 		str	r7, [sp, #72]
1930:../uvc.c      ****     dmaInterConfig.cb             = CyFxUvcAppInterInCallback;
 6053              		.loc 1 1930 0
 6054 34b0 4C308DE5 		str	r3, [sp, #76]
1931:../uvc.c      ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleInterStat, CY_U3P_DMA_TYPE_MANUAL_OUT,
 6055              		.loc 1 1931 0
 6056 34b4 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 6057              	.LVL496:
1933:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6058              		.loc 1 1933 0
 6059 34b8 005050E2 		subs	r5, r0, #0
 6060 34bc FE00001A 		bne	.L547
1940:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6061              		.loc 1 1940 0
 6062 34c0 010BA0E3 		mov	r0, #1024
 6063              	.LVL497:
 6064 34c4 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 6065 34c8 4C179FE5 		ldr	r1, .L559+88
1941:../uvc.c      ****     if (glInterStaBuffer == 0)
 6066              		.loc 1 1941 0
 6067 34cc 000050E3 		cmp	r0, #0
1940:../uvc.c      ****     glInterStaBuffer = (uint8_t *)CyU3PDmaBufferAlloc (1024);
 6068              		.loc 1 1940 0
 6069 34d0 000081E5 		str	r0, [r1, #0]
1941:../uvc.c      ****     if (glInterStaBuffer == 0)
 6070              		.loc 1 1941 0
 6071 34d4 EF00000A 		beq	.L548
1949:../uvc.c      ****     dmaMultiConfig.count          = CY_FX_UVC_STREAM_BUF_COUNT;
 6072              		.loc 1 1949 0
 6073 34d8 0430A0E3 		mov	r3, #4	@ movhi
 6074 34dc BE30CDE1 		strh	r3, [sp, #14]	@ movhi
1953:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6075              		.loc 1 1953 0
 6076 34e0 38379FE5 		ldr	r3, .L559+92
1948:../uvc.c      ****     dmaMultiConfig.size           = CY_FX_UVC_STREAM_BUF_SIZE;
 6077              		.loc 1 1948 0
 6078 34e4 01E9A0E3 		mov	lr, #16384	@ movhi
 6079 34e8 BCE0CDE1 		strh	lr, [sp, #12]	@ movhi
1952:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6080              		.loc 1 1952 0
 6081 34ec 30E79FE5 		ldr	lr, .L559+96
1953:../uvc.c      ****     dmaMultiConfig.consSckId [0]  = (CyU3PDmaSocketId_t)(CY_U3P_UIB_SOCKET_CONS_0 | CY_FX_EP_VIDEO_
 6082              		.loc 1 1953 0
 6083 34f0 BA31CDE1 		strh	r3, [sp, #26]	@ movhi
1960:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6084              		.loc 1 1960 0
 6085 34f4 2C379FE5 		ldr	r3, .L559+100
1951:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6086              		.loc 1 1951 0
 6087 34f8 01CCA0E3 		mov	ip, #256	@ movhi
1961:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6088              		.loc 1 1961 0
 6089 34fc 0C208DE2 		add	r2, sp, #12
1951:../uvc.c      ****     dmaMultiConfig.prodSckId [0]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_0;
 6090              		.loc 1 1951 0
 6091 3500 B2C1CDE1 		strh	ip, [sp, #18]	@ movhi
1952:../uvc.c      ****     dmaMultiConfig.prodSckId [1]  = (CyU3PDmaSocketId_t)CY_U3P_PIB_SOCKET_1;
 6092              		.loc 1 1952 0
 6093 3504 B4E1CDE1 		strh	lr, [sp, #20]	@ movhi
1955:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6094              		.loc 1 1955 0
 6095 3508 0CC0A0E3 		mov	ip, #12	@ movhi
1956:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6096              		.loc 1 1956 0
 6097 350c 04E0A0E3 		mov	lr, #4	@ movhi
1958:../uvc.c      ****     dmaMultiConfig.dmaMode        = CY_U3P_DMA_MODE_BYTE;
 6098              		.loc 1 1958 0
 6099 3510 2AA0CDE5 		strb	sl, [sp, #42]
1950:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6100              		.loc 1 1950 0
 6101 3514 0280A0E3 		mov	r8, #2	@ movhi
1961:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6102              		.loc 1 1961 0
 6103 3518 0C079FE5 		ldr	r0, .L559+104
 6104 351c 0710A0E3 		mov	r1, #7
1959:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6105              		.loc 1 1959 0
 6106 3520 18A0A0E3 		mov	sl, #24
1950:../uvc.c      ****     dmaMultiConfig.validSckCount  = 2;
 6107              		.loc 1 1950 0
 6108 3524 B081CDE1 		strh	r8, [sp, #16]	@ movhi
1954:../uvc.c      ****     dmaMultiConfig.prodAvailCount = 0;
 6109              		.loc 1 1954 0
 6110 3528 B252CDE1 		strh	r5, [sp, #34]	@ movhi
1955:../uvc.c      ****     dmaMultiConfig.prodHeader     = 12;                 /* 12 byte UVC header to be added. */
 6111              		.loc 1 1955 0
 6112 352c B4C2CDE1 		strh	ip, [sp, #36]	@ movhi
1956:../uvc.c      ****     dmaMultiConfig.prodFooter     = 4;                  /* 4 byte footer to compensate for the 12 b
 6113              		.loc 1 1956 0
 6114 3530 B6E2CDE1 		strh	lr, [sp, #38]	@ movhi
1957:../uvc.c      ****     dmaMultiConfig.consHeader     = 0;
 6115              		.loc 1 1957 0
 6116 3534 B852CDE1 		strh	r5, [sp, #40]	@ movhi
1959:../uvc.c      ****     dmaMultiConfig.notification   = CY_U3P_DMA_CB_PROD_EVENT | CY_U3P_DMA_CB_CONS_EVENT;
 6117              		.loc 1 1959 0
 6118 3538 2CA08DE5 		str	sl, [sp, #44]
1960:../uvc.c      ****     dmaMultiConfig.cb             = CyFxUvcApplnDmaCallback;
 6119              		.loc 1 1960 0
 6120 353c 30308DE5 		str	r3, [sp, #48]
1961:../uvc.c      ****     apiRetStatus = CyU3PDmaMultiChannelCreate (&glChHandleUVCStream, CY_U3P_DMA_TYPE_MANUAL_MANY_TO
 6121              		.loc 1 1961 0
 6122 3540 FEFFFFEB 		bl	CyU3PDmaMultiChannelCreate
 6123              	.LVL498:
1963:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6124              		.loc 1 1963 0
 6125 3544 002050E2 		subs	r2, r0, #0
 6126 3548 C900001A 		bne	.L549
2054:../uvc.c      ****     apiRetStatus = CyU3PConnectState (CyTrue, CyTrue);
 6127              		.loc 1 2054 0
 6128 354c 0400A0E1 		mov	r0, r4
 6129              	.LVL499:
 6130 3550 0410A0E1 		mov	r1, r4
 6131 3554 FEFFFFEB 		bl	CyU3PConnectState
 6132              	.LVL500:
2055:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6133              		.loc 1 2055 0
 6134 3558 002050E2 		subs	r2, r0, #0
 6135 355c BB00001A 		bne	.L550
2061:../uvc.c      ****     CyU3PBusyWait(100);
 6136              		.loc 1 2061 0
 6137 3560 6400A0E3 		mov	r0, #100
 6138              	.LVL501:
 6139 3564 FEFFFFEB 		bl	CyU3PBusyWait
 6140              	.LVL502:
2063:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6141              		.loc 1 2063 0
 6142 3568 FEFFFFEB 		bl	CyU3PUsbGetSpeed
2077:../uvc.c      ****     endPointConfig.streams  = 0;
 6143              		.loc 1 2077 0
 6144 356c 0020A0E3 		mov	r2, #0	@ movhi
2066:../uvc.c      ****     endPointConfig.epType   = CY_U3P_USB_EP_BULK;
 6145              		.loc 1 2066 0
 6146 3570 AC80CDE5 		strb	r8, [sp, #172]
2078:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6147              		.loc 1 2078 0
 6148 3574 A8108DE2 		add	r1, sp, #168
2077:../uvc.c      ****     endPointConfig.streams  = 0;
 6149              		.loc 1 2077 0
 6150 3578 BE2ACDE1 		strh	r2, [sp, #174]	@ movhi
2065:../uvc.c      ****     endPointConfig.enable   = 1;
 6151              		.loc 1 2065 0
 6152 357c A8408DE5 		str	r4, [sp, #168]
2067:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)  /*for usb3.0 super-speed mode */
 6153              		.loc 1 2067 0
 6154 3580 030050E3 		cmp	r0, #3
2063:../uvc.c      ****     usbSpeed = CyU3PUsbGetSpeed();
 6155              		.loc 1 2063 0
 6156 3584 4800C6E5 		strb	r0, [r6, #72]
2074:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6157              		.loc 1 2074 0
 6158 3588 020CA013 		movne	r0, #512	@ movhi
2069:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6159              		.loc 1 2069 0
 6160 358c 018BA003 		moveq	r8, #1024	@ movhi
2074:../uvc.c      ****     	endPointConfig.pcktSize = 0x200;
 6161              		.loc 1 2074 0
 6162 3590 B00BCD11 		strneh	r0, [sp, #176]	@ movhi
2078:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6163              		.loc 1 2078 0
 6164 3594 8300A0E3 		mov	r0, #131
2069:../uvc.c      ****     	endPointConfig.pcktSize = CY_FX_EP_BULK_VIDEO_PKT_SIZE;
 6165              		.loc 1 2069 0
 6166 3598 B08BCD01 		streqh	r8, [sp, #176]	@ movhi
2070:../uvc.c      ****     	endPointConfig.burstLen = 16;
 6167              		.loc 1 2070 0
 6168 359c B270CD05 		streqb	r7, [sp, #178]
2075:../uvc.c      ****     	endPointConfig.burstLen = 1;
 6169              		.loc 1 2075 0
 6170 35a0 B240CD15 		strneb	r4, [sp, #178]
2078:../uvc.c      ****     apiRetStatus = CyU3PSetEpConfig (CY_FX_EP_BULK_VIDEO, &endPointConfig);
 6171              		.loc 1 2078 0
 6172 35a4 FEFFFFEB 		bl	CyU3PSetEpConfig
 6173              	.LVL503:
2079:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6174              		.loc 1 2079 0
 6175 35a8 002050E2 		subs	r2, r0, #0
 6176 35ac 4F00001A 		bne	.L533
 6177 35b0 78869FE5 		ldr	r8, .L559+108
 6178              	.LBE217:
 6179              	.LBE214:
2199:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6180              		.loc 1 2199 0
 6181 35b4 1C469FE5 		ldr	r4, .L559+20
 6182 35b8 0250A0E1 		mov	r5, r2
2270:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6183              		.loc 1 2270 0
 6184 35bc 0870A0E1 		mov	r7, r8
 6185              	.LVL504:
 6186              	.L507:
2199:../uvc.c      ****         if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag,
 6187              		.loc 1 2199 0
 6188 35c0 10069FE5 		ldr	r0, .L559+20
 6189 35c4 0110A0E3 		mov	r1, #1
 6190 35c8 0220A0E3 		mov	r2, #2
 6191 35cc B4308DE2 		add	r3, sp, #180
 6192 35d0 00508DE5 		str	r5, [sp, #0]
 6193 35d4 FEFFFFEB 		bl	_txe_event_flags_get
 6194 35d8 000050E3 		cmp	r0, #0
 6195 35dc 3000001A 		bne	.L509
2245:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6196              		.loc 1 2245 0
 6197 35e0 441094E5 		ldr	r1, [r4, #68]
 6198 35e4 000051E3 		cmp	r1, #0
 6199 35e8 0300000A 		beq	.L510
2245:../uvc.c      ****             if ((hitFV) && (prodCount == consCount))
 6200              		.loc 1 2245 0 is_stmt 0 discriminator 1
 6201 35ec BEA2D4E1 		ldrh	sl, [r4, #46]
 6202 35f0 B0C3D4E1 		ldrh	ip, [r4, #48]
 6203 35f4 0C005AE1 		cmp	sl, ip
 6204 35f8 3601000A 		beq	.L551
 6205              	.L510:
2372:../uvc.c      ****         CyU3PEventSet (&glFxUVCEvent, VD_FX_INT_STA_EVENT, CYU3P_EVENT_OR);//check snap shot button
 6206              		.loc 1 2372 0 is_stmt 1
 6207 35fc 4010A0E3 		mov	r1, #64
 6208 3600 0020A0E3 		mov	r2, #0
 6209 3604 CC059FE5 		ldr	r0, .L559+20
 6210 3608 FEFFFFEB 		bl	_txe_event_flags_set
2375:../uvc.c      ****         CyU3PThreadRelinquish ();
 6211              		.loc 1 2375 0
 6212 360c FEFFFFEB 		bl	_txe_thread_relinquish
2376:../uvc.c      ****     }
 6213              		.loc 1 2376 0
 6214 3610 EAFFFFEA 		b	.L507
 6215              	.LVL505:
 6216              	.L536:
 6217              	.LBB252:
 6218              	.LBB216:
1753:../uvc.c      ****         CyU3PDebugPrint (4, "UVC Create Event failed, Error Code = %d\n", apiRetStatus);
 6219              		.loc 1 1753 0
 6220 3614 0400A0E3 		mov	r0, #4
 6221              	.LVL506:
 6222 3618 14169FE5 		ldr	r1, .L559+112
 6223 361c FEFFFFEB 		bl	CyU3PDebugPrint
 6224              	.LVL507:
 6225              	.L476:
 6226              	.LBB232:
 6227              	.LBB233:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6228              		.loc 1 1213 0
 6229 3620 10169FE5 		ldr	r1, .L559+116
 6230 3624 0400A0E3 		mov	r0, #4
 6231 3628 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6232              		.loc 1 1214 0
 6233 362c FA0FA0E3 		mov	r0, #1000
 6234 3630 FEFFFFEB 		bl	_tx_thread_sleep
 6235 3634 F9FFFFEA 		b	.L476
 6236              	.LVL508:
 6237              	.L538:
 6238              	.LBE233:
 6239              	.LBE232:
1784:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Override failed, Error Code = %d\n", apiRetStatus);
 6240              		.loc 1 1784 0
 6241 3638 0400A0E3 		mov	r0, #4
 6242              	.LVL509:
 6243 363c F8159FE5 		ldr	r1, .L559+120
 6244 3640 FEFFFFEB 		bl	CyU3PDebugPrint
 6245              	.LVL510:
 6246              	.L480:
 6247              	.LBB230:
 6248              	.LBB231:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6249              		.loc 1 1213 0
 6250 3644 EC159FE5 		ldr	r1, .L559+116
 6251 3648 0400A0E3 		mov	r0, #4
 6252 364c FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6253              		.loc 1 1214 0
 6254 3650 FA0FA0E3 		mov	r0, #1000
 6255 3654 FEFFFFEB 		bl	_tx_thread_sleep
 6256 3658 F9FFFFEA 		b	.L480
 6257              	.LVL511:
 6258              	.L537:
 6259              	.LBE231:
 6260              	.LBE230:
1775:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Init failed, Error Code = %d\n", apiRetStatus);
 6261              		.loc 1 1775 0
 6262 365c 0400A0E3 		mov	r0, #4
 6263              	.LVL512:
 6264 3660 D8159FE5 		ldr	r1, .L559+124
 6265 3664 FEFFFFEB 		bl	CyU3PDebugPrint
 6266              	.LVL513:
 6267              	.L478:
 6268              	.LBB228:
 6269              	.LBB229:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6270              		.loc 1 1213 0
 6271 3668 C8159FE5 		ldr	r1, .L559+116
 6272 366c 0400A0E3 		mov	r0, #4
 6273 3670 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6274              		.loc 1 1214 0
 6275 3674 FA0FA0E3 		mov	r0, #1000
 6276 3678 FEFFFFEB 		bl	_tx_thread_sleep
 6277 367c F9FFFFEA 		b	.L478
 6278              	.LVL514:
 6279              	.L539:
 6280              	.LBE229:
 6281              	.LBE228:
1790:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(20) Override failed, Error Code = %d\n", apiRetStatus);
 6282              		.loc 1 1790 0
 6283 3680 0400A0E3 		mov	r0, #4
 6284              	.LVL515:
 6285 3684 B8159FE5 		ldr	r1, .L559+128
 6286 3688 FEFFFFEB 		bl	CyU3PDebugPrint
 6287              	.LVL516:
 6288              	.L482:
 6289              	.LBB226:
 6290              	.LBB227:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6291              		.loc 1 1213 0
 6292 368c A4159FE5 		ldr	r1, .L559+116
 6293 3690 0400A0E3 		mov	r0, #4
 6294 3694 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6295              		.loc 1 1214 0
 6296 3698 FA0FA0E3 		mov	r0, #1000
 6297 369c FEFFFFEB 		bl	_tx_thread_sleep
 6298 36a0 F9FFFFEA 		b	.L482
 6299              	.LVL517:
 6300              	.L509:
 6301              	.LBE227:
 6302              	.LBE226:
 6303              	.LBE216:
 6304              	.LBE252:
2301:../uvc.c      ****             if (CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_ABORT_EVENT, CYU3P_EVENT_AND_CLEAR,
 6305              		.loc 1 2301 0
 6306 36a4 2C059FE5 		ldr	r0, .L559+20
 6307 36a8 0210A0E3 		mov	r1, #2
 6308 36ac 0320A0E3 		mov	r2, #3
 6309 36b0 B4308DE2 		add	r3, sp, #180
 6310 36b4 00508DE5 		str	r5, [sp, #0]
 6311 36b8 FEFFFFEB 		bl	_txe_event_flags_get
 6312 36bc 000050E3 		cmp	r0, #0
 6313 36c0 2500001A 		bne	.L517
2316:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6314              		.loc 1 2316 0
 6315 36c4 40C094E5 		ldr	ip, [r4, #64]
2304:../uvc.c      ****                 hitFV     = CyFalse;
 6316              		.loc 1 2304 0
 6317 36c8 445084E5 		str	r5, [r4, #68]
2316:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6318              		.loc 1 2316 0
 6319 36cc 00005CE3 		cmp	ip, #0
2305:../uvc.c      ****                 prodCount = 0;
 6320              		.loc 1 2305 0
 6321 36d0 BE52C4E1 		strh	r5, [r4, #46]	@ movhi
2312:../uvc.c      ****                 fb=0;
 6322              		.loc 1 2312 0
 6323 36d4 B852C4E1 		strh	r5, [r4, #40]	@ movhi
2306:../uvc.c      ****                 consCount = 0;
 6324              		.loc 1 2306 0
 6325 36d8 B053C4E1 		strh	r5, [r4, #48]	@ movhi
2313:../uvc.c      ****                 pb=0;
 6326              		.loc 1 2313 0
 6327 36dc BA52C4E1 		strh	r5, [r4, #42]	@ movhi
2314:../uvc.c      ****                 pbc=0;
 6328              		.loc 1 2314 0
 6329 36e0 BC52C4E1 		strh	r5, [r4, #44]	@ movhi
2316:../uvc.c      ****                 if (!clearFeatureRqtReceived)
 6330              		.loc 1 2316 0
 6331 36e4 0A00000A 		beq	.L552
 6332              	.L518:
2328:../uvc.c      ****                 clearFeatureRqtReceived = CyFalse;
 6333              		.loc 1 2328 0
 6334 36e8 405086E5 		str	r5, [r6, #64]
 6335 36ec C2FFFFEA 		b	.L510
 6336              	.LVL518:
 6337              	.L533:
 6338              	.LBB253:
 6339              	.LBB250:
2082:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6340              		.loc 1 2082 0
 6341 36f0 0400A0E3 		mov	r0, #4
 6342              	.LVL519:
 6343 36f4 4C159FE5 		ldr	r1, .L559+132
 6344 36f8 FEFFFFEB 		bl	CyU3PDebugPrint
 6345              	.LVL520:
 6346              	.L508:
 6347              	.LBB234:
 6348              	.LBB235:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6349              		.loc 1 1213 0
 6350 36fc 34159FE5 		ldr	r1, .L559+116
 6351 3700 0400A0E3 		mov	r0, #4
 6352 3704 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6353              		.loc 1 1214 0
 6354 3708 FA0FA0E3 		mov	r0, #1000
 6355 370c FEFFFFEB 		bl	_tx_thread_sleep
 6356 3710 F9FFFFEA 		b	.L508
 6357              	.LVL521:
 6358              	.L552:
 6359              	.LBE235:
 6360              	.LBE234:
 6361              	.LBE250:
 6362              	.LBE253:
2318:../uvc.c      ****                     apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6363              		.loc 1 2318 0
 6364 3714 10059FE5 		ldr	r0, .L559+104
 6365 3718 FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6366              	.LVL522:
2319:../uvc.c      ****                     if (apiRetStatus != CY_U3P_SUCCESS)
 6367              		.loc 1 2319 0
 6368 371c 000050E3 		cmp	r0, #0
 6369 3720 0200001A 		bne	.L534
2325:../uvc.c      ****                     CyU3PUsbFlushEp (CY_FX_EP_BULK_VIDEO);
 6370              		.loc 1 2325 0
 6371 3724 8300A0E3 		mov	r0, #131
 6372              	.LVL523:
 6373 3728 FEFFFFEB 		bl	CyU3PUsbFlushEp
 6374 372c EDFFFFEA 		b	.L518
 6375              	.L534:
 6376              	.LBB254:
 6377              	.LBB255:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6378              		.loc 1 1213 0
 6379 3730 00159FE5 		ldr	r1, .L559+116
 6380 3734 0400A0E3 		mov	r0, #4
 6381 3738 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6382              		.loc 1 1214 0
 6383 373c FA0FA0E3 		mov	r0, #1000
 6384 3740 FEFFFFEB 		bl	_tx_thread_sleep
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6385              		.loc 1 1213 0
 6386 3744 EC149FE5 		ldr	r1, .L559+116
 6387 3748 0400A0E3 		mov	r0, #4
 6388 374c FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6389              		.loc 1 1214 0
 6390 3750 FA0FA0E3 		mov	r0, #1000
 6391 3754 FEFFFFEB 		bl	_tx_thread_sleep
 6392 3758 F4FFFFEA 		b	.L534
 6393              	.L517:
 6394              	.LBE255:
 6395              	.LBE254:
2333:../uvc.c      ****                 CyU3PEventGet (&glFxUVCEvent, CY_FX_UVC_STREAM_EVENT, CYU3P_EVENT_AND, &flag, CYU3P
 6396              		.loc 1 2333 0
 6397 375c 00E0E0E3 		mvn	lr, #0
 6398 3760 0110A0E3 		mov	r1, #1
 6399 3764 0220A0E3 		mov	r2, #2
 6400 3768 B4308DE2 		add	r3, sp, #180
 6401 376c 64049FE5 		ldr	r0, .L559+20
 6402 3770 00E08DE5 		str	lr, [sp, #0]
 6403 3774 FEFFFFEB 		bl	_txe_event_flags_get
2337:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6404              		.loc 1 2337 0
 6405 3778 0520A0E1 		mov	r2, r5
 6406 377c A8049FE5 		ldr	r0, .L559+104
 6407 3780 0510A0E1 		mov	r1, r5
 6408 3784 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6409              	.LVL524:
2338:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6410              		.loc 1 2338 0
 6411 3788 002050E2 		subs	r2, r0, #0
 6412 378c 8800001A 		bne	.L553
2346:../uvc.c      ****                 if (gpif_initialized == CyFalse)
 6413              		.loc 1 2346 0
 6414 3790 383094E5 		ldr	r3, [r4, #56]
 6415 3794 000053E3 		cmp	r3, #0
 6416 3798 7D00001A 		bne	.L523
2349:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 1, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6417              		.loc 1 2349 0
 6418 379c 3010A0E3 		mov	r1, #48
 6419 37a0 0120A0E3 		mov	r2, #1
 6420 37a4 823083E2 		add	r3, r3, #130
 6421 37a8 2100A0E3 		mov	r0, #33
 6422              	.LVL525:
 6423 37ac FEFFFFEB 		bl	SensorSetIrisControl
2350:../uvc.c      ****                     CyU3PThreadSleep(500);
 6424              		.loc 1 2350 0
 6425 37b0 7D0FA0E3 		mov	r0, #500
 6426 37b4 FEFFFFEB 		bl	_tx_thread_sleep
2351:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 2, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6427              		.loc 1 2351 0
 6428 37b8 3010A0E3 		mov	r1, #48
 6429 37bc 0220A0E3 		mov	r2, #2
 6430 37c0 5230A0E3 		mov	r3, #82
 6431 37c4 2500A0E3 		mov	r0, #37
 6432 37c8 FEFFFFEB 		bl	SensorSetIrisControl
2352:../uvc.c      ****                     CyU3PThreadSleep(500);
 6433              		.loc 1 2352 0
 6434 37cc 7D0FA0E3 		mov	r0, #500
 6435 37d0 FEFFFFEB 		bl	_tx_thread_sleep
2353:../uvc.c      ****                    	SensorSetIrisControl(0x23, 0x30, 0xa, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iri
 6436              		.loc 1 2353 0
 6437 37d4 3010A0E3 		mov	r1, #48
 6438 37d8 0A20A0E3 		mov	r2, #10
 6439 37dc 8230A0E3 		mov	r3, #130
 6440 37e0 2300A0E3 		mov	r0, #35
 6441 37e4 FEFFFFEB 		bl	SensorSetIrisControl
2354:../uvc.c      ****                    	CyU3PThreadSleep(300);
 6442              		.loc 1 2354 0
 6443 37e8 4B0FA0E3 		mov	r0, #300
 6444 37ec FEFFFFEB 		bl	_tx_thread_sleep
2355:../uvc.c      ****                    	SensorSetIrisControl(0x21, 0x30, 0, I2C_AFBOARD_ADDR_WR/*boardID*/);//set Iris 
 6445              		.loc 1 2355 0
 6446 37f0 3010A0E3 		mov	r1, #48
 6447 37f4 0520A0E1 		mov	r2, r5
 6448 37f8 8230A0E3 		mov	r3, #130
 6449 37fc 2100A0E3 		mov	r0, #33
 6450 3800 FEFFFFEB 		bl	SensorSetIrisControl
2356:../uvc.c      ****                     CyU3PThreadSleep(500);
 6451              		.loc 1 2356 0
 6452 3804 7D0FA0E3 		mov	r0, #500
 6453 3808 FEFFFFEB 		bl	_tx_thread_sleep
2357:../uvc.c      ****                    	SensorSetIrisControl(0x25, 0x30, 0, I2C_DSPBOARD_ADDR_WR/*boardID*/);//set Iris
 6454              		.loc 1 2357 0
 6455 380c 5230A0E3 		mov	r3, #82
 6456 3810 3010A0E3 		mov	r1, #48
 6457 3814 0520A0E1 		mov	r2, r5
 6458 3818 2500A0E3 		mov	r0, #37
 6459 381c FEFFFFEB 		bl	SensorSetIrisControl
2358:../uvc.c      ****                     CyU3PThreadSleep(500);
 6460              		.loc 1 2358 0
 6461 3820 7D0FA0E3 		mov	r0, #500
 6462 3824 FEFFFFEB 		bl	_tx_thread_sleep
 6463              	.LVL526:
 6464              	.LBB256:
 6465              	.LBB257:
2107:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6466              		.loc 1 2107 0
 6467 3828 4830D4E5 		ldrb	r3, [r4, #72]	@ zero_extendqisi2
 6468 382c 030053E3 		cmp	r3, #3
 6469 3830 4700000A 		beq	.L554
2112:../uvc.c      ****     else if(usbSpeed == CY_U3P_HIGH_SPEED)
 6470              		.loc 1 2112 0
 6471 3834 020053E3 		cmp	r3, #2
 6472 3838 2900000A 		beq	.L555
 6473              	.LVL527:
 6474              	.L526:
 6475              	.LBE257:
 6476              	.LBE256:
2360:../uvc.c      ****                     gpif_initialized = CyTrue;
 6477              		.loc 1 2360 0
 6478 383c 0130A0E3 		mov	r3, #1
 6479 3840 383086E5 		str	r3, [r6, #56]
2361:../uvc.c      ****                     CyU3PThreadSleep(200);
 6480              		.loc 1 2361 0
 6481 3844 C800A0E3 		mov	r0, #200
 6482 3848 FEFFFFEB 		bl	_tx_thread_sleep
 6483 384c 6AFFFFEA 		b	.L510
 6484              	.LVL528:
 6485              	.L550:
 6486              	.LBB263:
 6487              	.LBB215:
2057:../uvc.c      ****         CyU3PDebugPrint (4, "USB Connect failed, Error Code = %d\n", apiRetStatus);
 6488              		.loc 1 2057 0
 6489 3850 0400A0E3 		mov	r0, #4
 6490              	.LVL529:
 6491 3854 F0139FE5 		ldr	r1, .L559+136
 6492 3858 FEFFFFEB 		bl	CyU3PDebugPrint
 6493              	.LVL530:
 6494              	.L504:
 6495              	.LBB224:
 6496              	.LBB225:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6497              		.loc 1 1213 0
 6498 385c D4139FE5 		ldr	r1, .L559+116
 6499 3860 0400A0E3 		mov	r0, #4
 6500 3864 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6501              		.loc 1 1214 0
 6502 3868 FA0FA0E3 		mov	r0, #1000
 6503 386c FEFFFFEB 		bl	_tx_thread_sleep
 6504 3870 F9FFFFEA 		b	.L504
 6505              	.LVL531:
 6506              	.L549:
 6507              	.LBE225:
 6508              	.LBE224:
1966:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Channel Creation Failed, Error Code = %d\n", apiRetStatus);
 6509              		.loc 1 1966 0
 6510 3874 0400A0E3 		mov	r0, #4
 6511              	.LVL532:
 6512 3878 D0139FE5 		ldr	r1, .L559+140
 6513 387c FEFFFFEB 		bl	CyU3PDebugPrint
 6514              	.LVL533:
 6515              	.L502:
 6516              	.LBB222:
 6517              	.LBB223:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6518              		.loc 1 1213 0
 6519 3880 B0139FE5 		ldr	r1, .L559+116
 6520 3884 0400A0E3 		mov	r0, #4
 6521 3888 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6522              		.loc 1 1214 0
 6523 388c FA0FA0E3 		mov	r0, #1000
 6524 3890 FEFFFFEB 		bl	_tx_thread_sleep
 6525 3894 F9FFFFEA 		b	.L502
 6526              	.LVL534:
 6527              	.L548:
 6528              	.LBE223:
 6529              	.LBE222:
1943:../uvc.c      ****         CyU3PDebugPrint (4, "Failed to allocate memory for interrupt status buffer\r\n");
 6530              		.loc 1 1943 0
 6531 3898 040080E2 		add	r0, r0, #4
 6532 389c B0139FE5 		ldr	r1, .L559+144
 6533 38a0 FEFFFFEB 		bl	CyU3PDebugPrint
 6534              	.LVL535:
 6535              	.L500:
 6536              	.LBB220:
 6537              	.LBB221:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6538              		.loc 1 1213 0
 6539 38a4 8C139FE5 		ldr	r1, .L559+116
 6540 38a8 0400A0E3 		mov	r0, #4
 6541 38ac FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6542              		.loc 1 1214 0
 6543 38b0 FA0FA0E3 		mov	r0, #1000
 6544 38b4 FEFFFFEB 		bl	_tx_thread_sleep
 6545 38b8 F9FFFFEA 		b	.L500
 6546              	.LVL536:
 6547              	.L547:
 6548              	.LBE221:
 6549              	.LBE220:
1936:../uvc.c      ****         CyU3PDebugPrint (4, "DMA Interrupt Status Channel Creation Failed, Error Code = %d\n", apiR
 6550              		.loc 1 1936 0
 6551 38bc 0400A0E3 		mov	r0, #4
 6552 38c0 90139FE5 		ldr	r1, .L559+148
 6553 38c4 0520A0E1 		mov	r2, r5
 6554 38c8 FEFFFFEB 		bl	CyU3PDebugPrint
 6555              	.L498:
 6556              	.LBB218:
 6557              	.LBB219:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6558              		.loc 1 1213 0
 6559 38cc 64139FE5 		ldr	r1, .L559+116
 6560 38d0 0400A0E3 		mov	r0, #4
 6561 38d4 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6562              		.loc 1 1214 0
 6563 38d8 FA0FA0E3 		mov	r0, #1000
 6564 38dc FEFFFFEB 		bl	_tx_thread_sleep
 6565 38e0 F9FFFFEA 		b	.L498
 6566              	.LVL537:
 6567              	.L555:
 6568              	.LBE219:
 6569              	.LBE218:
 6570              	.LBE215:
 6571              	.LBE263:
 6572              	.LBB264:
 6573              	.LBB262:
2114:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n high gpif");
 6574              		.loc 1 2114 0
 6575 38e4 70139FE5 		ldr	r1, .L559+152
 6576 38e8 0100A0E3 		mov	r0, #1
 6577 38ec FEFFFFEB 		bl	CyU3PDebugPrint
2115:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig_usb2);
 6578              		.loc 1 2115 0
 6579 38f0 68039FE5 		ldr	r0, .L559+156
 6580 38f4 FEFFFFEB 		bl	CyU3PGpifLoad
 6581 38f8 0020A0E1 		mov	r2, r0
 6582              	.LVL538:
 6583              	.L525:
2117:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6584              		.loc 1 2117 0
 6585 38fc 000052E3 		cmp	r2, #0
 6586 3900 1A00001A 		bne	.L556
2125:../uvc.c      ****     if(usbSpeed == CY_U3P_SUPER_SPEED)
 6587              		.loc 1 2125 0
 6588 3904 4830D6E5 		ldrb	r3, [r6, #72]	@ zero_extendqisi2
 6589 3908 030053E3 		cmp	r3, #3
 6590 390c 0100000A 		beq	.L535
2129:../uvc.c      ****     else if (usbSpeed == CY_U3P_HIGH_SPEED)
 6591              		.loc 1 2129 0
 6592 3910 020053E3 		cmp	r3, #2
 6593 3914 C8FFFF1A 		bne	.L526
 6594              	.L535:
2131:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6595              		.loc 1 2131 0
 6596 3918 0200A0E1 		mov	r0, r2
 6597              	.LVL539:
 6598 391c 0210A0E1 		mov	r1, r2
 6599 3920 FEFFFFEB 		bl	CyU3PGpifSMStart
 6600              	.LVL540:
2133:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6601              		.loc 1 2133 0
 6602 3924 000050E3 		cmp	r0, #0
2131:../uvc.c      ****     	apiRetStatus = CyU3PGpifSMStart (START_USB2, ALPHA_START_USB2);
 6603              		.loc 1 2131 0
 6604 3928 0020A0E1 		mov	r2, r0
 6605              	.LVL541:
2133:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 6606              		.loc 1 2133 0
 6607 392c C2FFFF0A 		beq	.L526
2136:../uvc.c      ****         CyU3PDebugPrint (4, "Starting GPIF state machine failed, Error Code = %d\r\n", apiRetStatus
 6608              		.loc 1 2136 0
 6609 3930 0400A0E3 		mov	r0, #4
 6610              	.LVL542:
 6611 3934 28139FE5 		ldr	r1, .L559+160
 6612 3938 FEFFFFEB 		bl	CyU3PDebugPrint
 6613              	.LVL543:
 6614              	.L531:
 6615              	.LBB258:
 6616              	.LBB259:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6617              		.loc 1 1213 0
 6618 393c F4129FE5 		ldr	r1, .L559+116
 6619 3940 0400A0E3 		mov	r0, #4
 6620 3944 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6621              		.loc 1 1214 0
 6622 3948 FA0FA0E3 		mov	r0, #1000
 6623 394c FEFFFFEB 		bl	_tx_thread_sleep
 6624 3950 F9FFFFEA 		b	.L531
 6625              	.LVL544:
 6626              	.L554:
 6627              	.LBE259:
 6628              	.LBE258:
2109:../uvc.c      ****     	CyU3PDebugPrint(1,"\r\n super gpif");
 6629              		.loc 1 2109 0
 6630 3954 0C139FE5 		ldr	r1, .L559+164
 6631 3958 0100A0E3 		mov	r0, #1
 6632 395c FEFFFFEB 		bl	CyU3PDebugPrint
2110:../uvc.c      ****     	apiRetStatus =  CyU3PGpifLoad ((CyU3PGpifConfig_t *) &CyFxGpifConfig);
 6633              		.loc 1 2110 0
 6634 3960 04039FE5 		ldr	r0, .L559+168
 6635 3964 FEFFFFEB 		bl	CyU3PGpifLoad
 6636 3968 0020A0E1 		mov	r2, r0
 6637              	.LVL545:
 6638 396c E2FFFFEA 		b	.L525
 6639              	.L556:
2120:../uvc.c      ****         CyU3PDebugPrint (4, "Loading GPIF Configuration failed, Error Code = %d\r\n", apiRetStatus)
 6640              		.loc 1 2120 0
 6641 3970 0400A0E3 		mov	r0, #4
 6642              	.LVL546:
 6643 3974 F4129FE5 		ldr	r1, .L559+172
 6644 3978 FEFFFFEB 		bl	CyU3PDebugPrint
 6645              	.LVL547:
 6646              	.L528:
 6647              	.LBB260:
 6648              	.LBB261:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6649              		.loc 1 1213 0
 6650 397c B4129FE5 		ldr	r1, .L559+116
 6651 3980 0400A0E3 		mov	r0, #4
 6652 3984 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6653              		.loc 1 1214 0
 6654 3988 FA0FA0E3 		mov	r0, #1000
 6655 398c FEFFFFEB 		bl	_tx_thread_sleep
 6656 3990 F9FFFFEA 		b	.L528
 6657              	.LVL548:
 6658              	.L523:
 6659              	.LBE261:
 6660              	.LBE260:
 6661              	.LBE262:
 6662              	.LBE264:
2368:../uvc.c      ****                     CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6663              		.loc 1 2368 0
 6664 3994 88029FE5 		ldr	r0, .L559+96
 6665              	.LVL549:
 6666 3998 02A0A0E3 		mov	sl, #2
 6667 399c 0510A0E1 		mov	r1, r5
 6668 39a0 0020A0E1 		mov	r2, r0
 6669              	.LVL550:
 6670 39a4 0530A0E1 		mov	r3, r5
 6671 39a8 00A08DE5 		str	sl, [sp, #0]
 6672 39ac FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6673 39b0 11FFFFEA 		b	.L510
 6674              	.LVL551:
 6675              	.L553:
2341:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\r\n", api
 6676              		.loc 1 2341 0
 6677 39b4 0400A0E3 		mov	r0, #4
 6678              	.LVL552:
 6679 39b8 B4129FE5 		ldr	r1, .L559+176
 6680 39bc FEFFFFEB 		bl	CyU3PDebugPrint
 6681              	.LVL553:
 6682              	.L522:
 6683              	.LBB265:
 6684              	.LBB266:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6685              		.loc 1 1213 0
 6686 39c0 70129FE5 		ldr	r1, .L559+116
 6687 39c4 0400A0E3 		mov	r0, #4
 6688 39c8 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6689              		.loc 1 1214 0
 6690 39cc FA0FA0E3 		mov	r0, #1000
 6691 39d0 FEFFFFEB 		bl	_tx_thread_sleep
 6692 39d4 F9FFFFEA 		b	.L522
 6693              	.LVL554:
 6694              	.L546:
 6695              	.LBE266:
 6696              	.LBE265:
 6697              	.LBB267:
 6698              	.LBB251:
1915:../uvc.c      ****         CyU3PDebugPrint (4, "USB Set Endpoint config failed, Error Code = %d\n", apiRetStatus);
 6699              		.loc 1 1915 0
 6700 39d8 0400A0E3 		mov	r0, #4
 6701              	.LVL555:
 6702 39dc 64129FE5 		ldr	r1, .L559+132
 6703 39e0 0320A0E1 		mov	r2, r3
 6704 39e4 FEFFFFEB 		bl	CyU3PDebugPrint
 6705              	.LVL556:
 6706              	.L496:
 6707              	.LBB236:
 6708              	.LBB237:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6709              		.loc 1 1213 0
 6710 39e8 48129FE5 		ldr	r1, .L559+116
 6711 39ec 0400A0E3 		mov	r0, #4
 6712 39f0 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6713              		.loc 1 1214 0
 6714 39f4 FA0FA0E3 		mov	r0, #1000
 6715 39f8 FEFFFFEB 		bl	_tx_thread_sleep
 6716 39fc F9FFFFEA 		b	.L496
 6717              	.LVL557:
 6718              	.L545:
 6719              	.LBE237:
 6720              	.LBE236:
1870:../uvc.c      ****         CyU3PDebugPrint (4, "USB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6721              		.loc 1 1870 0
 6722 3a00 0400A0E3 		mov	r0, #4
 6723              	.LVL558:
 6724 3a04 6C129FE5 		ldr	r1, .L559+180
 6725 3a08 FEFFFFEB 		bl	CyU3PDebugPrint
 6726              	.LVL559:
 6727              	.L494:
 6728              	.LBB238:
 6729              	.LBB239:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6730              		.loc 1 1213 0
 6731 3a0c 24129FE5 		ldr	r1, .L559+116
 6732 3a10 0400A0E3 		mov	r0, #4
 6733 3a14 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6734              		.loc 1 1214 0
 6735 3a18 FA0FA0E3 		mov	r0, #1000
 6736 3a1c FEFFFFEB 		bl	_tx_thread_sleep
 6737 3a20 F9FFFFEA 		b	.L494
 6738              	.LVL560:
 6739              	.L544:
 6740              	.LBE239:
 6741              	.LBE238:
1850:../uvc.c      ****         CyU3PDebugPrint (4, "PIB Function Failed to Start, Error Code = %d\n", apiRetStatus);
 6742              		.loc 1 1850 0
 6743 3a24 0400A0E3 		mov	r0, #4
 6744              	.LVL561:
 6745 3a28 4C129FE5 		ldr	r1, .L559+184
 6746 3a2c FEFFFFEB 		bl	CyU3PDebugPrint
 6747              	.LVL562:
 6748              	.L492:
 6749              	.LBB240:
 6750              	.LBB241:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6751              		.loc 1 1213 0
 6752 3a30 00129FE5 		ldr	r1, .L559+116
 6753 3a34 0400A0E3 		mov	r0, #4
 6754 3a38 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6755              		.loc 1 1214 0
 6756 3a3c FA0FA0E3 		mov	r0, #1000
 6757 3a40 FEFFFFEB 		bl	_tx_thread_sleep
 6758 3a44 F9FFFFEA 		b	.L492
 6759              	.LVL563:
 6760              	.L543:
 6761              	.LBE241:
 6762              	.LBE240:
1837:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (snap shot 24) Config Error, Error Code = %d\n", apiRetStatus
 6763              		.loc 1 1837 0
 6764 3a48 0400A0E3 		mov	r0, #4
 6765              	.LVL564:
 6766 3a4c 2C129FE5 		ldr	r1, .L559+188
 6767 3a50 FEFFFFEB 		bl	CyU3PDebugPrint
 6768              	.LVL565:
 6769              	.L490:
 6770              	.LBB242:
 6771              	.LBB243:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6772              		.loc 1 1213 0
 6773 3a54 DC119FE5 		ldr	r1, .L559+116
 6774 3a58 0400A0E3 		mov	r0, #4
 6775 3a5c FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6776              		.loc 1 1214 0
 6777 3a60 FA0FA0E3 		mov	r0, #1000
 6778 3a64 FEFFFFEB 		bl	_tx_thread_sleep
 6779 3a68 F9FFFFEA 		b	.L490
 6780              	.LVL566:
 6781              	.L541:
 6782              	.LBE243:
 6783              	.LBE242:
1809:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (reset 22) Config Error, Error Code = %d\n", apiRetStatus);
 6784              		.loc 1 1809 0
 6785 3a6c 0400A0E3 		mov	r0, #4
 6786              	.LVL567:
 6787 3a70 0C129FE5 		ldr	r1, .L559+192
 6788 3a74 FEFFFFEB 		bl	CyU3PDebugPrint
 6789              	.LVL568:
 6790              	.L486:
 6791              	.LBB244:
 6792              	.LBB245:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6793              		.loc 1 1213 0
 6794 3a78 B8119FE5 		ldr	r1, .L559+116
 6795 3a7c 0400A0E3 		mov	r0, #4
 6796 3a80 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6797              		.loc 1 1214 0
 6798 3a84 FA0FA0E3 		mov	r0, #1000
 6799 3a88 FEFFFFEB 		bl	_tx_thread_sleep
 6800 3a8c F9FFFFEA 		b	.L486
 6801              	.LVL569:
 6802              	.L540:
 6803              	.LBE245:
 6804              	.LBE244:
1796:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO(24) Override failed, Error Code = %d\n", apiRetStatus);
 6805              		.loc 1 1796 0
 6806 3a90 0400A0E3 		mov	r0, #4
 6807              	.LVL570:
 6808 3a94 EC119FE5 		ldr	r1, .L559+196
 6809 3a98 FEFFFFEB 		bl	CyU3PDebugPrint
 6810              	.LVL571:
 6811              	.L484:
 6812              	.LBB246:
 6813              	.LBB247:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6814              		.loc 1 1213 0
 6815 3a9c 94119FE5 		ldr	r1, .L559+116
 6816 3aa0 0400A0E3 		mov	r0, #4
 6817 3aa4 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6818              		.loc 1 1214 0
 6819 3aa8 FA0FA0E3 		mov	r0, #1000
 6820 3aac FEFFFFEB 		bl	_tx_thread_sleep
 6821 3ab0 F9FFFFEA 		b	.L484
 6822              	.LVL572:
 6823              	.L542:
 6824              	.LBE247:
 6825              	.LBE246:
1823:../uvc.c      ****         CyU3PDebugPrint (4, "GPIO Set (power 20) Config Error, Error Code = %d\n", apiRetStatus);
 6826              		.loc 1 1823 0
 6827 3ab4 0400A0E3 		mov	r0, #4
 6828              	.LVL573:
 6829 3ab8 CC119FE5 		ldr	r1, .L559+200
 6830 3abc FEFFFFEB 		bl	CyU3PDebugPrint
 6831              	.LVL574:
 6832              	.L488:
 6833              	.LBB248:
 6834              	.LBB249:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6835              		.loc 1 1213 0
 6836 3ac0 70119FE5 		ldr	r1, .L559+116
 6837 3ac4 0400A0E3 		mov	r0, #4
 6838 3ac8 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6839              		.loc 1 1214 0
 6840 3acc FA0FA0E3 		mov	r0, #1000
 6841 3ad0 FEFFFFEB 		bl	_tx_thread_sleep
 6842 3ad4 F9FFFFEA 		b	.L488
 6843              	.LVL575:
 6844              	.L551:
 6845              	.LBE249:
 6846              	.LBE248:
 6847              	.LBE251:
 6848              	.LBE267:
2248:../uvc.c      ****             		CyU3PDebugPrint (4, "\r\n(1) fb %d pb %d pbc %d\r\n", fb, pb, pbc);
 6849              		.loc 1 2248 0
 6850 3ad8 BCE2D4E1 		ldrh	lr, [r4, #44]
 6851 3adc B822D4E1 		ldrh	r2, [r4, #40]
 6852 3ae0 BA32D4E1 		ldrh	r3, [r4, #42]
 6853 3ae4 A4119FE5 		ldr	r1, .L559+204
 6854 3ae8 040080E2 		add	r0, r0, #4
 6855 3aec 00E08DE5 		str	lr, [sp, #0]
 6856 3af0 FEFFFFEB 		bl	CyU3PDebugPrint
2255:../uvc.c      ****                 prodCount = 0;
 6857              		.loc 1 2255 0
 6858 3af4 BE52C4E1 		strh	r5, [r4, #46]	@ movhi
2256:../uvc.c      ****                 consCount = 0;
 6859              		.loc 1 2256 0
 6860 3af8 B053C4E1 		strh	r5, [r4, #48]	@ movhi
2257:../uvc.c      ****                 hitFV     = CyFalse;
 6861              		.loc 1 2257 0
 6862 3afc 445084E5 		str	r5, [r4, #68]
2270:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6863              		.loc 1 2270 0
 6864 3b00 8114D8E5 		ldrb	r1, [r8, #1153]	@ zero_extendqisi2
2252:../uvc.c      ****             	fb=0;
 6865              		.loc 1 2252 0
 6866 3b04 B852C4E1 		strh	r5, [r4, #40]	@ movhi
2270:../uvc.c      ****                 glUVCHeader[1] ^= CY_FX_UVC_HEADER_FRAME_ID;
 6867              		.loc 1 2270 0
 6868 3b08 010021E2 		eor	r0, r1, #1
 6869 3b0c 8104C8E5 		strb	r0, [r8, #1153]
2271:../uvc.c      ****                 if(stiflag){
 6870              		.loc 1 2271 0
 6871 3b10 9C2094E5 		ldr	r2, [r4, #156]
2272:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6872              		.loc 1 2272 0
 6873 3b14 8134D7E5 		ldrb	r3, [r7, #1153]	@ zero_extendqisi2
2271:../uvc.c      ****                 if(stiflag){
 6874              		.loc 1 2271 0
 6875 3b18 000052E3 		cmp	r2, #0
2272:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6876              		.loc 1 2272 0
 6877 3b1c 20308313 		orrne	r3, r3, #32
2275:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6878              		.loc 1 2275 0
 6879 3b20 DF300302 		andeq	r3, r3, #223
2272:../uvc.c      ****                 	glUVCHeader[1] |= (1<<5);    //set still image flag
 6880              		.loc 1 2272 0
 6881 3b24 8134C715 		strneb	r3, [r7, #1153]
2275:../uvc.c      ****                 	glUVCHeader[1] &= ~(1<<5);    //clear still image flag
 6882              		.loc 1 2275 0
 6883 3b28 8134C705 		streqb	r3, [r7, #1153]
2273:../uvc.c      ****                 	stiflag = CyFalse;
 6884              		.loc 1 2273 0
 6885 3b2c 9C508415 		strne	r5, [r4, #156]
2253:../uvc.c      ****             	pb=0;
 6886              		.loc 1 2253 0
 6887 3b30 BA52C4E1 		strh	r5, [r4, #42]	@ movhi
2254:../uvc.c      ****             	pbc=0;
 6888              		.loc 1 2254 0
 6889 3b34 BC52C4E1 		strh	r5, [r4, #44]	@ movhi
2278:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelReset (&glChHandleUVCStream);
 6890              		.loc 1 2278 0
 6891 3b38 EC009FE5 		ldr	r0, .L559+104
 6892 3b3c FEFFFFEB 		bl	CyU3PDmaMultiChannelReset
 6893              	.LVL576:
2279:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6894              		.loc 1 2279 0
 6895 3b40 002050E2 		subs	r2, r0, #0
 6896 3b44 0C00001A 		bne	.L557
2286:../uvc.c      ****                 apiRetStatus = CyU3PDmaMultiChannelSetXfer (&glChHandleUVCStream, 0, 0);
 6897              		.loc 1 2286 0
 6898 3b48 0210A0E1 		mov	r1, r2
 6899 3b4c D8009FE5 		ldr	r0, .L559+104
 6900              	.LVL577:
 6901 3b50 FEFFFFEB 		bl	CyU3PDmaMultiChannelSetXfer
 6902              	.LVL578:
2287:../uvc.c      ****                 if (apiRetStatus != CY_U3P_SUCCESS)
 6903              		.loc 1 2287 0
 6904 3b54 002050E2 		subs	r2, r0, #0
 6905 3b58 1000001A 		bne	.L558
2295:../uvc.c      ****                 CyU3PGpifSMSwitch (257, 0, 257, 0, 2);
 6906              		.loc 1 2295 0
 6907 3b5c C0009FE5 		ldr	r0, .L559+96
 6908              	.LVL579:
 6909 3b60 0210A0E1 		mov	r1, r2
 6910 3b64 02A0A0E3 		mov	sl, #2
 6911 3b68 0020A0E1 		mov	r2, r0
 6912              	.LVL580:
 6913 3b6c 0130A0E1 		mov	r3, r1
 6914 3b70 00A08DE5 		str	sl, [sp, #0]
 6915 3b74 FEFFFFEB 		bl	CyU3PGpifSMSwitch
 6916              	.LVL581:
 6917 3b78 9FFEFFEA 		b	.L510
 6918              	.LVL582:
 6919              	.L557:
2281:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Reset Failed, Error Code = %d\n", apiRetStatus
 6920              		.loc 1 2281 0
 6921 3b7c 0400A0E3 		mov	r0, #4
 6922              	.LVL583:
 6923 3b80 0C119FE5 		ldr	r1, .L559+208
 6924 3b84 FEFFFFEB 		bl	CyU3PDebugPrint
 6925              	.LVL584:
 6926              	.L514:
 6927              	.LBB268:
 6928              	.LBB269:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6929              		.loc 1 1213 0
 6930 3b88 A8109FE5 		ldr	r1, .L559+116
 6931 3b8c 0400A0E3 		mov	r0, #4
 6932 3b90 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6933              		.loc 1 1214 0
 6934 3b94 FA0FA0E3 		mov	r0, #1000
 6935 3b98 FEFFFFEB 		bl	_tx_thread_sleep
 6936 3b9c F9FFFFEA 		b	.L514
 6937              	.LVL585:
 6938              	.L558:
 6939              	.LBE269:
 6940              	.LBE268:
2289:../uvc.c      ****                     CyU3PDebugPrint (4, "DMA Channel Set Transfer Failed, Error Code = %d\n", apiRe
 6941              		.loc 1 2289 0
 6942 3ba0 0400A0E3 		mov	r0, #4
 6943              	.LVL586:
 6944 3ba4 EC109FE5 		ldr	r1, .L559+212
 6945 3ba8 FEFFFFEB 		bl	CyU3PDebugPrint
 6946              	.LVL587:
 6947              	.L516:
 6948              	.LBB270:
 6949              	.LBB271:
1213:../uvc.c      ****         CyU3PDebugPrint (4, "Error handler...\r\n");
 6950              		.loc 1 1213 0
 6951 3bac 84109FE5 		ldr	r1, .L559+116
 6952 3bb0 0400A0E3 		mov	r0, #4
 6953 3bb4 FEFFFFEB 		bl	CyU3PDebugPrint
1214:../uvc.c      ****         CyU3PThreadSleep (1000);
 6954              		.loc 1 1214 0
 6955 3bb8 FA0FA0E3 		mov	r0, #1000
 6956 3bbc FEFFFFEB 		bl	_tx_thread_sleep
 6957 3bc0 F9FFFFEA 		b	.L516
 6958              	.L560:
 6959              		.align	2
 6960              	.L559:
 6961 3bc4 50060000 		.word	.LC34
 6962 3bc8 00C20100 		.word	115200
 6963 3bcc 70060000 		.word	.LC35
 6964 3bd0 A0860100 		.word	100000
 6965 3bd4 8C060000 		.word	.LC36
 6966 3bd8 00000000 		.word	.LANCHOR0
 6967 3bdc 00000000 		.word	CyFxGpifCB
 6968 3be0 00000000 		.word	CyFxUVCApplnUSBSetupCB
 6969 3be4 00000000 		.word	CyFxUVCApplnUSBEventCB
 6970 3be8 00000000 		.word	CyFxUSBDeviceDscr
 6971 3bec 00000000 		.word	CyFxUSBDeviceDscrSS
 6972 3bf0 00000000 		.word	CyFxUSBDeviceQualDscr
 6973 3bf4 00000000 		.word	CyFxUSBBOSDscr
 6974 3bf8 00000000 		.word	CyFxUSBHSConfigDscr
 6975 3bfc 00000000 		.word	CyFxUSBFSConfigDscr
 6976 3c00 00000000 		.word	CyFxUSBSSConfigDscr
 6977 3c04 00000000 		.word	CyFxUSBStringLangIDDscr
 6978 3c08 00000000 		.word	CyFxUSBManufactureDscr
 6979 3c0c 00000000 		.word	CyFxUSBProductDscr
 6980 3c10 013F0000 		.word	16129
 6981 3c14 02030000 		.word	770
 6982 3c18 00000000 		.word	glChHandleInterStat
 6983 3c1c 00000000 		.word	glInterStaBuffer
 6984 3c20 03030000 		.word	771
 6985 3c24 01010000 		.word	257
 6986 3c28 00000000 		.word	CyFxUvcApplnDmaCallback
 6987 3c2c 00000000 		.word	glChHandleUVCStream
 6988 3c30 00000000 		.word	.LANCHOR1
 6989 3c34 A8060000 		.word	.LC37
 6990 3c38 D4010000 		.word	.LC12
 6991 3c3c F8060000 		.word	.LC39
 6992 3c40 D4060000 		.word	.LC38
 6993 3c44 20070000 		.word	.LC40
 6994 3c48 78080000 		.word	.LC47
 6995 3c4c 54090000 		.word	.LC51
 6996 3c50 24090000 		.word	.LC50
 6997 3c54 EC080000 		.word	.LC49
 6998 3c58 AC080000 		.word	.LC48
 6999 3c5c 3C0A0000 		.word	.LC57
 7000 3c60 2C000000 		.word	.LANCHOR2+44
 7001 3c64 840A0000 		.word	.LC59
 7002 3c68 2C0A0000 		.word	.LC56
 7003 3c6c 10000000 		.word	.LANCHOR2+16
 7004 3c70 4C0A0000 		.word	.LC58
 7005 3c74 F8090000 		.word	.LC55
 7006 3c78 48080000 		.word	.LC46
 7007 3c7c 18080000 		.word	.LC45
 7008 3c80 E0070000 		.word	.LC44
 7009 3c84 78070000 		.word	.LC42
 7010 3c88 4C070000 		.word	.LC41
 7011 3c8c AC070000 		.word	.LC43
 7012 3c90 7C090000 		.word	.LC52
 7013 3c94 98090000 		.word	.LC53
 7014 3c98 C4090000 		.word	.LC54
 7015              	.LBE271:
 7016              	.LBE270:
 7017              		.cfi_endproc
 7018              	.LFE18:
 7020              		.align	2
 7021              		.global	CyFxApplicationDefine
 7023              	CyFxApplicationDefine:
 7024              	.LFB26:
3595:../uvc.c      **** }
3596:../uvc.c      **** 
3597:../uvc.c      **** 
3598:../uvc.c      **** /*
3599:../uvc.c      ****  * This function is called by the FX3 framework once the ThreadX RTOS has started up.
3600:../uvc.c      ****  * The application specific threads and other OS resources are created and initialized here.
3601:../uvc.c      ****  */
3602:../uvc.c      **** void
3603:../uvc.c      **** CyFxApplicationDefine (
3604:../uvc.c      ****         void)
3605:../uvc.c      **** {
 7025              		.loc 1 3605 0
 7026              		.cfi_startproc
 7027              		@ args = 0, pretend = 0, frame = 40
 7028              		@ frame_needed = 0, uses_anonymous_args = 0
 7029              	.LVL588:
 7030 3c9c F04F2DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 7031              	.LCFI25:
 7032              		.cfi_def_cfa_offset 36
3606:../uvc.c      ****     void *ptr1, *ptr2, *ptr3;
3607:../uvc.c      ****     uint32_t retThrdCreate;
3608:../uvc.c      ****     VdRingBuf *cmdQuptr = &cmdQu;
3609:../uvc.c      ****     VdRingBuf *statQuptr = &statQu;
3610:../uvc.c      **** 
3611:../uvc.c      ****     /* Allocate the memory for the thread stacks. */
3612:../uvc.c      ****     ptr1 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7033              		.loc 1 3612 0
 7034 3ca0 010AA0E3 		mov	r0, #4096
3605:../uvc.c      **** {
 7035              		.loc 1 3605 0
 7036 3ca4 4CD04DE2 		sub	sp, sp, #76
 7037              	.LCFI26:
 7038              		.cfi_def_cfa_offset 112
 7039              		.loc 1 3612 0
 7040              		.cfi_offset 14, -4
 7041              		.cfi_offset 11, -8
 7042              		.cfi_offset 10, -12
 7043              		.cfi_offset 9, -16
 7044              		.cfi_offset 8, -20
 7045              		.cfi_offset 7, -24
 7046              		.cfi_offset 6, -28
 7047              		.cfi_offset 5, -32
 7048              		.cfi_offset 4, -36
 7049 3ca8 FEFFFFEB 		bl	CyU3PMemAlloc
 7050 3cac 00A0A0E1 		mov	sl, r0
 7051              	.LVL589:
3613:../uvc.c      ****     ptr2 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7052              		.loc 1 3613 0
 7053 3cb0 010AA0E3 		mov	r0, #4096
 7054              	.LVL590:
 7055 3cb4 FEFFFFEB 		bl	CyU3PMemAlloc
 7056 3cb8 00B0A0E1 		mov	fp, r0
 7057              	.LVL591:
3614:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7058              		.loc 1 3614 0
 7059 3cbc 010AA0E3 		mov	r0, #4096
 7060              	.LVL592:
 7061 3cc0 FEFFFFEB 		bl	CyU3PMemAlloc
3615:../uvc.c      **** 
3616:../uvc.c      ****     if ((ptr1 == 0) || (ptr2 == 0) || (ptr3 == 0))
 7062              		.loc 1 3616 0
 7063 3cc4 00005AE3 		cmp	sl, #0
 7064 3cc8 00005B13 		cmpne	fp, #0
 7065 3ccc 0090A013 		movne	r9, #0
 7066 3cd0 0190A003 		moveq	r9, #1
3614:../uvc.c      ****     ptr3 = CyU3PMemAlloc (UVC_APP_THREAD_STACK);
 7067              		.loc 1 3614 0
 7068 3cd4 24008DE5 		str	r0, [sp, #36]
 7069              	.LVL593:
 7070              		.loc 1 3616 0
 7071 3cd8 0000001A 		bne	.L565
 7072              	.LVL594:
 7073              	.L562:
 7074              	.L564:
 7075 3cdc FEFFFFEA 		b	.L564
 7076              	.L565:
 7077              		.loc 1 3616 0 is_stmt 0 discriminator 1
 7078 3ce0 000050E3 		cmp	r0, #0
 7079 3ce4 FCFFFF0A 		beq	.L562
3617:../uvc.c      ****         goto fatalErrorHandler;
3618:../uvc.c      **** 
3619:../uvc.c      **** 	/****** create a ring buffer for command queue *******/
3620:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7080              		.loc 1 3620 0 is_stmt 1
 7081 3ce8 28408DE2 		add	r4, sp, #40
 7082 3cec 0400A0E1 		mov	r0, r4
 7083 3cf0 4010A0E3 		mov	r1, #64
 7084 3cf4 18219FE5 		ldr	r2, .L566
 7085 3cf8 FEFFFFEB 		bl	cmdbufCreate
 7086 3cfc 0450A0E1 		mov	r5, r4
 7087 3d00 0F00B5E8 		ldmia	r5!, {r0, r1, r2, r3}
 7088 3d04 0C719FE5 		ldr	r7, .L566+4
3621:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7089              		.loc 1 3621 0
 7090 3d08 0C819FE5 		ldr	r8, .L566+8
3620:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7091              		.loc 1 3620 0
 7092 3d0c 07C0A0E1 		mov	ip, r7
 7093 3d10 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7094 3d14 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
3622:../uvc.c      **** 
3623:../uvc.c      **** 	/****** initialize command descriptor ***********/
3624:../uvc.c      **** 	cmdquInit(cmdQuptr);
3625:../uvc.c      **** 	cmdquInit(statQuptr);
3626:../uvc.c      **** 
3627:../uvc.c      ****     /* Create the UVC application thread. */
3628:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppThread,   /* UVC Thread structure */
 7095              		.loc 1 3628 0
 7096 3d18 0860A0E3 		mov	r6, #8
3620:../uvc.c      **** 	cmdQu = cmdbufCreate(MAXCMD, &cmdQuMux);
 7097              		.loc 1 3620 0
 7098 3d1c 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3621:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7099              		.loc 1 3621 0
 7100 3d20 F8209FE5 		ldr	r2, .L566+12
 7101 3d24 0400A0E1 		mov	r0, r4
 7102 3d28 2010A0E3 		mov	r1, #32
 7103 3d2c FEFFFFEB 		bl	cmdbufCreate
 7104 3d30 0F00B4E8 		ldmia	r4!, {r0, r1, r2, r3}
 7105 3d34 08C0A0E1 		mov	ip, r8
 7106 3d38 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 7107 3d3c 0F0095E8 		ldmia	r5, {r0, r1, r2, r3}
 7108              		.loc 1 3628 0
 7109 3d40 0140A0E3 		mov	r4, #1
3621:../uvc.c      **** 	statQu = cmdbufCreate(MAXSTA, &staQuMux);
 7110              		.loc 1 3621 0
 7111 3d44 0F008CE8 		stmia	ip, {r0, r1, r2, r3}
3624:../uvc.c      **** 	cmdquInit(cmdQuptr);
 7112              		.loc 1 3624 0
 7113 3d48 0700A0E1 		mov	r0, r7
 7114 3d4c FEFFFFEB 		bl	cmdquInit
3625:../uvc.c      **** 	cmdquInit(statQuptr);
 7115              		.loc 1 3625 0
 7116 3d50 0800A0E1 		mov	r0, r8
 7117 3d54 FEFFFFEB 		bl	cmdquInit
 7118              		.loc 1 3628 0
 7119 3d58 A850A0E3 		mov	r5, #168
 7120 3d5c 01CAA0E3 		mov	ip, #4096
 7121 3d60 BC009FE5 		ldr	r0, .L566+16
 7122 3d64 BC109FE5 		ldr	r1, .L566+20
 7123 3d68 BC209FE5 		ldr	r2, .L566+24
 7124 3d6c 0930A0E1 		mov	r3, r9
 7125 3d70 00148DE8 		stmia	sp, {sl, ip}	@ phole stm
 7126 3d74 08608DE5 		str	r6, [sp, #8]
 7127 3d78 0C608DE5 		str	r6, [sp, #12]
 7128 3d7c 10908DE5 		str	r9, [sp, #16]
 7129 3d80 14408DE5 		str	r4, [sp, #20]
 7130 3d84 18508DE5 		str	r5, [sp, #24]
 7131 3d88 FEFFFFEB 		bl	_txe_thread_create
 7132              	.LVL595:
3629:../uvc.c      ****             "30:UVC App Thread",                        /* Thread Id and name */
3630:../uvc.c      ****             UVCAppThread_Entry,                         /* UVC Application Thread Entry function */
3631:../uvc.c      ****             0,                                          /* No input parameter to thread */
3632:../uvc.c      ****             ptr1,                                       /* Pointer to the allocated thread stack */
3633:../uvc.c      ****             UVC_APP_THREAD_STACK,                       /* UVC Application Thread stack size */
3634:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3635:../uvc.c      ****             UVC_APP_THREAD_PRIORITY,                    /* Threshold value for thread pre-emption. 
3636:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3637:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3638:../uvc.c      ****             );
3639:../uvc.c      ****     if (retThrdCreate != 0)
 7133              		.loc 1 3639 0
 7134 3d8c 00C050E2 		subs	ip, r0, #0
 7135 3d90 D1FFFF1A 		bne	.L562
3640:../uvc.c      ****     {
3641:../uvc.c      ****         goto fatalErrorHandler;
3642:../uvc.c      ****     }
3643:../uvc.c      **** 
3644:../uvc.c      ****     /* Create the control request handling thread. */
3645:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&uvcAppEP0Thread,        /* UVC Thread structure */
 7136              		.loc 1 3645 0
 7137 3d94 0C30A0E1 		mov	r3, ip
 7138 3d98 027BA0E3 		mov	r7, #2048
 7139 3d9c 8C009FE5 		ldr	r0, .L566+28
 7140              	.LVL596:
 7141 3da0 8C109FE5 		ldr	r1, .L566+32
 7142 3da4 8C209FE5 		ldr	r2, .L566+36
 7143 3da8 10C08DE5 		str	ip, [sp, #16]
 7144 3dac 00B08DE5 		str	fp, [sp, #0]
 7145 3db0 04708DE5 		str	r7, [sp, #4]
 7146 3db4 08608DE5 		str	r6, [sp, #8]
 7147 3db8 0C608DE5 		str	r6, [sp, #12]
 7148 3dbc 14408DE5 		str	r4, [sp, #20]
 7149 3dc0 18508DE5 		str	r5, [sp, #24]
 7150 3dc4 FEFFFFEB 		bl	_txe_thread_create
 7151              	.LVL597:
3646:../uvc.c      ****             "31:UVC App EP0 Thread",                            /* Thread Id and name */
3647:../uvc.c      ****             UVCAppEP0Thread_Entry,                              /* UVC Application EP0 Thread Entry
3648:../uvc.c      ****             0,                                                  /* No input parameter to thread */
3649:../uvc.c      ****             ptr2,                                               /* Pointer to the allocated thread 
3650:../uvc.c      ****             UVC_APP_EP0_THREAD_STACK,                           /* UVC Application Thread stack siz
3651:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* UVC Application Thread priority 
3652:../uvc.c      ****             UVC_APP_EP0_THREAD_PRIORITY,                        /* Threshold value for thread pre-e
3653:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                                /* No time slice for the applicatio
3654:../uvc.c      ****             CYU3P_AUTO_START                                    /* Start the Thread immediately */
3655:../uvc.c      ****             );
3656:../uvc.c      ****     if (retThrdCreate != 0)
 7152              		.loc 1 3656 0
 7153 3dc8 00C050E2 		subs	ip, r0, #0
 7154 3dcc C2FFFF1A 		bne	.L562
3657:../uvc.c      ****     {
3658:../uvc.c      ****         goto fatalErrorHandler;
3659:../uvc.c      ****     }
3660:../uvc.c      **** #if 1
3661:../uvc.c      ****     /* Create the I2C control command handling thread. */
3662:../uvc.c      ****     retThrdCreate = CyU3PThreadCreate (&i2cAppThread,   /* UVC Thread structure */
 7155              		.loc 1 3662 0
 7156 3dd0 24E09DE5 		ldr	lr, [sp, #36]
 7157 3dd4 60009FE5 		ldr	r0, .L566+40
 7158              	.LVL598:
 7159 3dd8 60109FE5 		ldr	r1, .L566+44
 7160 3ddc 60209FE5 		ldr	r2, .L566+48
 7161 3de0 0C30A0E1 		mov	r3, ip
 7162 3de4 00E08DE5 		str	lr, [sp, #0]
 7163 3de8 04708DE5 		str	r7, [sp, #4]
 7164 3dec 08608DE5 		str	r6, [sp, #8]
 7165 3df0 0C608DE5 		str	r6, [sp, #12]
 7166 3df4 10C08DE5 		str	ip, [sp, #16]
 7167 3df8 14408DE5 		str	r4, [sp, #20]
 7168 3dfc 18508DE5 		str	r5, [sp, #24]
 7169 3e00 FEFFFFEB 		bl	_txe_thread_create
 7170              	.LVL599:
3663:../uvc.c      ****             "32:I2C App CTRL Thread",                        /* Thread Id and name */
3664:../uvc.c      ****             I2cAppThread_Entry,                         /* UVC Application Thread Entry function */
3665:../uvc.c      ****             0,                                          /* No input parameter to thread */
3666:../uvc.c      ****             ptr3,                                       /* Pointer to the allocated thread stack */
3667:../uvc.c      ****             UVC_APP_I2C_THREAD_STACK,                       /* UVC Application Thread stack size */
3668:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* UVC Application Thread priority */
3669:../uvc.c      ****             UVC_APP_I2C_THREAD_PRIORITY,                    /* Threshold value for thread pre-empti
3670:../uvc.c      ****             CYU3P_NO_TIME_SLICE,                        /* No time slice for the application thread
3671:../uvc.c      ****             CYU3P_AUTO_START                            /* Start the Thread immediately */
3672:../uvc.c      ****             );
3673:../uvc.c      ****     if (retThrdCreate != 0)
 7171              		.loc 1 3673 0
 7172 3e04 000050E3 		cmp	r0, #0
 7173 3e08 B3FFFF1A 		bne	.L562
3674:../uvc.c      ****     {
3675:../uvc.c      ****         goto fatalErrorHandler;
3676:../uvc.c      ****     }
3677:../uvc.c      **** #endif
3678:../uvc.c      **** 
3679:../uvc.c      ****     return;
3680:../uvc.c      **** 
3681:../uvc.c      **** fatalErrorHandler:
3682:../uvc.c      ****     /* Add custom recovery or debug actions here */
3683:../uvc.c      ****     /* Loop indefinitely */
3684:../uvc.c      ****     while (1);
3685:../uvc.c      **** }
 7174              		.loc 1 3685 0
 7175 3e0c 4CD08DE2 		add	sp, sp, #76
 7176 3e10 F08FBDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 7177              	.L567:
 7178              		.align	2
 7179              	.L566:
 7180 3e14 00000000 		.word	cmdQuMux
 7181 3e18 00000000 		.word	cmdQu
 7182 3e1c 00000000 		.word	statQu
 7183 3e20 00000000 		.word	staQuMux
 7184 3e24 A0000000 		.word	.LANCHOR0+160
 7185 3e28 BC0A0000 		.word	.LC60
 7186 3e2c 00000000 		.word	UVCAppThread_Entry
 7187 3e30 48010000 		.word	.LANCHOR0+328
 7188 3e34 D00A0000 		.word	.LC61
 7189 3e38 00000000 		.word	UVCAppEP0Thread_Entry
 7190 3e3c F0010000 		.word	.LANCHOR0+496
 7191 3e40 E80A0000 		.word	.LC62
 7192 3e44 00000000 		.word	I2cAppThread_Entry
 7193              		.cfi_endproc
 7194              	.LFE26:
 7196              		.align	2
 7197              		.global	main
 7199              	main:
 7200              	.LFB27:
3686:../uvc.c      **** 
3687:../uvc.c      **** /* Main entry point for the C code. We perform device initialization and start
3688:../uvc.c      ****  * the ThreadX RTOS here.
3689:../uvc.c      ****  */
3690:../uvc.c      **** int
3691:../uvc.c      **** main (
3692:../uvc.c      ****         void)
3693:../uvc.c      **** {
 7201              		.loc 1 3693 0
 7202              		.cfi_startproc
 7203              		@ args = 0, pretend = 0, frame = 56
 7204              		@ frame_needed = 0, uses_anonymous_args = 0
 7205 3e48 30402DE9 		stmfd	sp!, {r4, r5, lr}
 7206              	.LCFI27:
 7207              		.cfi_def_cfa_offset 12
3694:../uvc.c      ****     CyU3PReturnStatus_t apiRetStatus;
3695:../uvc.c      ****     CyU3PIoMatrixConfig_t io_cfg;
3696:../uvc.c      **** 
3697:../uvc.c      ****        CyU3PSysClockConfig_t clockConfig;
3698:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
3699:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
3700:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
3701:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
3702:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7208              		.loc 1 3702 0
 7209 3e4c 0010A0E3 		mov	r1, #0
3693:../uvc.c      **** {
 7210              		.loc 1 3693 0
 7211 3e50 3CD04DE2 		sub	sp, sp, #60
 7212              	.LCFI28:
 7213              		.cfi_def_cfa_offset 72
3699:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7214              		.loc 1 3699 0
 7215 3e54 0220A0E3 		mov	r2, #2
3703:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7216              		.loc 1 3703 0
 7217 3e58 033081E2 		add	r3, r1, #3
3698:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7218              		.loc 1 3698 0
 7219 3e5c 0150A0E3 		mov	r5, #1
 7220              		.cfi_offset 14, -4
 7221              		.cfi_offset 5, -8
 7222              		.cfi_offset 4, -12
3704:../uvc.c      **** 
3705:../uvc.c      ****     /* Initialize the device */
3706:../uvc.c      ****     apiRetStatus = CyU3PDeviceInit (&clockConfig);
 7223              		.loc 1 3706 0
 7224 3e60 28008DE2 		add	r0, sp, #40
3698:../uvc.c      ****        clockConfig.setSysClk400  = CyTrue;
 7225              		.loc 1 3698 0
 7226 3e64 28508DE5 		str	r5, [sp, #40]
3699:../uvc.c      ****        clockConfig.cpuClkDiv     = 2;
 7227              		.loc 1 3699 0
 7228 3e68 2C20CDE5 		strb	r2, [sp, #44]
3700:../uvc.c      ****        clockConfig.dmaClkDiv     = 2;
 7229              		.loc 1 3700 0
 7230 3e6c 2D20CDE5 		strb	r2, [sp, #45]
3701:../uvc.c      ****        clockConfig.mmioClkDiv    = 2;
 7231              		.loc 1 3701 0
 7232 3e70 2E20CDE5 		strb	r2, [sp, #46]
3702:../uvc.c      ****        clockConfig.useStandbyClk = CyFalse;
 7233              		.loc 1 3702 0
 7234 3e74 30108DE5 		str	r1, [sp, #48]
3703:../uvc.c      ****        clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 7235              		.loc 1 3703 0
 7236 3e78 3430CDE5 		strb	r3, [sp, #52]
 7237              		.loc 1 3706 0
 7238 3e7c FEFFFFEB 		bl	CyU3PDeviceInit
 7239              	.LVL600:
3707:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7240              		.loc 1 3707 0
 7241 3e80 004050E2 		subs	r4, r0, #0
 7242 3e84 0000000A 		beq	.L571
 7243              	.L569:
 7244              	.L570:
 7245 3e88 FEFFFFEA 		b	.L570
 7246              	.L571:
3708:../uvc.c      ****     {
3709:../uvc.c      ****         goto handle_fatal_error;
3710:../uvc.c      ****     }
3711:../uvc.c      **** 
3712:../uvc.c      ****     /* Turn on instruction cache to improve firmware performance. Use Release build to improve it f
3713:../uvc.c      ****     apiRetStatus = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);
 7247              		.loc 1 3713 0
 7248 3e8c 0410A0E1 		mov	r1, r4
 7249 3e90 0420A0E1 		mov	r2, r4
 7250 3e94 0500A0E1 		mov	r0, r5
 7251              	.LVL601:
 7252 3e98 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 7253              	.LVL602:
3714:../uvc.c      **** 
3715:../uvc.c      ****     /* Configure the IO matrix for the device. */
3716:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
3717:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
3718:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
3719:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
3720:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
3721:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
3722:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
3723:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
3724:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
3725:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
3726:../uvc.c      **** 
3727:../uvc.c      ****     apiRetStatus = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 7254              		.loc 1 3727 0
 7255 3e9c 0D00A0E1 		mov	r0, sp
3717:../uvc.c      ****     io_cfg.lppMode          = CY_U3P_IO_MATRIX_LPP_DEFAULT;
 7256              		.loc 1 3717 0
 7257 3ea0 1640CDE5 		strb	r4, [sp, #22]
3718:../uvc.c      ****     io_cfg.gpioSimpleEn[0]  = 0;
 7258              		.loc 1 3718 0
 7259 3ea4 18408DE5 		str	r4, [sp, #24]
3719:../uvc.c      ****     io_cfg.gpioSimpleEn[1]  = 0;
 7260              		.loc 1 3719 0
 7261 3ea8 1C408DE5 		str	r4, [sp, #28]
3720:../uvc.c      ****     io_cfg.gpioComplexEn[0] = 0;
 7262              		.loc 1 3720 0
 7263 3eac 20408DE5 		str	r4, [sp, #32]
3721:../uvc.c      ****     io_cfg.gpioComplexEn[1] = 0;
 7264              		.loc 1 3721 0
 7265 3eb0 24408DE5 		str	r4, [sp, #36]
3724:../uvc.c      ****     io_cfg.useI2S           = CyFalse;
 7266              		.loc 1 3724 0
 7267 3eb4 0C408DE5 		str	r4, [sp, #12]
3725:../uvc.c      ****     io_cfg.useSpi           = CyFalse;
 7268              		.loc 1 3725 0
 7269 3eb8 10408DE5 		str	r4, [sp, #16]
3716:../uvc.c      ****     io_cfg.isDQ32Bit        = CyTrue;
 7270              		.loc 1 3716 0
 7271 3ebc 00508DE5 		str	r5, [sp, #0]
3722:../uvc.c      ****     io_cfg.useUart          = CyTrue;   /* Uart is enabled for logging. */
 7272              		.loc 1 3722 0
 7273 3ec0 04508DE5 		str	r5, [sp, #4]
3723:../uvc.c      ****     io_cfg.useI2C           = CyTrue;   /* I2C is used for the sensor interface. */
 7274              		.loc 1 3723 0
 7275 3ec4 08508DE5 		str	r5, [sp, #8]
 7276              		.loc 1 3727 0
 7277 3ec8 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 7278              	.LVL603:
3728:../uvc.c      ****     if (apiRetStatus != CY_U3P_SUCCESS)
 7279              		.loc 1 3728 0
 7280 3ecc 004050E2 		subs	r4, r0, #0
 7281 3ed0 ECFFFF1A 		bne	.L569
3729:../uvc.c      ****     {
3730:../uvc.c      ****         goto handle_fatal_error;
3731:../uvc.c      ****     }
3732:../uvc.c      **** 
3733:../uvc.c      ****     /* This is a non returnable call for initializing the RTOS kernel */
3734:../uvc.c      ****     CyU3PKernelEntry ();
 7282              		.loc 1 3734 0
 7283 3ed4 FEFFFFEB 		bl	_tx_initialize_kernel_enter
 7284              	.LVL604:
3735:../uvc.c      **** 
3736:../uvc.c      ****     /* Dummy return to make the compiler happy */
3737:../uvc.c      ****     return 0;
3738:../uvc.c      **** 
3739:../uvc.c      **** handle_fatal_error:
3740:../uvc.c      ****     /* Cannot recover from this error. */
3741:../uvc.c      ****     while (1);
3742:../uvc.c      **** }
 7285              		.loc 1 3742 0
 7286 3ed8 0400A0E1 		mov	r0, r4
 7287 3edc 3CD08DE2 		add	sp, sp, #60
 7288 3ee0 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 7289              		.cfi_endproc
 7290              	.LFE27:
 7292              		.global	CyFxGpifTransition
 7293              		.global	CyFxGpifWavedata
 7294              		.global	CyFxGpifWavedataPosition
 7295              		.global	CyFxGpifRegValue
 7296              		.global	CyFxGpifConfig
 7297              		.global	CyFxGpifTransition_usb2
 7298              		.global	CyFxGpifWavedata_usb2
 7299              		.global	CyFxGpifWavedataPosition_usb2
 7300              		.global	CyFxGpifRegValue_usb2
 7301              		.global	CyFxGpifConfig_usb2
 7302              		.global	snapButFlag
 7303              		.global	testSnap
 7304              		.global	fb
 7305              		.global	pb
 7306              		.global	pbc
 7307              		.global	fbbak
 7308              		.global	pbbak
 7309              		.global	pbcbak
 7310              		.global	pbcpbak
 7311              		.global	isUsbConnected
 7312              		.global	usbSpeed
 7313              		.global	clearFeatureRqtReceived
 7314              		.global	streamingStarted
 7315              		.global	glProbeCtrl
 7316              		.global	glProbeStilCtrl
 7317              		.global	glProbeCtrl20
 7318              		.global	glProbeStilCtrl20
 7319              		.global	glUVCHeader
 7320              		.comm	glChHandleUVCStream,220,4
 7321              		.comm	glChHandleStillStream,220,4
 7322              		.comm	glChHandleInterStat,160,4
 7323              		.comm	glInterStaBuffer,4,4
 7324              		.comm	cmdQu,32,4
 7325              		.comm	statQu,32,4
 7326              		.comm	cmdQuMux,56,4
 7327              		.comm	staQuMux,56,4
 7328              		.comm	timMux,56,4
 7329              		.comm	bmReqType,1,1
 7330              		.comm	bRequest,1,1
 7331              		.comm	wValue,2,2
 7332              		.comm	wIndex,2,2
 7333              		.comm	wLength,2,2
 7334              		.comm	posTick,4,4
 7335              		.comm	I2CCmdTimer,44,4
 7336              		.section	.rodata
 7337              		.align	2
 7338              		.set	.LANCHOR2,. + 0
 7341              	ExTime:
 7342 0000 9C       		.byte	-100
 7343 0001 00       		.byte	0
 7344 0002 4E       		.byte	78
 7345 0003 00       		.byte	0
 7346 0004 27       		.byte	39
 7347 0005 00       		.byte	0
 7348 0006 14       		.byte	20
 7349 0007 00       		.byte	0
 7350 0008 0A       		.byte	10
 7351 0009 00       		.byte	0
 7352 000a 05       		.byte	5
 7353 000b 00       		.byte	0
 7354 000c 02       		.byte	2
 7355 000d 00       		.byte	0
 7356 000e 01       		.byte	1
 7357 000f 00       		.byte	0
 7360              	CyFxGpifConfig:
 7361 0010 0F00     		.short	15
 7362 0012 0000     		.space	2
 7363 0014 00000000 		.word	CyFxGpifWavedata
 7364 0018 00000000 		.word	CyFxGpifWavedataPosition
 7365 001c 0500     		.short	5
 7366 001e 0000     		.space	2
 7367 0020 00000000 		.word	CyFxGpifTransition
 7368 0024 4C00     		.short	76
 7369 0026 0000     		.space	2
 7370 0028 00000000 		.word	CyFxGpifRegValue
 7373              	CyFxGpifConfig_usb2:
 7374 002c 9300     		.short	147
 7375 002e 0000     		.space	2
 7376 0030 00000000 		.word	CyFxGpifWavedata_usb2
 7377 0034 00000000 		.word	CyFxGpifWavedataPosition_usb2
 7378 0038 0800     		.short	8
 7379 003a 0000     		.space	2
 7380 003c 00000000 		.word	CyFxGpifTransition_usb2
 7381 0040 4C00     		.short	76
 7382 0042 0000     		.space	2
 7383 0044 00000000 		.word	CyFxGpifRegValue_usb2
 7384              		.data
 7385              		.align	2
 7386              		.set	.LANCHOR1,. + 0
 7389              	ExUCtrlParArry:
 7390 0000 13       		.byte	19
 7391 0001 14       		.byte	20
 7392 0002 02       		.byte	2
 7393 0003 01       		.byte	1
 7394 0004 00       		.byte	0
 7395 0005 03       		.byte	3
 7396 0006 00       		.byte	0
 7397 0007 01       		.byte	1
 7398 0008 00       		.byte	0
 7399 0009 03       		.byte	3
 7400 000a 00       		.byte	0
 7401 000b 23       		.byte	35
 7402 000c 37       		.byte	55
 7403 000d 23       		.byte	35
 7404 000e 37       		.byte	55
 7405 000f 30       		.byte	48
 7406 0010 01       		.byte	1
 7407 0011 00       		.byte	0
 7408 0012 00       		.byte	0
 7409 0013 00000000 		.space	5
 7409      00
 7410 0018 11       		.byte	17
 7411 0019 00       		.byte	0
 7412 001a 02       		.byte	2
 7413 001b 01       		.byte	1
 7414 001c 00       		.byte	0
 7415 001d 03       		.byte	3
 7416 001e 00       		.byte	0
 7417 001f 01       		.byte	1
 7418 0020 00       		.byte	0
 7419 0021 03       		.byte	3
 7420 0022 00       		.byte	0
 7421 0023 01       		.byte	1
 7422 0024 00       		.byte	0
 7423 0025 01       		.byte	1
 7424 0026 00       		.byte	0
 7425 0027 30       		.byte	48
 7426 0028 01       		.byte	1
 7427 0029 01       		.byte	1
 7428 002a 00       		.byte	0
 7429 002b 00000000 		.space	5
 7429      00
 7430 0030 17       		.byte	23
 7431 0031 00       		.byte	0
 7432 0032 01       		.byte	1
 7433 0033 01       		.byte	1
 7434 0034 00       		.byte	0
 7435 0035 02       		.byte	2
 7436 0036 00       		.byte	0
 7437 0037 01       		.byte	1
 7438 0038 00       		.byte	0
 7439 0039 03       		.byte	3
 7440 003a 00       		.byte	0
 7441 003b 00       		.byte	0
 7442 003c 00       		.byte	0
 7443 003d 00       		.byte	0
 7444 003e 00       		.byte	0
 7445 003f 30       		.byte	48
 7446 0040 01       		.byte	1
 7447 0041 01       		.byte	1
 7448 0042 00       		.byte	0
 7449 0043 00000000 		.space	5
 7449      00
 7450 0048 00       		.byte	0
 7451 0049 00       		.byte	0
 7452 004a 04       		.byte	4
 7453 004b 01       		.byte	1
 7454 004c 00       		.byte	0
 7455 004d 38       		.byte	56
 7456 004e 01       		.byte	1
 7457 004f 01       		.byte	1
 7458 0050 00       		.byte	0
 7459 0051 03       		.byte	3
 7460 0052 00       		.byte	0
 7461 0053 4E       		.byte	78
 7462 0054 00       		.byte	0
 7463 0055 4E       		.byte	78
 7464 0056 00       		.byte	0
 7465 0057 30       		.byte	48
 7466 0058 01       		.byte	1
 7467 0059 00       		.byte	0
 7468 005a 00       		.byte	0
 7469 005b 00000000 		.space	5
 7469      00
 7470 0060 00       		.byte	0
 7471 0061 00       		.byte	0
 7472 0062 01       		.byte	1
 7473 0063 00       		.byte	0
 7474 0064 00       		.byte	0
 7475 0065 00       		.byte	0
 7476 0066 00       		.byte	0
 7477 0067 01       		.byte	1
 7478 0068 00       		.byte	0
 7479 0069 03       		.byte	3
 7480 006a 00       		.byte	0
 7481 006b 00       		.byte	0
 7482 006c 00       		.byte	0
 7483 006d 00       		.byte	0
 7484 006e 00       		.byte	0
 7485 006f 30       		.byte	48
 7486 0070 01       		.byte	1
 7487 0071 00       		.byte	0
 7488 0072 00       		.byte	0
 7489 0073 00000000 		.space	5
 7489      00
 7490 0078 00       		.byte	0
 7491 0079 00       		.byte	0
 7492 007a 02       		.byte	2
 7493 007b 00       		.byte	0
 7494 007c 00       		.byte	0
 7495 007d FF       		.byte	-1
 7496 007e 00       		.byte	0
 7497 007f 01       		.byte	1
 7498 0080 00       		.byte	0
 7499 0081 03       		.byte	3
 7500 0082 00       		.byte	0
 7501 0083 01       		.byte	1
 7502 0084 00       		.byte	0
 7503 0085 00       		.byte	0
 7504 0086 00       		.byte	0
 7505 0087 30       		.byte	48
 7506 0088 01       		.byte	1
 7507 0089 01       		.byte	1
 7508 008a 00       		.byte	0
 7509 008b 00000000 		.space	5
 7509      00
 7510 0090 00       		.byte	0
 7511 0091 00       		.byte	0
 7512 0092 02       		.byte	2
 7513 0093 00       		.byte	0
 7514 0094 00       		.byte	0
 7515 0095 00       		.byte	0
 7516 0096 00       		.byte	0
 7517 0097 00       		.byte	0
 7518 0098 00       		.byte	0
 7519 0099 03       		.byte	3
 7520 009a 00       		.byte	0
 7521 009b 00       		.byte	0
 7522 009c 00       		.byte	0
 7523 009d 00       		.byte	0
 7524 009e 00       		.byte	0
 7525 009f 30       		.byte	48
 7526 00a0 01       		.byte	1
 7527 00a1 01       		.byte	1
 7528 00a2 00       		.byte	0
 7529 00a3 00000000 		.space	5
 7529      00
 7530 00a8 00       		.byte	0
 7531 00a9 00       		.byte	0
 7532 00aa 02       		.byte	2
 7533 00ab 00       		.byte	0
 7534 00ac 00       		.byte	0
 7535 00ad 30       		.byte	48
 7536 00ae 00       		.byte	0
 7537 00af 01       		.byte	1
 7538 00b0 00       		.byte	0
 7539 00b1 03       		.byte	3
 7540 00b2 0A       		.byte	10
 7541 00b3 00       		.byte	0
 7542 00b4 00       		.byte	0
 7543 00b5 0A       		.byte	10
 7544 00b6 00       		.byte	0
 7545 00b7 30       		.byte	48
 7546 00b8 01       		.byte	1
 7547 00b9 01       		.byte	1
 7548 00ba 00       		.byte	0
 7549 00bb 00000000 		.space	5
 7549      00
 7550 00c0 00       		.byte	0
 7551 00c1 00       		.byte	0
 7552 00c2 01       		.byte	1
 7553 00c3 00       		.byte	0
 7554 00c4 00       		.byte	0
 7555 00c5 7F       		.byte	127
 7556 00c6 00       		.byte	0
 7557 00c7 01       		.byte	1
 7558 00c8 00       		.byte	0
 7559 00c9 03       		.byte	3
 7560 00ca 00       		.byte	0
 7561 00cb 00       		.byte	0
 7562 00cc 00       		.byte	0
 7563 00cd 00       		.byte	0
 7564 00ce 00       		.byte	0
 7565 00cf 30       		.byte	48
 7566 00d0 01       		.byte	1
 7567 00d1 00       		.byte	0
 7568 00d2 00       		.byte	0
 7569 00d3 00000000 		.space	5
 7569      00
 7570 00d8 00       		.byte	0
 7571 00d9 00       		.byte	0
 7572 00da 02       		.byte	2
 7573 00db 00       		.byte	0
 7574 00dc 00       		.byte	0
 7575 00dd 05       		.byte	5
 7576 00de 00       		.byte	0
 7577 00df 01       		.byte	1
 7578 00e0 00       		.byte	0
 7579 00e1 03       		.byte	3
 7580 00e2 00       		.byte	0
 7581 00e3 00       		.byte	0
 7582 00e4 00       		.byte	0
 7583 00e5 00       		.byte	0
 7584 00e6 00       		.byte	0
 7585 00e7 30       		.byte	48
 7586 00e8 01       		.byte	1
 7587 00e9 00       		.byte	0
 7588 00ea 00       		.byte	0
 7589 00eb 00000000 		.space	5
 7589      00
 7590 00f0 00       		.byte	0
 7591 00f1 00       		.byte	0
 7592 00f2 03       		.byte	3
 7593 00f3 00       		.byte	0
 7594 00f4 00       		.byte	0
 7595 00f5 0A       		.byte	10
 7596 00f6 00       		.byte	0
 7597 00f7 01       		.byte	1
 7598 00f8 00       		.byte	0
 7599 00f9 03       		.byte	3
 7600 00fa 00       		.byte	0
 7601 00fb 00       		.byte	0
 7602 00fc 00       		.byte	0
 7603 00fd 00       		.byte	0
 7604 00fe 00       		.byte	0
 7605 00ff 30       		.byte	48
 7606 0100 01       		.byte	1
 7607 0101 00       		.byte	0
 7608 0102 00       		.byte	0
 7609 0103 00000000 		.space	5
 7609      00
 7610 0108 00       		.byte	0
 7611 0109 00       		.byte	0
 7612 010a 02       		.byte	2
 7613 010b 00       		.byte	0
 7614 010c 00       		.byte	0
 7615 010d 40       		.byte	64
 7616 010e 00       		.byte	0
 7617 010f 01       		.byte	1
 7618 0110 00       		.byte	0
 7619 0111 03       		.byte	3
 7620 0112 00       		.byte	0
 7621 0113 0F       		.byte	15
 7622 0114 11       		.byte	17
 7623 0115 00       		.byte	0
 7624 0116 00       		.byte	0
 7625 0117 30       		.byte	48
 7626 0118 01       		.byte	1
 7627 0119 00       		.byte	0
 7628 011a 00       		.byte	0
 7629 011b 00000000 		.space	5
 7629      00
 7630 0120 00       		.byte	0
 7631 0121 00       		.byte	0
 7632 0122 02       		.byte	2
 7633 0123 00       		.byte	0
 7634 0124 00       		.byte	0
 7635 0125 64       		.byte	100
 7636 0126 00       		.byte	0
 7637 0127 01       		.byte	1
 7638 0128 00       		.byte	0
 7639 0129 03       		.byte	3
 7640 012a 00       		.byte	0
 7641 012b 00       		.byte	0
 7642 012c 00       		.byte	0
 7643 012d 00       		.byte	0
 7644 012e 00       		.byte	0
 7645 012f 30       		.byte	48
 7646 0130 01       		.byte	1
 7647 0131 00       		.byte	0
 7648 0132 00       		.byte	0
 7649 0133 00000000 		.space	5
 7649      00
 7650 0138 00       		.byte	0
 7651 0139 00       		.byte	0
 7652 013a 02       		.byte	2
 7653 013b 00       		.byte	0
 7654 013c 00       		.byte	0
 7655 013d 64       		.byte	100
 7656 013e 00       		.byte	0
 7657 013f 01       		.byte	1
 7658 0140 00       		.byte	0
 7659 0141 03       		.byte	3
 7660 0142 00       		.byte	0
 7661 0143 00       		.byte	0
 7662 0144 00       		.byte	0
 7663 0145 00       		.byte	0
 7664 0146 00       		.byte	0
 7665 0147 30       		.byte	48
 7666 0148 01       		.byte	1
 7667 0149 00       		.byte	0
 7668 014a 00       		.byte	0
 7669 014b 00000000 		.space	5
 7669      00
 7670 0150 00       		.byte	0
 7671 0151 00       		.byte	0
 7672 0152 02       		.byte	2
 7673 0153 00       		.byte	0
 7674 0154 00       		.byte	0
 7675 0155 64       		.byte	100
 7676 0156 00       		.byte	0
 7677 0157 01       		.byte	1
 7678 0158 00       		.byte	0
 7679 0159 03       		.byte	3
 7680 015a 00       		.byte	0
 7681 015b 00       		.byte	0
 7682 015c 00       		.byte	0
 7683 015d 00       		.byte	0
 7684 015e 00       		.byte	0
 7685 015f 30       		.byte	48
 7686 0160 01       		.byte	1
 7687 0161 00       		.byte	0
 7688 0162 00       		.byte	0
 7689 0163 00000000 		.space	5
 7689      00
 7690 0168 00       		.byte	0
 7691 0169 00       		.byte	0
 7692 016a 02       		.byte	2
 7693 016b 00       		.byte	0
 7694 016c 00       		.byte	0
 7695 016d 64       		.byte	100
 7696 016e 00       		.byte	0
 7697 016f 01       		.byte	1
 7698 0170 00       		.byte	0
 7699 0171 03       		.byte	3
 7700 0172 00       		.byte	0
 7701 0173 00       		.byte	0
 7702 0174 00       		.byte	0
 7703 0175 00       		.byte	0
 7704 0176 00       		.byte	0
 7705 0177 30       		.byte	48
 7706 0178 01       		.byte	1
 7707 0179 00       		.byte	0
 7708 017a 00       		.byte	0
 7709 017b 00000000 		.space	5
 7709      00
 7712              	CtrlParArry:
 7713 0180 10       		.byte	16
 7714 0181 10       		.byte	16
 7715 0182 02       		.byte	2
 7716 0183 00       		.byte	0
 7717 0184 00       		.byte	0
 7718 0185 03       		.byte	3
 7719 0186 00       		.byte	0
 7720 0187 01       		.byte	1
 7721 0188 00       		.byte	0
 7722 0189 03       		.byte	3
 7723 018a 00       		.byte	0
 7724 018b 03       		.byte	3
 7725 018c 00       		.byte	0
 7726 018d 03       		.byte	3
 7727 018e 00       		.byte	0
 7728 018f 30       		.byte	48
 7729 0190 01       		.byte	1
 7730 0191 00       		.byte	0
 7731 0192 00       		.byte	0
 7732 0193 00000000 		.space	5
 7732      00
 7733 0198 01       		.byte	1
 7734 0199 00       		.byte	0
 7735 019a 02       		.byte	2
 7736 019b 00       		.byte	0
 7737 019c 00       		.byte	0
 7738 019d FF       		.byte	-1
 7739 019e 00       		.byte	0
 7740 019f 01       		.byte	1
 7741 01a0 00       		.byte	0
 7742 01a1 03       		.byte	3
 7743 01a2 00       		.byte	0
 7744 01a3 76       		.byte	118
 7745 01a4 00       		.byte	0
 7746 01a5 76       		.byte	118
 7747 01a6 C7       		.byte	-57
 7748 01a7 C6       		.byte	-58
 7749 01a8 01       		.byte	1
 7750 01a9 01       		.byte	1
 7751 01aa 00       		.byte	0
 7752 01ab 00000000 		.space	5
 7752      00
 7753 01b0 02       		.byte	2
 7754 01b1 02       		.byte	2
 7755 01b2 02       		.byte	2
 7756 01b3 00       		.byte	0
 7757 01b4 00       		.byte	0
 7758 01b5 FF       		.byte	-1
 7759 01b6 00       		.byte	0
 7760 01b7 01       		.byte	1
 7761 01b8 00       		.byte	0
 7762 01b9 03       		.byte	3
 7763 01ba 00       		.byte	0
 7764 01bb 70       		.byte	112
 7765 01bc 00       		.byte	0
 7766 01bd 70       		.byte	112
 7767 01be 00       		.byte	0
 7768 01bf C6       		.byte	-58
 7769 01c0 01       		.byte	1
 7770 01c1 01       		.byte	1
 7771 01c2 00       		.byte	0
 7772 01c3 00000000 		.space	5
 7772      00
 7773 01c8 00       		.byte	0
 7774 01c9 00       		.byte	0
 7775 01ca 02       		.byte	2
 7776 01cb 00       		.byte	0
 7777 01cc 00       		.byte	0
 7778 01cd 64       		.byte	100
 7779 01ce 00       		.byte	0
 7780 01cf 01       		.byte	1
 7781 01d0 00       		.byte	0
 7782 01d1 03       		.byte	3
 7783 01d2 00       		.byte	0
 7784 01d3 00       		.byte	0
 7785 01d4 00       		.byte	0
 7786 01d5 00       		.byte	0
 7787 01d6 00       		.byte	0
 7788 01d7 30       		.byte	48
 7789 01d8 01       		.byte	1
 7790 01d9 00       		.byte	0
 7791 01da 00       		.byte	0
 7792 01db 00000000 		.space	5
 7792      00
 7793 01e0 07       		.byte	7
 7794 01e1 07       		.byte	7
 7795 01e2 02       		.byte	2
 7796 01e3 00       		.byte	0
 7797 01e4 00       		.byte	0
 7798 01e5 01       		.byte	1
 7799 01e6 00       		.byte	0
 7800 01e7 01       		.byte	1
 7801 01e8 00       		.byte	0
 7802 01e9 03       		.byte	3
 7803 01ea 00       		.byte	0
 7804 01eb 01       		.byte	1
 7805 01ec 00       		.byte	0
 7806 01ed 01       		.byte	1
 7807 01ee 00       		.byte	0
 7808 01ef 30       		.byte	48
 7809 01f0 01       		.byte	1
 7810 01f1 00       		.byte	0
 7811 01f2 00       		.byte	0
 7812 01f3 00000000 		.space	5
 7812      00
 7813 01f8 DF       		.byte	-33
 7814 01f9 E1       		.byte	-31
 7815 01fa 02       		.byte	2
 7816 01fb 00       		.byte	0
 7817 01fc 00       		.byte	0
 7818 01fd FF       		.byte	-1
 7819 01fe 00       		.byte	0
 7820 01ff 01       		.byte	1
 7821 0200 00       		.byte	0
 7822 0201 03       		.byte	3
 7823 0202 00       		.byte	0
 7824 0203 80       		.byte	-128
 7825 0204 00       		.byte	0
 7826 0205 00       		.byte	0
 7827 0206 00       		.byte	0
 7828 0207 C6       		.byte	-58
 7829 0208 01       		.byte	1
 7830 0209 01       		.byte	1
 7831 020a 00       		.byte	0
 7832 020b 00000000 		.space	5
 7832      00
 7833 0210 85       		.byte	-123
 7834 0211 86       		.byte	-122
 7835 0212 02       		.byte	2
 7836 0213 00       		.byte	0
 7837 0214 00       		.byte	0
 7838 0215 64       		.byte	100
 7839 0216 00       		.byte	0
 7840 0217 01       		.byte	1
 7841 0218 00       		.byte	0
 7842 0219 03       		.byte	3
 7843 021a 00       		.byte	0
 7844 021b 32       		.byte	50
 7845 021c 00       		.byte	0
 7846 021d 32       		.byte	50
 7847 021e 00       		.byte	0
 7848 021f F2       		.byte	-14
 7849 0220 01       		.byte	1
 7850 0221 01       		.byte	1
 7851 0222 00       		.byte	0
 7852 0223 00000000 		.space	5
 7852      00
 7853 0228 06       		.byte	6
 7854 0229 06       		.byte	6
 7855 022a 02       		.byte	2
 7856 022b 00       		.byte	0
 7857 022c 00       		.byte	0
 7858 022d 40       		.byte	64
 7859 022e 00       		.byte	0
 7860 022f 01       		.byte	1
 7861 0230 00       		.byte	0
 7862 0231 03       		.byte	3
 7863 0232 00       		.byte	0
 7864 0233 20       		.byte	32
 7865 0234 00       		.byte	0
 7866 0235 20       		.byte	32
 7867 0236 00       		.byte	0
 7868 0237 30       		.byte	48
 7869 0238 01       		.byte	1
 7870 0239 01       		.byte	1
 7871 023a 00       		.byte	0
 7872 023b 00000000 		.space	5
 7872      00
 7873 0240 00       		.byte	0
 7874 0241 00       		.byte	0
 7875 0242 02       		.byte	2
 7876 0243 00       		.byte	0
 7877 0244 00       		.byte	0
 7878 0245 64       		.byte	100
 7879 0246 00       		.byte	0
 7880 0247 01       		.byte	1
 7881 0248 00       		.byte	0
 7882 0249 03       		.byte	3
 7883 024a 00       		.byte	0
 7884 024b 00       		.byte	0
 7885 024c 00       		.byte	0
 7886 024d 00       		.byte	0
 7887 024e 00       		.byte	0
 7888 024f 30       		.byte	48
 7889 0250 01       		.byte	1
 7890 0251 00       		.byte	0
 7891 0252 00       		.byte	0
 7892 0253 00000000 		.space	5
 7892      00
 7893 0258 08       		.byte	8
 7894 0259 08       		.byte	8
 7895 025a 02       		.byte	2
 7896 025b 00       		.byte	0
 7897 025c 00       		.byte	0
 7898 025d 05       		.byte	5
 7899 025e 00       		.byte	0
 7900 025f 01       		.byte	1
 7901 0260 00       		.byte	0
 7902 0261 03       		.byte	3
 7903 0262 00       		.byte	0
 7904 0263 00       		.byte	0
 7905 0264 00       		.byte	0
 7906 0265 00       		.byte	0
 7907 0266 00       		.byte	0
 7908 0267 30       		.byte	48
 7909 0268 01       		.byte	1
 7910 0269 00       		.byte	0
 7911 026a 00       		.byte	0
 7912 026b 00000000 		.space	5
 7912      00
 7913 0270 00       		.byte	0
 7914 0271 00       		.byte	0
 7915 0272 02       		.byte	2
 7916 0273 00       		.byte	0
 7917 0274 00       		.byte	0
 7918 0275 40       		.byte	64
 7919 0276 00       		.byte	0
 7920 0277 01       		.byte	1
 7921 0278 00       		.byte	0
 7922 0279 03       		.byte	3
 7923 027a 00       		.byte	0
 7924 027b 00       		.byte	0
 7925 027c 00       		.byte	0
 7926 027d 00       		.byte	0
 7927 027e 00       		.byte	0
 7928 027f 30       		.byte	48
 7929 0280 01       		.byte	1
 7930 0281 00       		.byte	0
 7931 0282 00       		.byte	0
 7932 0283 00000000 		.space	5
 7932      00
 7933 0288 09       		.byte	9
 7934 0289 0A       		.byte	10
 7935 028a 04       		.byte	4
 7936 028b 00       		.byte	0
 7937 028c 00       		.byte	0
 7938 028d 40       		.byte	64
 7939 028e 00       		.byte	0
 7940 028f 01       		.byte	1
 7941 0290 00       		.byte	0
 7942 0291 03       		.byte	3
 7943 0292 00       		.byte	0
 7944 0293 20       		.byte	32
 7945 0294 38       		.byte	56
 7946 0295 20       		.byte	32
 7947 0296 38       		.byte	56
 7948 0297 30       		.byte	48
 7949 0298 01       		.byte	1
 7950 0299 00       		.byte	0
 7951 029a 00       		.byte	0
 7952 029b 00000000 		.space	5
 7952      00
 7953 02a0 00       		.byte	0
 7954 02a1 00       		.byte	0
 7955 02a2 02       		.byte	2
 7956 02a3 00       		.byte	0
 7957 02a4 00       		.byte	0
 7958 02a5 64       		.byte	100
 7959 02a6 00       		.byte	0
 7960 02a7 01       		.byte	1
 7961 02a8 00       		.byte	0
 7962 02a9 03       		.byte	3
 7963 02aa 00       		.byte	0
 7964 02ab 00       		.byte	0
 7965 02ac 00       		.byte	0
 7966 02ad 00       		.byte	0
 7967 02ae 00       		.byte	0
 7968 02af 30       		.byte	48
 7969 02b0 01       		.byte	1
 7970 02b1 00       		.byte	0
 7971 02b2 00       		.byte	0
 7972 02b3 00000000 		.space	5
 7972      00
 7973 02b8 00       		.byte	0
 7974 02b9 00       		.byte	0
 7975 02ba 02       		.byte	2
 7976 02bb 00       		.byte	0
 7977 02bc 00       		.byte	0
 7978 02bd 64       		.byte	100
 7979 02be 00       		.byte	0
 7980 02bf 01       		.byte	1
 7981 02c0 00       		.byte	0
 7982 02c1 03       		.byte	3
 7983 02c2 00       		.byte	0
 7984 02c3 00       		.byte	0
 7985 02c4 00       		.byte	0
 7986 02c5 00       		.byte	0
 7987 02c6 00       		.byte	0
 7988 02c7 30       		.byte	48
 7989 02c8 01       		.byte	1
 7990 02c9 00       		.byte	0
 7991 02ca 00       		.byte	0
 7992 02cb 00000000 		.space	5
 7992      00
 7993 02d0 2A       		.byte	42
 7994 02d1 2A       		.byte	42
 7995 02d2 02       		.byte	2
 7996 02d3 00       		.byte	0
 7997 02d4 00       		.byte	0
 7998 02d5 1B       		.byte	27
 7999 02d6 00       		.byte	0
 8000 02d7 01       		.byte	1
 8001 02d8 00       		.byte	0
 8002 02d9 03       		.byte	3
 8003 02da 00       		.byte	0
 8004 02db 00       		.byte	0
 8005 02dc 00       		.byte	0
 8006 02dd 00       		.byte	0
 8007 02de 00       		.byte	0
 8008 02df 30       		.byte	48
 8009 02e0 01       		.byte	1
 8010 02e1 00       		.byte	0
 8011 02e2 00       		.byte	0
 8012 02e3 00000000 		.space	5
 8012      00
 8013 02e8 00       		.byte	0
 8014 02e9 00       		.byte	0
 8015 02ea 02       		.byte	2
 8016 02eb 00       		.byte	0
 8017 02ec 00       		.byte	0
 8018 02ed 64       		.byte	100
 8019 02ee 00       		.byte	0
 8020 02ef 01       		.byte	1
 8021 02f0 00       		.byte	0
 8022 02f1 03       		.byte	3
 8023 02f2 00       		.byte	0
 8024 02f3 00       		.byte	0
 8025 02f4 00       		.byte	0
 8026 02f5 00       		.byte	0
 8027 02f6 00       		.byte	0
 8028 02f7 30       		.byte	48
 8029 02f8 01       		.byte	1
 8030 02f9 00       		.byte	0
 8031 02fa 00       		.byte	0
 8032 02fb 00000000 		.space	5
 8032      00
 8033 0300 00       		.byte	0
 8034 0301 00       		.byte	0
 8035 0302 02       		.byte	2
 8036 0303 00       		.byte	0
 8037 0304 00       		.byte	0
 8038 0305 12       		.byte	18
 8039 0306 00       		.byte	0
 8040 0307 01       		.byte	1
 8041 0308 00       		.byte	0
 8042 0309 03       		.byte	3
 8043 030a 00       		.byte	0
 8044 030b 00       		.byte	0
 8045 030c 00       		.byte	0
 8046 030d 00       		.byte	0
 8047 030e 00       		.byte	0
 8048 030f 30       		.byte	48
 8049 0310 01       		.byte	1
 8050 0311 00       		.byte	0
 8051 0312 00       		.byte	0
 8052 0313 00000000 		.space	5
 8052      00
 8053 0318 01       		.byte	1
 8054 0319 01       		.byte	1
 8055 031a 02       		.byte	2
 8056 031b 00       		.byte	0
 8057 031c 00       		.byte	0
 8058 031d 09       		.byte	9
 8059 031e 00       		.byte	0
 8060 031f 01       		.byte	1
 8061 0320 00       		.byte	0
 8062 0321 03       		.byte	3
 8063 0322 00       		.byte	0
 8064 0323 00       		.byte	0
 8065 0324 00       		.byte	0
 8066 0325 01       		.byte	1
 8067 0326 00       		.byte	0
 8068 0327 30       		.byte	48
 8069 0328 01       		.byte	1
 8070 0329 00       		.byte	0
 8071 032a 00       		.byte	0
 8072 032b 00000000 		.space	5
 8072      00
 8073 0330 05       		.byte	5
 8074 0331 05       		.byte	5
 8075 0332 02       		.byte	2
 8076 0333 00       		.byte	0
 8077 0334 00       		.byte	0
 8078 0335 03       		.byte	3
 8079 0336 00       		.byte	0
 8080 0337 01       		.byte	1
 8081 0338 00       		.byte	0
 8082 0339 03       		.byte	3
 8083 033a 00       		.byte	0
 8084 033b 00       		.byte	0
 8085 033c 00       		.byte	0
 8086 033d 02       		.byte	2
 8087 033e 00       		.byte	0
 8088 033f 30       		.byte	48
 8089 0340 01       		.byte	1
 8090 0341 00       		.byte	0
 8091 0342 00       		.byte	0
 8092 0343 00000000 		.space	5
 8092      00
 8093 0348 18       		.byte	24
 8094 0349 18       		.byte	24
 8095 034a 02       		.byte	2
 8096 034b 00       		.byte	0
 8097 034c 00       		.byte	0
 8098 034d 01       		.byte	1
 8099 034e 00       		.byte	0
 8100 034f 01       		.byte	1
 8101 0350 00       		.byte	0
 8102 0351 03       		.byte	3
 8103 0352 00       		.byte	0
 8104 0353 00       		.byte	0
 8105 0354 00       		.byte	0
 8106 0355 00       		.byte	0
 8107 0356 00       		.byte	0
 8108 0357 30       		.byte	48
 8109 0358 01       		.byte	1
 8110 0359 00       		.byte	0
 8111 035a 00       		.byte	0
 8112 035b 00000000 		.space	5
 8112      00
 8113 0360 19       		.byte	25
 8114 0361 19       		.byte	25
 8115 0362 01       		.byte	1
 8116 0363 00       		.byte	0
 8117 0364 00       		.byte	0
 8118 0365 40       		.byte	64
 8119 0366 00       		.byte	0
 8120 0367 01       		.byte	1
 8121 0368 00       		.byte	0
 8122 0369 03       		.byte	3
 8123 036a 00       		.byte	0
 8124 036b 20       		.byte	32
 8125 036c 00       		.byte	0
 8126 036d 20       		.byte	32
 8127 036e 00       		.byte	0
 8128 036f 30       		.byte	48
 8129 0370 01       		.byte	1
 8130 0371 00       		.byte	0
 8131 0372 00       		.byte	0
 8132 0373 00000000 		.space	5
 8132      00
 8133 0378 20       		.byte	32
 8134 0379 20       		.byte	32
 8135 037a 02       		.byte	2
 8136 037b 00       		.byte	0
 8137 037c 00       		.byte	0
 8138 037d 02       		.byte	2
 8139 037e 00       		.byte	0
 8140 037f 01       		.byte	1
 8141 0380 00       		.byte	0
 8142 0381 03       		.byte	3
 8143 0382 00       		.byte	0
 8144 0383 00       		.byte	0
 8145 0384 00       		.byte	0
 8146 0385 00       		.byte	0
 8147 0386 00       		.byte	0
 8148 0387 30       		.byte	48
 8149 0388 01       		.byte	1
 8150 0389 00       		.byte	0
 8151 038a 00       		.byte	0
 8152 038b 00000000 		.space	5
 8152      00
 8153 0390 22       		.byte	34
 8154 0391 22       		.byte	34
 8155 0392 02       		.byte	2
 8156 0393 00       		.byte	0
 8157 0394 00       		.byte	0
 8158 0395 3F       		.byte	63
 8159 0396 00       		.byte	0
 8160 0397 01       		.byte	1
 8161 0398 00       		.byte	0
 8162 0399 03       		.byte	3
 8163 039a 00       		.byte	0
 8164 039b 00       		.byte	0
 8165 039c 00       		.byte	0
 8166 039d 00       		.byte	0
 8167 039e 00       		.byte	0
 8168 039f 30       		.byte	48
 8169 03a0 01       		.byte	1
 8170 03a1 00       		.byte	0
 8171 03a2 00       		.byte	0
 8172 03a3 00000000 		.space	5
 8172      00
 8173 03a8 23       		.byte	35
 8174 03a9 23       		.byte	35
 8175 03aa 02       		.byte	2
 8176 03ab 00       		.byte	0
 8177 03ac 00       		.byte	0
 8178 03ad 64       		.byte	100
 8179 03ae 00       		.byte	0
 8180 03af 01       		.byte	1
 8181 03b0 00       		.byte	0
 8182 03b1 03       		.byte	3
 8183 03b2 00       		.byte	0
 8184 03b3 10       		.byte	16
 8185 03b4 00       		.byte	0
 8186 03b5 10       		.byte	16
 8187 03b6 00       		.byte	0
 8188 03b7 30       		.byte	48
 8189 03b8 01       		.byte	1
 8190 03b9 00       		.byte	0
 8191 03ba 00       		.byte	0
 8192 03bb 00000000 		.space	5
 8192      00
 8193 03c0 24       		.byte	36
 8194 03c1 24       		.byte	36
 8195 03c2 02       		.byte	2
 8196 03c3 00       		.byte	0
 8197 03c4 00       		.byte	0
 8198 03c5 64       		.byte	100
 8199 03c6 00       		.byte	0
 8200 03c7 01       		.byte	1
 8201 03c8 00       		.byte	0
 8202 03c9 03       		.byte	3
 8203 03ca 00       		.byte	0
 8204 03cb 10       		.byte	16
 8205 03cc 00       		.byte	0
 8206 03cd 10       		.byte	16
 8207 03ce 00       		.byte	0
 8208 03cf 30       		.byte	48
 8209 03d0 01       		.byte	1
 8210 03d1 00       		.byte	0
 8211 03d2 00       		.byte	0
 8212 03d3 00000000 		.space	5
 8212      00
 8213 03d8 02       		.byte	2
 8214 03d9 03       		.byte	3
 8215 03da 04       		.byte	4
 8216 03db 00       		.byte	0
 8217 03dc 00       		.byte	0
 8218 03dd 7F       		.byte	127
 8219 03de 00       		.byte	0
 8220 03df 01       		.byte	1
 8221 03e0 00       		.byte	0
 8222 03e1 03       		.byte	3
 8223 03e2 00       		.byte	0
 8224 03e3 00       		.byte	0
 8225 03e4 20       		.byte	32
 8226 03e5 00       		.byte	0
 8227 03e6 20       		.byte	32
 8228 03e7 30       		.byte	48
 8229 03e8 01       		.byte	1
 8230 03e9 00       		.byte	0
 8231 03ea 00       		.byte	0
 8232 03eb 00000000 		.space	5
 8232      00
 8233 03f0 04       		.byte	4
 8234 03f1 04       		.byte	4
 8235 03f2 02       		.byte	2
 8236 03f3 00       		.byte	0
 8237 03f4 00       		.byte	0
 8238 03f5 40       		.byte	64
 8239 03f6 00       		.byte	0
 8240 03f7 01       		.byte	1
 8241 03f8 00       		.byte	0
 8242 03f9 03       		.byte	3
 8243 03fa 00       		.byte	0
 8244 03fb 20       		.byte	32
 8245 03fc 00       		.byte	0
 8246 03fd 20       		.byte	32
 8247 03fe 00       		.byte	0
 8248 03ff 30       		.byte	48
 8249 0400 01       		.byte	1
 8250 0401 00       		.byte	0
 8251 0402 00       		.byte	0
 8252 0403 00000000 		.space	5
 8252      00
 8253 0408 00       		.byte	0
 8254 0409 00       		.byte	0
 8255 040a 02       		.byte	2
 8256 040b 00       		.byte	0
 8257 040c 00       		.byte	0
 8258 040d 19       		.byte	25
 8259 040e 00       		.byte	0
 8260 040f 01       		.byte	1
 8261 0410 00       		.byte	0
 8262 0411 03       		.byte	3
 8263 0412 00       		.byte	0
 8264 0413 00       		.byte	0
 8265 0414 00       		.byte	0
 8266 0415 00       		.byte	0
 8267 0416 00       		.byte	0
 8268 0417 30       		.byte	48
 8269 0418 01       		.byte	1
 8270 0419 00       		.byte	0
 8271 041a 00       		.byte	0
 8272 041b 00000000 		.space	5
 8272      00
 8273 0420 10       		.byte	16
 8274 0421 10       		.byte	16
 8275 0422 02       		.byte	2
 8276 0423 00       		.byte	0
 8277 0424 00       		.byte	0
 8278 0425 06       		.byte	6
 8279 0426 00       		.byte	0
 8280 0427 01       		.byte	1
 8281 0428 00       		.byte	0
 8282 0429 03       		.byte	3
 8283 042a 00       		.byte	0
 8284 042b 03       		.byte	3
 8285 042c 00       		.byte	0
 8286 042d 03       		.byte	3
 8287 042e 00       		.byte	0
 8288 042f 30       		.byte	48
 8289 0430 01       		.byte	1
 8290 0431 00       		.byte	0
 8291 0432 00       		.byte	0
 8292 0433 00000000 		.space	5
 8292      00
 8293 0438 00       		.byte	0
 8294 0439 00       		.byte	0
 8295 043a 02       		.byte	2
 8296 043b 00       		.byte	0
 8297 043c 00       		.byte	0
 8298 043d 03       		.byte	3
 8299 043e 00       		.byte	0
 8300 043f 01       		.byte	1
 8301 0440 00       		.byte	0
 8302 0441 03       		.byte	3
 8303 0442 00       		.byte	0
 8304 0443 00       		.byte	0
 8305 0444 00       		.byte	0
 8306 0445 00       		.byte	0
 8307 0446 00       		.byte	0
 8308 0447 30       		.byte	48
 8309 0448 01       		.byte	1
 8310 0449 00       		.byte	0
 8311 044a 00       		.byte	0
 8312 044b 00000000 		.space	5
 8312      00
 8313 0450 50       		.byte	80
 8314 0451 50       		.byte	80
 8315 0452 01       		.byte	1
 8316 0453 00       		.byte	0
 8317 0454 00       		.byte	0
 8318 0455 03       		.byte	3
 8319 0456 00       		.byte	0
 8320 0457 01       		.byte	1
 8321 0458 00       		.byte	0
 8322 0459 03       		.byte	3
 8323 045a 00       		.byte	0
 8324 045b 00       		.byte	0
 8325 045c 00       		.byte	0
 8326 045d 00       		.byte	0
 8327 045e 00       		.byte	0
 8328 045f 30       		.byte	48
 8329 0460 01       		.byte	1
 8330 0461 00       		.byte	0
 8331 0462 00       		.byte	0
 8332 0463 00000000 		.space	5
 8332      00
 8333 0468 00       		.byte	0
 8334 0469 00       		.byte	0
 8335 046a 0B       		.byte	11
 8336 046b 00       		.byte	0
 8337 046c 00       		.byte	0
 8338 046d FF       		.byte	-1
 8339 046e FF       		.byte	-1
 8340 046f 01       		.byte	1
 8341 0470 00       		.byte	0
 8342 0471 03       		.byte	3
 8343 0472 00       		.byte	0
 8344 0473 00       		.byte	0
 8345 0474 00       		.byte	0
 8346 0475 00       		.byte	0
 8347 0476 00       		.byte	0
 8348 0477 00       		.byte	0
 8349 0478 01       		.byte	1
 8350 0479 00       		.byte	0
 8351 047a 00       		.byte	0
 8352 047b 00000000 		.space	5
 8352      00
 8355              	glUVCHeader:
 8356 0480 0C       		.byte	12
 8357 0481 8C       		.byte	-116
 8358 0482 00       		.byte	0
 8359 0483 00       		.byte	0
 8360 0484 00       		.byte	0
 8361 0485 00       		.byte	0
 8362 0486 00       		.byte	0
 8363 0487 00       		.byte	0
 8364 0488 00       		.byte	0
 8365 0489 00       		.byte	0
 8366 048a 00       		.byte	0
 8367 048b 00       		.byte	0
 8370              	WBMenuCmpArry:
 8371 048c 20       		.byte	32
 8372 048d 0F       		.byte	15
 8373 048e 38       		.byte	56
 8374 048f F0       		.byte	-16
 8377              	CTCtrlParArry:
 8378 0490 00       		.byte	0
 8379 0491 00       		.byte	0
 8380 0492 01       		.byte	1
 8381 0493 00       		.byte	0
 8382 0494 00       		.byte	0
 8383 0495 03       		.byte	3
 8384 0496 00       		.byte	0
 8385 0497 01       		.byte	1
 8386 0498 00       		.byte	0
 8387 0499 03       		.byte	3
 8388 049a 00       		.byte	0
 8389 049b 03       		.byte	3
 8390 049c 00       		.byte	0
 8391 049d 03       		.byte	3
 8392 049e 00       		.byte	0
 8393 049f 30       		.byte	48
 8394 04a0 01       		.byte	1
 8395 04a1 00       		.byte	0
 8396 04a2 00       		.byte	0
 8397 04a3 00000000 		.space	5
 8397      00
 8398 04a8 00       		.byte	0
 8399 04a9 00       		.byte	0
 8400 04aa 01       		.byte	1
 8401 04ab 01       		.byte	1
 8402 04ac 00       		.byte	0
 8403 04ad 0F       		.byte	15
 8404 04ae 00       		.byte	0
 8405 04af 0F       		.byte	15
 8406 04b0 00       		.byte	0
 8407 04b1 03       		.byte	3
 8408 04b2 00       		.byte	0
 8409 04b3 02       		.byte	2
 8410 04b4 00       		.byte	0
 8411 04b5 02       		.byte	2
 8412 04b6 00       		.byte	0
 8413 04b7 30       		.byte	48
 8414 04b8 01       		.byte	1
 8415 04b9 01       		.byte	1
 8416 04ba 00       		.byte	0
 8417 04bb 00000000 		.space	5
 8417      00
 8418 04c0 02       		.byte	2
 8419 04c1 00       		.byte	0
 8420 04c2 01       		.byte	1
 8421 04c3 00       		.byte	0
 8422 04c4 00       		.byte	0
 8423 04c5 01       		.byte	1
 8424 04c6 00       		.byte	0
 8425 04c7 01       		.byte	1
 8426 04c8 00       		.byte	0
 8427 04c9 03       		.byte	3
 8428 04ca 00       		.byte	0
 8429 04cb 00       		.byte	0
 8430 04cc 00       		.byte	0
 8431 04cd 00       		.byte	0
 8432 04ce 00       		.byte	0
 8433 04cf 30       		.byte	48
 8434 04d0 01       		.byte	1
 8435 04d1 01       		.byte	1
 8436 04d2 00       		.byte	0
 8437 04d3 00000000 		.space	5
 8437      00
 8438 04d8 00       		.byte	0
 8439 04d9 00       		.byte	0
 8440 04da 04       		.byte	4
 8441 04db 01       		.byte	1
 8442 04dc 00       		.byte	0
 8443 04dd 38       		.byte	56
 8444 04de 01       		.byte	1
 8445 04df 01       		.byte	1
 8446 04e0 00       		.byte	0
 8447 04e1 03       		.byte	3
 8448 04e2 00       		.byte	0
 8449 04e3 4E       		.byte	78
 8450 04e4 00       		.byte	0
 8451 04e5 4E       		.byte	78
 8452 04e6 00       		.byte	0
 8453 04e7 30       		.byte	48
 8454 04e8 01       		.byte	1
 8455 04e9 00       		.byte	0
 8456 04ea 00       		.byte	0
 8457 04eb 00000000 		.space	5
 8457      00
 8458 04f0 04       		.byte	4
 8459 04f1 00       		.byte	0
 8460 04f2 01       		.byte	1
 8461 04f3 00       		.byte	0
 8462 04f4 00       		.byte	0
 8463 04f5 00       		.byte	0
 8464 04f6 00       		.byte	0
 8465 04f7 01       		.byte	1
 8466 04f8 00       		.byte	0
 8467 04f9 03       		.byte	3
 8468 04fa 00       		.byte	0
 8469 04fb 00       		.byte	0
 8470 04fc 00       		.byte	0
 8471 04fd 00       		.byte	0
 8472 04fe 00       		.byte	0
 8473 04ff 30       		.byte	48
 8474 0500 01       		.byte	1
 8475 0501 00       		.byte	0
 8476 0502 00       		.byte	0
 8477 0503 00000000 		.space	5
 8477      00
 8478 0508 05       		.byte	5
 8479 0509 00       		.byte	0
 8480 050a 02       		.byte	2
 8481 050b 00       		.byte	0
 8482 050c 00       		.byte	0
 8483 050d FF       		.byte	-1
 8484 050e 00       		.byte	0
 8485 050f 01       		.byte	1
 8486 0510 00       		.byte	0
 8487 0511 03       		.byte	3
 8488 0512 00       		.byte	0
 8489 0513 01       		.byte	1
 8490 0514 00       		.byte	0
 8491 0515 00       		.byte	0
 8492 0516 00       		.byte	0
 8493 0517 30       		.byte	48
 8494 0518 01       		.byte	1
 8495 0519 01       		.byte	1
 8496 051a 00       		.byte	0
 8497 051b 00000000 		.space	5
 8497      00
 8498 0520 06       		.byte	6
 8499 0521 00       		.byte	0
 8500 0522 02       		.byte	2
 8501 0523 00       		.byte	0
 8502 0524 00       		.byte	0
 8503 0525 00       		.byte	0
 8504 0526 00       		.byte	0
 8505 0527 00       		.byte	0
 8506 0528 00       		.byte	0
 8507 0529 03       		.byte	3
 8508 052a 00       		.byte	0
 8509 052b 00       		.byte	0
 8510 052c 00       		.byte	0
 8511 052d 00       		.byte	0
 8512 052e 00       		.byte	0
 8513 052f 30       		.byte	48
 8514 0530 01       		.byte	1
 8515 0531 01       		.byte	1
 8516 0532 00       		.byte	0
 8517 0533 00000000 		.space	5
 8517      00
 8518 0538 23       		.byte	35
 8519 0539 00       		.byte	0
 8520 053a 02       		.byte	2
 8521 053b 00       		.byte	0
 8522 053c 00       		.byte	0
 8523 053d 30       		.byte	48
 8524 053e 00       		.byte	0
 8525 053f 01       		.byte	1
 8526 0540 00       		.byte	0
 8527 0541 03       		.byte	3
 8528 0542 0A       		.byte	10
 8529 0543 00       		.byte	0
 8530 0544 00       		.byte	0
 8531 0545 0A       		.byte	10
 8532 0546 00       		.byte	0
 8533 0547 30       		.byte	48
 8534 0548 01       		.byte	1
 8535 0549 01       		.byte	1
 8536 054a 00       		.byte	0
 8537 054b 00000000 		.space	5
 8537      00
 8538 0550 08       		.byte	8
 8539 0551 00       		.byte	0
 8540 0552 01       		.byte	1
 8541 0553 00       		.byte	0
 8542 0554 00       		.byte	0
 8543 0555 7F       		.byte	127
 8544 0556 00       		.byte	0
 8545 0557 01       		.byte	1
 8546 0558 00       		.byte	0
 8547 0559 03       		.byte	3
 8548 055a 00       		.byte	0
 8549 055b 00       		.byte	0
 8550 055c 00       		.byte	0
 8551 055d 00       		.byte	0
 8552 055e 00       		.byte	0
 8553 055f 30       		.byte	48
 8554 0560 01       		.byte	1
 8555 0561 00       		.byte	0
 8556 0562 00       		.byte	0
 8557 0563 00000000 		.space	5
 8557      00
 8558 0568 09       		.byte	9
 8559 0569 00       		.byte	0
 8560 056a 02       		.byte	2
 8561 056b 00       		.byte	0
 8562 056c 00       		.byte	0
 8563 056d 05       		.byte	5
 8564 056e 00       		.byte	0
 8565 056f 01       		.byte	1
 8566 0570 00       		.byte	0
 8567 0571 03       		.byte	3
 8568 0572 00       		.byte	0
 8569 0573 00       		.byte	0
 8570 0574 00       		.byte	0
 8571 0575 00       		.byte	0
 8572 0576 00       		.byte	0
 8573 0577 30       		.byte	48
 8574 0578 01       		.byte	1
 8575 0579 00       		.byte	0
 8576 057a 00       		.byte	0
 8577 057b 00000000 		.space	5
 8577      00
 8578 0580 10       		.byte	16
 8579 0581 00       		.byte	0
 8580 0582 03       		.byte	3
 8581 0583 00       		.byte	0
 8582 0584 00       		.byte	0
 8583 0585 00       		.byte	0
 8584 0586 00       		.byte	0
 8585 0587 00       		.byte	0
 8586 0588 00       		.byte	0
 8587 0589 03       		.byte	3
 8588 058a 00       		.byte	0
 8589 058b 00       		.byte	0
 8590 058c 00       		.byte	0
 8591 058d 00       		.byte	0
 8592 058e 00       		.byte	0
 8593 058f 30       		.byte	48
 8594 0590 01       		.byte	1
 8595 0591 00       		.byte	0
 8596 0592 00       		.byte	0
 8597 0593 00000000 		.space	5
 8597      00
 8598 0598 00       		.byte	0
 8599 0599 00       		.byte	0
 8600 059a 02       		.byte	2
 8601 059b 00       		.byte	0
 8602 059c 00       		.byte	0
 8603 059d 40       		.byte	64
 8604 059e 00       		.byte	0
 8605 059f 01       		.byte	1
 8606 05a0 00       		.byte	0
 8607 05a1 03       		.byte	3
 8608 05a2 00       		.byte	0
 8609 05a3 0F       		.byte	15
 8610 05a4 11       		.byte	17
 8611 05a5 00       		.byte	0
 8612 05a6 00       		.byte	0
 8613 05a7 30       		.byte	48
 8614 05a8 01       		.byte	1
 8615 05a9 00       		.byte	0
 8616 05aa 00       		.byte	0
 8617 05ab 00000000 		.space	5
 8617      00
 8618 05b0 00       		.byte	0
 8619 05b1 00       		.byte	0
 8620 05b2 02       		.byte	2
 8621 05b3 00       		.byte	0
 8622 05b4 00       		.byte	0
 8623 05b5 64       		.byte	100
 8624 05b6 00       		.byte	0
 8625 05b7 01       		.byte	1
 8626 05b8 00       		.byte	0
 8627 05b9 03       		.byte	3
 8628 05ba 00       		.byte	0
 8629 05bb 00       		.byte	0
 8630 05bc 00       		.byte	0
 8631 05bd 00       		.byte	0
 8632 05be 00       		.byte	0
 8633 05bf 30       		.byte	48
 8634 05c0 01       		.byte	1
 8635 05c1 00       		.byte	0
 8636 05c2 00       		.byte	0
 8637 05c3 00000000 		.space	5
 8637      00
 8638 05c8 00       		.byte	0
 8639 05c9 00       		.byte	0
 8640 05ca 02       		.byte	2
 8641 05cb 00       		.byte	0
 8642 05cc 00       		.byte	0
 8643 05cd 64       		.byte	100
 8644 05ce 00       		.byte	0
 8645 05cf 01       		.byte	1
 8646 05d0 00       		.byte	0
 8647 05d1 03       		.byte	3
 8648 05d2 00       		.byte	0
 8649 05d3 00       		.byte	0
 8650 05d4 00       		.byte	0
 8651 05d5 00       		.byte	0
 8652 05d6 00       		.byte	0
 8653 05d7 30       		.byte	48
 8654 05d8 01       		.byte	1
 8655 05d9 00       		.byte	0
 8656 05da 00       		.byte	0
 8657 05db 00000000 		.space	5
 8657      00
 8658 05e0 00       		.byte	0
 8659 05e1 00       		.byte	0
 8660 05e2 02       		.byte	2
 8661 05e3 00       		.byte	0
 8662 05e4 00       		.byte	0
 8663 05e5 64       		.byte	100
 8664 05e6 00       		.byte	0
 8665 05e7 01       		.byte	1
 8666 05e8 00       		.byte	0
 8667 05e9 03       		.byte	3
 8668 05ea 00       		.byte	0
 8669 05eb 00       		.byte	0
 8670 05ec 00       		.byte	0
 8671 05ed 00       		.byte	0
 8672 05ee 00       		.byte	0
 8673 05ef 30       		.byte	48
 8674 05f0 01       		.byte	1
 8675 05f1 00       		.byte	0
 8676 05f2 00       		.byte	0
 8677 05f3 00000000 		.space	5
 8677      00
 8678 05f8 00       		.byte	0
 8679 05f9 00       		.byte	0
 8680 05fa 02       		.byte	2
 8681 05fb 00       		.byte	0
 8682 05fc 00       		.byte	0
 8683 05fd 64       		.byte	100
 8684 05fe 00       		.byte	0
 8685 05ff 01       		.byte	1
 8686 0600 00       		.byte	0
 8687 0601 03       		.byte	3
 8688 0602 00       		.byte	0
 8689 0603 00       		.byte	0
 8690 0604 00       		.byte	0
 8691 0605 00       		.byte	0
 8692 0606 00       		.byte	0
 8693 0607 30       		.byte	48
 8694 0608 01       		.byte	1
 8695 0609 00       		.byte	0
 8696 060a 00       		.byte	0
 8697 060b 00000000 		.space	5
 8697      00
 8700              	glProbeCtrl:
 8701 0610 00       		.byte	0
 8702 0611 00       		.byte	0
 8703 0612 01       		.byte	1
 8704 0613 01       		.byte	1
 8705 0614 15       		.byte	21
 8706 0615 16       		.byte	22
 8707 0616 05       		.byte	5
 8708 0617 00       		.byte	0
 8709 0618 00       		.byte	0
 8710 0619 00       		.byte	0
 8711 061a 00       		.byte	0
 8712 061b 00       		.byte	0
 8713 061c 00       		.byte	0
 8714 061d 00       		.byte	0
 8715 061e 00       		.byte	0
 8716 061f 00       		.byte	0
 8717 0620 00       		.byte	0
 8718 0621 00       		.byte	0
 8719 0622 00       		.byte	0
 8720 0623 48       		.byte	72
 8721 0624 3F       		.byte	63
 8722 0625 00       		.byte	0
 8723 0626 00       		.byte	0
 8724 0627 40       		.byte	64
 8725 0628 00       		.byte	0
 8726 0629 00       		.byte	0
 8727 062a 0000     		.space	2
 8730              	glProbeCtrl20:
 8731 062c 00       		.byte	0
 8732 062d 00       		.byte	0
 8733 062e 01       		.byte	1
 8734 062f 01       		.byte	1
 8735 0630 80       		.byte	-128
 8736 0631 1A       		.byte	26
 8737 0632 06       		.byte	6
 8738 0633 00       		.byte	0
 8739 0634 00       		.byte	0
 8740 0635 00       		.byte	0
 8741 0636 00       		.byte	0
 8742 0637 00       		.byte	0
 8743 0638 00       		.byte	0
 8744 0639 00       		.byte	0
 8745 063a 00       		.byte	0
 8746 063b 00       		.byte	0
 8747 063c 00       		.byte	0
 8748 063d 00       		.byte	0
 8749 063e 00       		.byte	0
 8750 063f D2       		.byte	-46
 8751 0640 0F       		.byte	15
 8752 0641 00       		.byte	0
 8753 0642 00       		.byte	0
 8754 0643 40       		.byte	64
 8755 0644 00       		.byte	0
 8756 0645 00       		.byte	0
 8757 0646 0000     		.space	2
 8760              	glProbeStilCtrl:
 8761 0648 01       		.byte	1
 8762 0649 01       		.byte	1
 8763 064a 00       		.byte	0
 8764 064b 00       		.byte	0
 8765 064c 48       		.byte	72
 8766 064d 3F       		.byte	63
 8767 064e 00       		.byte	0
 8768 064f 00       		.byte	0
 8769 0650 40       		.byte	64
 8770 0651 00       		.byte	0
 8771 0652 00       		.byte	0
 8772 0653 00       		.space	1
 8775              	glProbeStilCtrl20:
 8776 0654 01       		.byte	1
 8777 0655 01       		.byte	1
 8778 0656 00       		.byte	0
 8779 0657 00       		.byte	0
 8780 0658 D2       		.byte	-46
 8781 0659 0F       		.byte	15
 8782 065a 00       		.byte	0
 8783 065b 00       		.byte	0
 8784 065c 40       		.byte	64
 8785 065d 00       		.byte	0
 8786 065e 00       		.byte	0
 8789              	snapButFlag:
 8790 065f 01       		.byte	1
 8793              	CyFxGpifTransition:
 8794 0660 0000     		.short	0
 8795 0662 5555     		.short	21845
 8796 0664 8888     		.short	-30584
 8797 0666 AAAA     		.short	-21846
 8798 0668 3333     		.short	13107
 8799 066a 0000     		.space	2
 8802              	CyFxGpifWavedata:
 8803 066c 0181731E 		.word	510886145
 8804 0670 00000000 		.word	0
 8805 0674 00000080 		.word	-2147483648
 8806 0678 00000000 		.word	0
 8807 067c 00000000 		.word	0
 8808 0680 00000000 		.word	0
 8809 0684 0201702E 		.word	779092226
 8810 0688 00010000 		.word	256
 8811 068c A0000080 		.word	-2147483488
 8812 0690 00000000 		.word	0
 8813 0694 00000000 		.word	0
 8814 0698 00000000 		.word	0
 8815 069c 0380722E 		.word	779255811
 8816 06a0 02010020 		.word	536871170
 8817 06a4 60000080 		.word	-2147483552
 8818 06a8 00000000 		.word	0
 8819 06ac 00000000 		.word	0
 8820 06b0 00000000 		.word	0
 8821 06b4 0460722E 		.word	779247620
 8822 06b8 02010024 		.word	603980034
 8823 06bc 90000080 		.word	-2147483504
 8824 06c0 0594731E 		.word	510891013
 8825 06c4 06000000 		.word	6
 8826 06c8 00000080 		.word	-2147483648
 8827 06cc 0380722E 		.word	779255811
 8828 06d0 02010020 		.word	536871170
 8829 06d4 60000080 		.word	-2147483552
 8830 06d8 0693731E 		.word	510890758
 8831 06dc 06000000 		.word	6
 8832 06e0 00000080 		.word	-2147483648
 8833 06e4 0720703E 		.word	1047535623
 8834 06e8 08010000 		.word	264
 8835 06ec 00000080 		.word	-2147483648
 8836 06f0 0820703E 		.word	1047535624
 8837 06f4 08010000 		.word	264
 8838 06f8 00000080 		.word	-2147483648
 8839 06fc 0920703E 		.word	1047535625
 8840 0700 08010000 		.word	264
 8841 0704 00000080 		.word	-2147483648
 8842 0708 0A20703E 		.word	1047535626
 8843 070c 08010000 		.word	264
 8844 0710 00000080 		.word	-2147483648
 8845 0714 0380722E 		.word	779255811
 8846 0718 02010020 		.word	536871170
 8847 071c 60000080 		.word	-2147483552
 8848 0720 0B000000 		.word	11
 8849 0724 00000000 		.word	0
 8850 0728 00010080 		.word	-2147483392
 8851 072c 0460722E 		.word	779247620
 8852 0730 02010024 		.word	603980034
 8853 0734 90000080 		.word	-2147483504
 8854 0738 0D000000 		.word	13
 8855 073c 00000000 		.word	0
 8856 0740 00010080 		.word	-2147483392
 8857 0744 0460722E 		.word	779247620
 8858 0748 02010024 		.word	603980034
 8859 074c 90000080 		.word	-2147483504
 8860 0750 0C000000 		.word	12
 8861 0754 00000000 		.word	0
 8862 0758 00010080 		.word	-2147483392
 8863 075c 0380722E 		.word	779255811
 8864 0760 02010020 		.word	536871170
 8865 0764 60000080 		.word	-2147483552
 8866 0768 0E000000 		.word	14
 8867 076c 00000000 		.word	0
 8868 0770 00010080 		.word	-2147483392
 8869 0774 00000000 		.word	0
 8870 0778 00000000 		.word	0
 8871 077c 00000000 		.word	0
 8872 0780 00000000 		.word	0
 8873 0784 00000000 		.word	0
 8874 0788 00000000 		.word	0
 8877              	CyFxGpifWavedataPosition:
 8878 078c 00       		.byte	0
 8879 078d 01       		.byte	1
 8880 078e 02       		.byte	2
 8881 078f 03       		.byte	3
 8882 0790 04       		.byte	4
 8883 0791 05       		.byte	5
 8884 0792 06       		.byte	6
 8885 0793 07       		.byte	7
 8886 0794 08       		.byte	8
 8887 0795 09       		.byte	9
 8888 0796 0A       		.byte	10
 8889 0797 0B       		.byte	11
 8890 0798 0B       		.byte	11
 8891 0799 0B       		.byte	11
 8892 079a 0B       		.byte	11
 8893 079b 00       		.space	1
 8896              	CyFxGpifRegValue:
 8897 079c 08830080 		.word	-2147450104
 8898 07a0 67000000 		.word	103
 8899 07a4 00000000 		.word	0
 8900 07a8 46000000 		.word	70
 8901 07ac 00000000 		.word	0
 8902 07b0 00000000 		.word	0
 8903 07b4 02000000 		.word	2
 8904 07b8 82000000 		.word	130
 8905 07bc 82070000 		.word	1922
 8906 07c0 40040000 		.word	1088
 8907 07c4 FCFF0000 		.word	65532
 8908 07c8 28000000 		.word	40
 8909 07cc 00000000 		.word	0
 8910 07d0 00000000 		.word	0
 8911 07d4 00000000 		.word	0
 8912 07d8 00000000 		.word	0
 8913 07dc 01000000 		.word	1
 8914 07e0 00000000 		.word	0
 8915 07e4 00000000 		.word	0
 8916 07e8 00000000 		.word	0
 8917 07ec 00000000 		.word	0
 8918 07f0 00000000 		.word	0
 8919 07f4 00000000 		.word	0
 8920 07f8 00000000 		.word	0
 8921 07fc 00000000 		.word	0
 8922 0800 00000000 		.word	0
 8923 0804 00000000 		.word	0
 8924 0808 00000000 		.word	0
 8925 080c 00000000 		.word	0
 8926 0810 06000000 		.word	6
 8927 0814 00000000 		.word	0
 8928 0818 FFFF0000 		.word	65535
 8929 081c 09010000 		.word	265
 8930 0820 00000000 		.word	0
 8931 0824 F71F0000 		.word	8183
 8932 0828 00000000 		.word	0
 8933 082c FFFF0000 		.word	65535
 8934 0830 09010000 		.word	265
 8935 0834 00000000 		.word	0
 8936 0838 F71F0000 		.word	8183
 8937 083c 00000000 		.word	0
 8938 0840 00000000 		.word	0
 8939 0844 00000000 		.word	0
 8940 0848 00000000 		.word	0
 8941 084c 00000000 		.word	0
 8942 0850 00000000 		.word	0
 8943 0854 00000000 		.word	0
 8944 0858 00000000 		.word	0
 8945 085c 00000000 		.word	0
 8946 0860 00000000 		.word	0
 8947 0864 00000000 		.word	0
 8948 0868 00000000 		.word	0
 8949 086c 00000000 		.word	0
 8950 0870 00000000 		.word	0
 8951 0874 00000000 		.word	0
 8952 0878 00000000 		.word	0
 8953 087c 00000000 		.word	0
 8954 0880 00000000 		.word	0
 8955 0884 00000000 		.word	0
 8956 0888 00000000 		.word	0
 8957 088c 00000000 		.word	0
 8958 0890 00000000 		.word	0
 8959 0894 00000000 		.word	0
 8960 0898 00040180 		.word	-2147417088
 8961 089c 01040180 		.word	-2147417087
 8962 08a0 02040180 		.word	-2147417086
 8963 08a4 03040180 		.word	-2147417085
 8964 08a8 00000000 		.word	0
 8965 08ac 00000000 		.word	0
 8966 08b0 00000000 		.word	0
 8967 08b4 00000000 		.word	0
 8968 08b8 00000000 		.word	0
 8969 08bc 00000000 		.word	0
 8970 08c0 00000000 		.word	0
 8971 08c4 00000000 		.word	0
 8972 08c8 C1FFFFFF 		.word	-63
 8975              	CyFxGpifTransition_usb2:
 8976 08cc 0000     		.short	0
 8977 08ce 5555     		.short	21845
 8978 08d0 AAAA     		.short	-21846
 8979 08d2 8888     		.short	-30584
 8980 08d4 1111     		.short	4369
 8981 08d6 4444     		.short	17476
 8982 08d8 3333     		.short	13107
 8983 08da CCCC     		.short	-13108
 8986              	CyFxGpifWavedata_usb2:
 8987 08dc 0181731E 		.word	510886145
 8988 08e0 00000000 		.word	0
 8989 08e4 00000080 		.word	-2147483648
 8990 08e8 00000000 		.word	0
 8991 08ec 00000000 		.word	0
 8992 08f0 00000000 		.word	0
 8993 08f4 0201703E 		.word	1047527682
 8994 08f8 00010000 		.word	256
 8995 08fc A00000C0 		.word	-1073741664
 8996 0900 00000000 		.word	0
 8997 0904 00000000 		.word	0
 8998 0908 00000000 		.word	0
 8999 090c 0394731E 		.word	510891011
 9000 0910 04000020 		.word	536870916
 9001 0914 60004080 		.word	-2143289248
 9002 0918 00000000 		.word	0
 9003 091c 00000000 		.word	0
 9004 0920 00000000 		.word	0
 9005 0924 0620702E 		.word	779100166
 9006 0928 0C000000 		.word	12
 9007 092c 00000080 		.word	-2147483648
 9008 0930 0620702E 		.word	779100166
 9009 0934 0C000000 		.word	12
 9010 0938 00000080 		.word	-2147483648
 9011 093c 0394731E 		.word	510891011
 9012 0940 04000020 		.word	536870916
 9013 0944 60004080 		.word	-2143289248
 9014 0948 0620702E 		.word	779100166
 9015 094c 0C000000 		.word	12
 9016 0950 00000080 		.word	-2147483648
 9017 0954 0C93731E 		.word	510890764
 9018 0958 04000024 		.word	603979780
 9019 095c 90004080 		.word	-2143289200
 9020 0960 0D20702E 		.word	779100173
 9021 0964 0C000000 		.word	12
 9022 0968 00000080 		.word	-2147483648
 9023 096c 0780724E 		.word	1316126727
 9024 0970 0A000000 		.word	10
 9025 0974 00000080 		.word	-2147483648
 9026 0978 08000000 		.word	8
 9027 097c 00000000 		.word	0
 9028 0980 00010080 		.word	-2147483392
 9029 0984 0920702E 		.word	779100169
 9030 0988 0C010000 		.word	268
 9031 098c 00000080 		.word	-2147483648
 9032 0990 0A01701E 		.word	510656778
 9033 0994 0E000100 		.word	65550
 9034 0998 00000080 		.word	-2147483648
 9035 099c 00000000 		.word	0
 9036 09a0 00000000 		.word	0
 9037 09a4 00000000 		.word	0
 9038 09a8 00000000 		.word	0
 9039 09ac 00000000 		.word	0
 9040 09b0 00000000 		.word	0
 9041 09b4 0394731E 		.word	510891011
 9042 09b8 04000020 		.word	536870916
 9043 09bc 60004080 		.word	-2143289248
 9044 09c0 08000000 		.word	8
 9045 09c4 00000000 		.word	0
 9046 09c8 00010080 		.word	-2147483392
 9047 09cc 0B000000 		.word	11
 9048 09d0 00000000 		.word	0
 9049 09d4 00010080 		.word	-2147483392
 9050 09d8 0C93731E 		.word	510890764
 9051 09dc 04000024 		.word	603979780
 9052 09e0 90004080 		.word	-2143289200
 9053 09e4 0D20702E 		.word	779100173
 9054 09e8 0C000000 		.word	12
 9055 09ec 00000080 		.word	-2147483648
 9056 09f0 0D20702E 		.word	779100173
 9057 09f4 0C000000 		.word	12
 9058 09f8 00000080 		.word	-2147483648
 9059 09fc 0E60724E 		.word	1316118542
 9060 0a00 0A000000 		.word	10
 9061 0a04 00000080 		.word	-2147483648
 9062 0a08 0F000000 		.word	15
 9063 0a0c 00000000 		.word	0
 9064 0a10 00010080 		.word	-2147483392
 9065 0a14 1020702E 		.word	779100176
 9066 0a18 0C010000 		.word	268
 9067 0a1c 00000080 		.word	-2147483648
 9068 0a20 1101701E 		.word	510656785
 9069 0a24 0E000100 		.word	65550
 9070 0a28 00000080 		.word	-2147483648
 9071 0a2c 0C93731E 		.word	510890764
 9072 0a30 04000024 		.word	603979780
 9073 0a34 90004080 		.word	-2143289200
 9074 0a38 0F000000 		.word	15
 9075 0a3c 00000000 		.word	0
 9076 0a40 00010080 		.word	-2147483392
 9077 0a44 12000000 		.word	18
 9078 0a48 00000000 		.word	0
 9079 0a4c 00010080 		.word	-2147483392
 9080 0a50 0394731E 		.word	510891011
 9081 0a54 04000020 		.word	536870916
 9082 0a58 60004080 		.word	-2143289248
 9083 0a5c 0480732E 		.word	779321348
 9084 0a60 02010000 		.word	258
 9085 0a64 000040C0 		.word	-1069547520
 9086 0a68 0580732E 		.word	779321349
 9087 0a6c 02010000 		.word	258
 9088 0a70 000040C0 		.word	-1069547520
 9089 0a74 0580732E 		.word	779321349
 9090 0a78 02010000 		.word	258
 9091 0a7c 000040C0 		.word	-1069547520
 9092 0a80 0480732E 		.word	779321348
 9093 0a84 02010000 		.word	258
 9094 0a88 000040C0 		.word	-1069547520
 9097              	CyFxGpifWavedataPosition_usb2:
 9098 0a8c 00       		.byte	0
 9099 0a8d 01       		.byte	1
 9100 0a8e 02       		.byte	2
 9101 0a8f 03       		.byte	3
 9102 0a90 04       		.byte	4
 9103 0a91 05       		.byte	5
 9104 0a92 06       		.byte	6
 9105 0a93 07       		.byte	7
 9106 0a94 08       		.byte	8
 9107 0a95 09       		.byte	9
 9108 0a96 0A       		.byte	10
 9109 0a97 08       		.byte	8
 9110 0a98 0B       		.byte	11
 9111 0a99 0C       		.byte	12
 9112 0a9a 0D       		.byte	13
 9113 0a9b 08       		.byte	8
 9114 0a9c 0E       		.byte	14
 9115 0a9d 0F       		.byte	15
 9116 0a9e 08       		.byte	8
 9117 0a9f 08       		.byte	8
 9118 0aa0 08       		.byte	8
 9119 0aa1 08       		.byte	8
 9120 0aa2 08       		.byte	8
 9121 0aa3 08       		.byte	8
 9122 0aa4 08       		.byte	8
 9123 0aa5 08       		.byte	8
 9124 0aa6 08       		.byte	8
 9125 0aa7 08       		.byte	8
 9126 0aa8 08       		.byte	8
 9127 0aa9 08       		.byte	8
 9128 0aaa 08       		.byte	8
 9129 0aab 08       		.byte	8
 9130 0aac 08       		.byte	8
 9131 0aad 08       		.byte	8
 9132 0aae 08       		.byte	8
 9133 0aaf 08       		.byte	8
 9134 0ab0 08       		.byte	8
 9135 0ab1 08       		.byte	8
 9136 0ab2 08       		.byte	8
 9137 0ab3 08       		.byte	8
 9138 0ab4 08       		.byte	8
 9139 0ab5 08       		.byte	8
 9140 0ab6 08       		.byte	8
 9141 0ab7 08       		.byte	8
 9142 0ab8 08       		.byte	8
 9143 0ab9 08       		.byte	8
 9144 0aba 08       		.byte	8
 9145 0abb 08       		.byte	8
 9146 0abc 08       		.byte	8
 9147 0abd 08       		.byte	8
 9148 0abe 08       		.byte	8
 9149 0abf 08       		.byte	8
 9150 0ac0 08       		.byte	8
 9151 0ac1 08       		.byte	8
 9152 0ac2 08       		.byte	8
 9153 0ac3 08       		.byte	8
 9154 0ac4 08       		.byte	8
 9155 0ac5 08       		.byte	8
 9156 0ac6 08       		.byte	8
 9157 0ac7 08       		.byte	8
 9158 0ac8 08       		.byte	8
 9159 0ac9 08       		.byte	8
 9160 0aca 08       		.byte	8
 9161 0acb 08       		.byte	8
 9162 0acc 08       		.byte	8
 9163 0acd 08       		.byte	8
 9164 0ace 08       		.byte	8
 9165 0acf 08       		.byte	8
 9166 0ad0 08       		.byte	8
 9167 0ad1 08       		.byte	8
 9168 0ad2 08       		.byte	8
 9169 0ad3 08       		.byte	8
 9170 0ad4 08       		.byte	8
 9171 0ad5 08       		.byte	8
 9172 0ad6 08       		.byte	8
 9173 0ad7 08       		.byte	8
 9174 0ad8 08       		.byte	8
 9175 0ad9 08       		.byte	8
 9176 0ada 08       		.byte	8
 9177 0adb 08       		.byte	8
 9178 0adc 08       		.byte	8
 9179 0add 08       		.byte	8
 9180 0ade 08       		.byte	8
 9181 0adf 08       		.byte	8
 9182 0ae0 08       		.byte	8
 9183 0ae1 08       		.byte	8
 9184 0ae2 08       		.byte	8
 9185 0ae3 08       		.byte	8
 9186 0ae4 08       		.byte	8
 9187 0ae5 08       		.byte	8
 9188 0ae6 08       		.byte	8
 9189 0ae7 08       		.byte	8
 9190 0ae8 08       		.byte	8
 9191 0ae9 08       		.byte	8
 9192 0aea 08       		.byte	8
 9193 0aeb 08       		.byte	8
 9194 0aec 08       		.byte	8
 9195 0aed 08       		.byte	8
 9196 0aee 08       		.byte	8
 9197 0aef 08       		.byte	8
 9198 0af0 08       		.byte	8
 9199 0af1 08       		.byte	8
 9200 0af2 08       		.byte	8
 9201 0af3 08       		.byte	8
 9202 0af4 08       		.byte	8
 9203 0af5 08       		.byte	8
 9204 0af6 08       		.byte	8
 9205 0af7 08       		.byte	8
 9206 0af8 08       		.byte	8
 9207 0af9 08       		.byte	8
 9208 0afa 08       		.byte	8
 9209 0afb 08       		.byte	8
 9210 0afc 08       		.byte	8
 9211 0afd 08       		.byte	8
 9212 0afe 08       		.byte	8
 9213 0aff 08       		.byte	8
 9214 0b00 08       		.byte	8
 9215 0b01 08       		.byte	8
 9216 0b02 08       		.byte	8
 9217 0b03 08       		.byte	8
 9218 0b04 08       		.byte	8
 9219 0b05 08       		.byte	8
 9220 0b06 08       		.byte	8
 9221 0b07 08       		.byte	8
 9222 0b08 08       		.byte	8
 9223 0b09 08       		.byte	8
 9224 0b0a 08       		.byte	8
 9225 0b0b 08       		.byte	8
 9226 0b0c 00       		.byte	0
 9227 0b0d 01       		.byte	1
 9228 0b0e 02       		.byte	2
 9229 0b0f 10       		.byte	16
 9230 0b10 04       		.byte	4
 9231 0b11 05       		.byte	5
 9232 0b12 06       		.byte	6
 9233 0b13 07       		.byte	7
 9234 0b14 08       		.byte	8
 9235 0b15 09       		.byte	9
 9236 0b16 0A       		.byte	10
 9237 0b17 08       		.byte	8
 9238 0b18 11       		.byte	17
 9239 0b19 0C       		.byte	12
 9240 0b1a 0D       		.byte	13
 9241 0b1b 08       		.byte	8
 9242 0b1c 0E       		.byte	14
 9243 0b1d 0F       		.byte	15
 9244 0b1e 08       		.byte	8
 9245 0b1f 00       		.space	1
 9248              	CyFxGpifRegValue_usb2:
 9249 0b20 08830080 		.word	-2147450104
 9250 0b24 67000000 		.word	103
 9251 0b28 01000000 		.word	1
 9252 0b2c 46000000 		.word	70
 9253 0b30 00000000 		.word	0
 9254 0b34 00000000 		.word	0
 9255 0b38 02000000 		.word	2
 9256 0b3c 82000000 		.word	130
 9257 0b40 82070000 		.word	1922
 9258 0b44 40040000 		.word	1088
 9259 0b48 FCFF0000 		.word	65532
 9260 0b4c 28000000 		.word	40
 9261 0b50 00000000 		.word	0
 9262 0b54 00000000 		.word	0
 9263 0b58 00000000 		.word	0
 9264 0b5c 00000000 		.word	0
 9265 0b60 01000000 		.word	1
 9266 0b64 00000000 		.word	0
 9267 0b68 00000000 		.word	0
 9268 0b6c 00000000 		.word	0
 9269 0b70 00000000 		.word	0
 9270 0b74 00000000 		.word	0
 9271 0b78 00000000 		.word	0
 9272 0b7c 00000000 		.word	0
 9273 0b80 00000000 		.word	0
 9274 0b84 00000000 		.word	0
 9275 0b88 00000000 		.word	0
 9276 0b8c 00000000 		.word	0
 9277 0b90 00000000 		.word	0
 9278 0b94 06000000 		.word	6
 9279 0b98 00000000 		.word	0
 9280 0b9c FFFF0000 		.word	65535
 9281 0ba0 09010000 		.word	265
 9282 0ba4 00000000 		.word	0
 9283 0ba8 F71F0000 		.word	8183
 9284 0bac 00000000 		.word	0
 9285 0bb0 FFFF0000 		.word	65535
 9286 0bb4 09010000 		.word	265
 9287 0bb8 00000000 		.word	0
 9288 0bbc F71F0000 		.word	8183
 9289 0bc0 00000000 		.word	0
 9290 0bc4 00000000 		.word	0
 9291 0bc8 00000000 		.word	0
 9292 0bcc 00000000 		.word	0
 9293 0bd0 00000000 		.word	0
 9294 0bd4 00000000 		.word	0
 9295 0bd8 00000000 		.word	0
 9296 0bdc 00000000 		.word	0
 9297 0be0 00000000 		.word	0
 9298 0be4 00000000 		.word	0
 9299 0be8 00000000 		.word	0
 9300 0bec 00000000 		.word	0
 9301 0bf0 00000000 		.word	0
 9302 0bf4 00000000 		.word	0
 9303 0bf8 00000000 		.word	0
 9304 0bfc 00000000 		.word	0
 9305 0c00 00000000 		.word	0
 9306 0c04 00000000 		.word	0
 9307 0c08 00000000 		.word	0
 9308 0c0c 00000000 		.word	0
 9309 0c10 00000000 		.word	0
 9310 0c14 00000000 		.word	0
 9311 0c18 00000000 		.word	0
 9312 0c1c 00040180 		.word	-2147417088
 9313 0c20 01040180 		.word	-2147417087
 9314 0c24 02040180 		.word	-2147417086
 9315 0c28 03040180 		.word	-2147417085
 9316 0c2c 00000000 		.word	0
 9317 0c30 00000000 		.word	0
 9318 0c34 00000000 		.word	0
 9319 0c38 00000000 		.word	0
 9320 0c3c 00000000 		.word	0
 9321 0c40 00000000 		.word	0
 9322 0c44 00000000 		.word	0
 9323 0c48 00000000 		.word	0
 9324 0c4c C1FFFFFF 		.word	-63
 9325              		.section	.rodata.str1.4,"aMS",%progbits,1
 9326              		.align	2
 9327              	.LC0:
 9328 0000 49324320 		.ascii	"I2C per-timer %d\015\012\000"
 9328      7065722D 
 9328      74696D65 
 9328      72202564 
 9328      0D0A00
 9329 0013 00       		.space	1
 9330              	.LC1:
 9331 0014 54686520 		.ascii	"The command queue is ready %d %d\015\012\000"
 9331      636F6D6D 
 9331      616E6420 
 9331      71756575 
 9331      65206973 
 9332 0037 00       		.space	1
 9333              	.LC2:
 9334 0038 4572726F 		.ascii	"Error in multichannelcommitbuffer: Code = %d, size "
 9334      7220696E 
 9334      206D756C 
 9334      74696368 
 9334      616E6E65 
 9335 006b 3D202578 		.ascii	"= %x, dmaDone %x\015\012\000"
 9335      2C20646D 
 9335      61446F6E 
 9335      65202578 
 9335      0D0A00
 9336 007e 0000     		.space	2
 9337              	.LC3:
 9338 0080 52455345 		.ascii	"RESET encountered...0x%x 0x%x\015\012\000"
 9338      5420656E 
 9338      636F756E 
 9338      74657265 
 9338      642E2E2E 
 9339              	.LC4:
 9340 00a0 53555350 		.ascii	"SUSPEND encountered...0x%x 0x%x\015\012\000"
 9340      454E4420 
 9340      656E636F 
 9340      756E7465 
 9340      7265642E 
 9341 00c2 0000     		.space	2
 9342              	.LC5:
 9343 00c4 55534220 		.ascii	"USB disconnected...0x%x 0x%x\015\012\000"
 9343      64697363 
 9343      6F6E6E65 
 9343      63746564 
 9343      2E2E2E30 
 9344 00e3 00       		.space	1
 9345              	.LC6:
 9346 00e4 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_CONTROL_REQUEST_EVENT Failed %x"
 9346      43595F46 
 9346      585F5556 
 9346      435F5649 
 9346      44454F5F 
 9347 0117 0A00     		.ascii	"\012\000"
 9348 0119 000000   		.space	3
 9349              	.LC7:
 9350 011c 53657420 		.ascii	"Set CY_FX_UVC_VIDEO_STREAM_REQUEST_EVENT Failed %x\012"
 9350      43595F46 
 9350      585F5556 
 9350      435F5649 
 9350      44454F5F 
 9351 014f 00       		.ascii	"\000"
 9352              	.LC8:
 9353 0150 416C7465 		.ascii	"Alternate setting 0..\015\012\000"
 9353      726E6174 
 9353      65207365 
 9353      7474696E 
 9353      6720302E 
 9354              	.LC9:
 9355 0168 436C6561 		.ascii	"Clear feature request detected..\015\012\000"
 9355      72206665 
 9355      61747572 
 9355      65207265 
 9355      71756573 
 9356 018b 00       		.space	1
 9357              	.LC10:
 9358 018c 0D0A2063 		.ascii	"\015\012 commiteof state = %d\000"
 9358      6F6D6D69 
 9358      74656F66 
 9358      20737461 
 9358      7465203D 
 9359              	.LC11:
 9360 01a4 4368616E 		.ascii	"Channel Set WrapUp failed, Error code = %d\015\012\000"
 9360      6E656C20 
 9360      53657420 
 9360      57726170 
 9360      55702066 
 9361 01d1 000000   		.space	3
 9362              	.LC12:
 9363 01d4 4572726F 		.ascii	"Error handler...\015\012\000"
 9363      72206861 
 9363      6E646C65 
 9363      722E2E2E 
 9363      0D0A00
 9364 01e7 00       		.space	1
 9365              	.LC13:
 9366 01e8 436F6D6D 		.ascii	"Commit EOF failed!\012\000"
 9366      69742045 
 9366      4F462066 
 9366      61696C65 
 9366      64210A00 
 9367              	.LC14:
 9368 01fc 54686520 		.ascii	"The I2C command is 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x"
 9368      49324320 
 9368      636F6D6D 
 9368      616E6420 
 9368      69732030 
 9369 022f 25782030 		.ascii	"%x 0x%x 0x%x 0x%x 0x%x\015\012\000"
 9369      78257820 
 9369      30782578 
 9369      20307825 
 9369      78203078 
 9370              	.LC15:
 9371 0248 6261636B 		.ascii	"back light compensation setting is not correct. %d "
 9371      206C6967 
 9371      68742063 
 9371      6F6D7065 
 9371      6E736174 
 9372 027b 25640D0A 		.ascii	"%d\015\012\000"
 9372      00
 9373              	.LC16:
 9374 0280 54686520 		.ascii	"The I2C current data is not available. try again. %"
 9374      49324320 
 9374      63757272 
 9374      656E7420 
 9374      64617461 
 9375 02b3 64202564 		.ascii	"d %d\015\012\000"
 9375      0D0A00
 9376 02ba 0000     		.space	2
 9377              	.LC17:
 9378 02bc 4578704D 		.ascii	"ExpM&AGC sent to host. %d %d; %d %d\015\012\000"
 9378      26414743 
 9378      2073656E 
 9378      7420746F 
 9378      20686F73 
 9379 02e2 0000     		.space	2
 9380              	.LC18:
 9381 02e4 4578704D 		.ascii	"ExpM&AGC gotten from host. %d %d; %d %d\015\012\000"
 9381      26414743 
 9381      20676F74 
 9381      74656E20 
 9381      66726F6D 
 9382 030e 0000     		.space	2
 9383              	.LC19:
 9384 0310 54686520 		.ascii	"The get data from host fail error code %d.\015\012\000"
 9384      67657420 
 9384      64617461 
 9384      2066726F 
 9384      6D20686F 
 9385 033d 000000   		.space	3
 9386              	.LC20:
 9387 0340 54686520 		.ascii	"The Request 0x%x parameter get from host 0x%x 0x%x "
 9387      52657175 
 9387      65737420 
 9387      30782578 
 9387      20706172 
 9388 0373 2F207365 		.ascii	"/ send to host 0x%x 0x%x\015\012\000"
 9388      6E642074 
 9388      6F20686F 
 9388      73742030 
 9388      78257820 
 9389 038e 0000     		.space	2
 9390              	.LC21:
 9391 0390 5A6F6F6D 		.ascii	"Zoom Op receives (CT) 0x%x 0x%x 0x%x\015\012\000"
 9391      204F7020 
 9391      72656365 
 9391      69766573 
 9391      20284354 
 9392 03b7 00       		.space	1
 9393              	.LC22:
 9394 03b8 64656661 		.ascii	"default selector (CT) 0x%x 0x%x\015\012\000"
 9394      756C7420 
 9394      73656C65 
 9394      63746F72 
 9394      20284354 
 9395 03da 0000     		.space	2
 9396              	.LC23:
 9397 03dc 64656661 		.ascii	"default request (CT) 0x%x 0x%x\015\012\000"
 9397      756C7420 
 9397      72657175 
 9397      65737420 
 9397      28435429 
 9398 03fd 000000   		.space	3
 9399              	.LC24:
 9400 0400 54686520 		.ascii	"The Request 0x%x parameter get from host (CT) 0x%x "
 9400      52657175 
 9400      65737420 
 9400      30782578 
 9400      20706172 
 9401 0433 30782578 		.ascii	"0x%x 0x%x / send to host 0x%x 0x%x 0x%x, %d\015\012"
 9401      20307825 
 9401      78202F20 
 9401      73656E64 
 9401      20746F20 
 9402 0460 00       		.ascii	"\000"
 9403 0461 000000   		.space	3
 9404              	.LC25:
 9405 0464 55534220 		.ascii	"USB speed = %d evenflag = 0x%x bmReqType = 0x%x\015"
 9405      73706565 
 9405      64203D20 
 9405      25642065 
 9405      76656E66 
 9406 0494 0A625265 		.ascii	"\012bRequest = 0x%x wValue = 0x%x wIndex = 0x%x wLe"
 9406      71756573 
 9406      74203D20 
 9406      30782578 
 9406      20775661 
 9407 04c4 6E677468 		.ascii	"ngth = 0x%x isflag 0x%x\015\012\000"
 9407      203D2030 
 9407      78257820 
 9407      6973666C 
 9407      61672030 
 9408 04de 0000     		.space	2
 9409              	.LC26:
 9410 04e0 54686520 		.ascii	"The default setup request value 0x%x 0x%x\015\012\000"
 9410      64656661 
 9410      756C7420 
 9410      73657475 
 9410      70207265 
 9411              	.LC27:
 9412 050c 54686520 		.ascii	"The host command is not correct for 1080p camera 0x"
 9412      686F7374 
 9412      20636F6D 
 9412      6D616E64 
 9412      20697320 
 9413 053f 25782030 		.ascii	"%x 0x%x\015\012\000"
 9413      7825780D 
 9413      0A00
 9414 0549 000000   		.space	3
 9415              	.LC28:
 9416 054c 53657420 		.ascii	"Set CY_FX_UVC_STREAM_EVENT failed %x\012\000"
 9416      43595F46 
 9416      585F5556 
 9416      435F5354 
 9416      5245414D 
 9417 0572 0000     		.space	2
 9418              	.LC29:
 9419 0574 47657420 		.ascii	"Get UVC still trigger control %d %d\015\012\000"
 9419      55564320 
 9419      7374696C 
 9419      6C207472 
 9419      69676765 
 9420 059a 0000     		.space	2
 9421              	.LC30:
 9422 059c 55564320 		.ascii	"UVC still trigger control fail %d %d\015\012\000"
 9422      7374696C 
 9422      6C207472 
 9422      69676765 
 9422      7220636F 
 9423 05c3 00       		.space	1
 9424              	.LC31:
 9425 05c4 4661696C 		.ascii	"Failed to send interrupt status, Error code = %d\015"
 9425      65642074 
 9425      6F207365 
 9425      6E642069 
 9425      6E746572 
 9426 05f5 0A00     		.ascii	"\012\000"
 9427 05f7 00       		.space	1
 9428              	.LC32:
 9429 05f8 54686520 		.ascii	"The set def data 0x%x, 0x%x.\015\012\000"
 9429      73657420 
 9429      64656620 
 9429      64617461 
 9429      20307825 
 9430 0617 00       		.space	1
 9431              	.LC33:
 9432 0618 54686520 		.ascii	"The set def data 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x"
 9432      73657420 
 9432      64656620 
 9432      64617461 
 9432      20307825 
 9433 064b 2E0D0A00 		.ascii	".\015\012\000"
 9434 064f 00       		.space	1
 9435              	.LC34:
 9436 0650 55415254 		.ascii	"UART initialization failed!\012\000"
 9436      20696E69 
 9436      7469616C 
 9436      697A6174 
 9436      696F6E20 
 9437 066d 000000   		.space	3
 9438              	.LC35:
 9439 0670 49324320 		.ascii	"I2C initialization failed!\012\000"
 9439      696E6974 
 9439      69616C69 
 9439      7A617469 
 9439      6F6E2066 
 9440              	.LC36:
 9441 068c 49324320 		.ascii	"I2C configuration failed!\012\000"
 9441      636F6E66 
 9441      69677572 
 9441      6174696F 
 9441      6E206661 
 9442 06a7 00       		.space	1
 9443              	.LC37:
 9444 06a8 55564320 		.ascii	"UVC Create Event failed, Error Code = %d\012\000"
 9444      43726561 
 9444      74652045 
 9444      76656E74 
 9444      20666169 
 9445 06d2 0000     		.space	2
 9446              	.LC38:
 9447 06d4 4750494F 		.ascii	"GPIO Init failed, Error Code = %d\012\000"
 9447      20496E69 
 9447      74206661 
 9447      696C6564 
 9447      2C204572 
 9448 06f7 00       		.space	1
 9449              	.LC39:
 9450 06f8 4750494F 		.ascii	"GPIO Override failed, Error Code = %d\012\000"
 9450      204F7665 
 9450      72726964 
 9450      65206661 
 9450      696C6564 
 9451 071f 00       		.space	1
 9452              	.LC40:
 9453 0720 4750494F 		.ascii	"GPIO(20) Override failed, Error Code = %d\012\000"
 9453      28323029 
 9453      204F7665 
 9453      72726964 
 9453      65206661 
 9454 074b 00       		.space	1
 9455              	.LC41:
 9456 074c 4750494F 		.ascii	"GPIO(24) Override failed, Error Code = %d\012\000"
 9456      28323429 
 9456      204F7665 
 9456      72726964 
 9456      65206661 
 9457 0777 00       		.space	1
 9458              	.LC42:
 9459 0778 4750494F 		.ascii	"GPIO Set (reset 22) Config Error, Error Code = %d\012"
 9459      20536574 
 9459      20287265 
 9459      73657420 
 9459      32322920 
 9460 07aa 00       		.ascii	"\000"
 9461 07ab 00       		.space	1
 9462              	.LC43:
 9463 07ac 4750494F 		.ascii	"GPIO Set (power 20) Config Error, Error Code = %d\012"
 9463      20536574 
 9463      2028706F 
 9463      77657220 
 9463      32302920 
 9464 07de 00       		.ascii	"\000"
 9465 07df 00       		.space	1
 9466              	.LC44:
 9467 07e0 4750494F 		.ascii	"GPIO Set (snap shot 24) Config Error, Error Code = "
 9467      20536574 
 9467      2028736E 
 9467      61702073 
 9467      686F7420 
 9468 0813 25640A00 		.ascii	"%d\012\000"
 9469 0817 00       		.space	1
 9470              	.LC45:
 9471 0818 50494220 		.ascii	"PIB Function Failed to Start, Error Code = %d\012\000"
 9471      46756E63 
 9471      74696F6E 
 9471      20466169 
 9471      6C656420 
 9472 0847 00       		.space	1
 9473              	.LC46:
 9474 0848 55534220 		.ascii	"USB Function Failed to Start, Error Code = %d\012\000"
 9474      46756E63 
 9474      74696F6E 
 9474      20466169 
 9474      6C656420 
 9475 0877 00       		.space	1
 9476              	.LC47:
 9477 0878 55534220 		.ascii	"USB Set Endpoint config failed, Error Code = %d\012"
 9477      53657420 
 9477      456E6470 
 9477      6F696E74 
 9477      20636F6E 
 9478 08a8 00       		.ascii	"\000"
 9479 08a9 000000   		.space	3
 9480              	.LC48:
 9481 08ac 444D4120 		.ascii	"DMA Interrupt Status Channel Creation Failed, Error"
 9481      496E7465 
 9481      72727570 
 9481      74205374 
 9481      61747573 
 9482 08df 20436F64 		.ascii	" Code = %d\012\000"
 9482      65203D20 
 9482      25640A00 
 9483 08eb 00       		.space	1
 9484              	.LC49:
 9485 08ec 4661696C 		.ascii	"Failed to allocate memory for interrupt status buff"
 9485      65642074 
 9485      6F20616C 
 9485      6C6F6361 
 9485      7465206D 
 9486 091f 65720D0A 		.ascii	"er\015\012\000"
 9486      00
 9487              	.LC50:
 9488 0924 444D4120 		.ascii	"DMA Channel Creation Failed, Error Code = %d\012\000"
 9488      4368616E 
 9488      6E656C20 
 9488      43726561 
 9488      74696F6E 
 9489 0952 0000     		.space	2
 9490              	.LC51:
 9491 0954 55534220 		.ascii	"USB Connect failed, Error Code = %d\012\000"
 9491      436F6E6E 
 9491      65637420 
 9491      6661696C 
 9491      65642C20 
 9492 0979 000000   		.space	3
 9493              	.LC52:
 9494 097c 0D0A2831 		.ascii	"\015\012(1) fb %d pb %d pbc %d\015\012\000"
 9494      29206662 
 9494      20256420 
 9494      70622025 
 9494      64207062 
 9495 0997 00       		.space	1
 9496              	.LC53:
 9497 0998 444D4120 		.ascii	"DMA Channel Reset Failed, Error Code = %d\012\000"
 9497      4368616E 
 9497      6E656C20 
 9497      52657365 
 9497      74204661 
 9498 09c3 00       		.space	1
 9499              	.LC54:
 9500 09c4 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\012"
 9500      4368616E 
 9500      6E656C20 
 9500      53657420 
 9500      5472616E 
 9501 09f5 00       		.ascii	"\000"
 9502 09f6 0000     		.space	2
 9503              	.LC55:
 9504 09f8 444D4120 		.ascii	"DMA Channel Set Transfer Failed, Error Code = %d\015"
 9504      4368616E 
 9504      6E656C20 
 9504      53657420 
 9504      5472616E 
 9505 0a29 0A00     		.ascii	"\012\000"
 9506 0a2b 00       		.space	1
 9507              	.LC56:
 9508 0a2c 0D0A2073 		.ascii	"\015\012 super gpif\000"
 9508      75706572 
 9508      20677069 
 9508      6600
 9509 0a3a 0000     		.space	2
 9510              	.LC57:
 9511 0a3c 0D0A2068 		.ascii	"\015\012 high gpif\000"
 9511      69676820 
 9511      67706966 
 9511      00
 9512 0a49 000000   		.space	3
 9513              	.LC58:
 9514 0a4c 4C6F6164 		.ascii	"Loading GPIF Configuration failed, Error Code = %d\015"
 9514      696E6720 
 9514      47504946 
 9514      20436F6E 
 9514      66696775 
 9515 0a7f 0A00     		.ascii	"\012\000"
 9516 0a81 000000   		.space	3
 9517              	.LC59:
 9518 0a84 53746172 		.ascii	"Starting GPIF state machine failed, Error Code = %d"
 9518      74696E67 
 9518      20475049 
 9518      46207374 
 9518      61746520 
 9519 0ab7 0D0A00   		.ascii	"\015\012\000"
 9520 0aba 0000     		.space	2
 9521              	.LC60:
 9522 0abc 33303A55 		.ascii	"30:UVC App Thread\000"
 9522      56432041 
 9522      70702054 
 9522      68726561 
 9522      6400
 9523 0ace 0000     		.space	2
 9524              	.LC61:
 9525 0ad0 33313A55 		.ascii	"31:UVC App EP0 Thread\000"
 9525      56432041 
 9525      70702045 
 9525      50302054 
 9525      68726561 
 9526 0ae6 0000     		.space	2
 9527              	.LC62:
 9528 0ae8 33323A49 		.ascii	"32:I2C App CTRL Thread\000"
 9528      32432041 
 9528      70702043 
 9528      54524C20 
 9528      54687265 
 9529 0aff 00       		.bss
 9530              		.align	2
 9531              		.set	.LANCHOR0,. + 0
 9534              	glFxUVCEvent:
 9535 0000 00000000 		.space	40
 9535      00000000 
 9535      00000000 
 9535      00000000 
 9535      00000000 
 9538              	fb:
 9539 0028 0000     		.space	2
 9542              	pb:
 9543 002a 0000     		.space	2
 9546              	pbc:
 9547 002c 0000     		.space	2
 9550              	prodCount:
 9551 002e 0000     		.space	2
 9554              	consCount:
 9555 0030 0000     		.space	2
 9556 0032 0000     		.space	2
 9559              	streamingStarted:
 9560 0034 00000000 		.space	4
 9563              	gpif_initialized:
 9564 0038 00000000 		.space	4
 9567              	isUsbConnected:
 9568 003c 00000000 		.space	4
 9571              	clearFeatureRqtReceived:
 9572 0040 00000000 		.space	4
 9575              	hitFV:
 9576 0044 00000000 		.space	4
 9579              	usbSpeed:
 9580 0048 00       		.space	1
 9581 0049 000000   		.space	3
 9584              	I2CCMDArry:
 9585 004c 00000000 		.space	12
 9585      00000000 
 9585      00000000 
 9588              	glEp0Buffer:
 9589 0058 00000000 		.space	32
 9589      00000000 
 9589      00000000 
 9589      00000000 
 9589      00000000 
 9592              	CamMode:
 9593 0078 00       		.space	1
 9594 0079 000000   		.space	3
 9597              	glCommitCtrl:
 9598 007c 00000000 		.space	32
 9598      00000000 
 9598      00000000 
 9598      00000000 
 9598      00000000 
 9601              	stiflag:
 9602 009c 00000000 		.space	4
 9605              	uvcAppThread:
 9606 00a0 00000000 		.space	168
 9606      00000000 
 9606      00000000 
 9606      00000000 
 9606      00000000 
 9609              	uvcAppEP0Thread:
 9610 0148 00000000 		.space	168
 9610      00000000 
 9610      00000000 
 9610      00000000 
 9610      00000000 
 9613              	i2cAppThread:
 9614 01f0 00000000 		.space	168
 9614      00000000 
 9614      00000000 
 9614      00000000 
 9614      00000000 
 9617              	testSnap:
 9618 0298 00       		.space	1
 9619 0299 00       		.space	1
 9622              	fbbak:
 9623 029a 0000     		.space	2
 9626              	pbbak:
 9627 029c 0000     		.space	2
 9630              	pbcbak:
 9631 029e 0000     		.space	2
 9634              	pbcpbak:
 9635 02a0 0000     		.space	2
 9636 02a2 0000     		.text
 9637              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 uvc.c
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:21     .text:00000000 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:24     .text:00000000 I2cAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:184    .text:00000148 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:190    .text:00000158 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:291    .text:0000021c $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:305    .text:0000023c I2CCmdCb
                            *COM*:0000002c I2CCmdTimer
                            *COM*:00000020 cmdQu
                            *COM*:00000020 statQu
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:302    .text:0000023c $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:324    .text:0000024c $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:328    .text:00000250 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:331    .text:00000250 CyFxUvcApplnDmaCallback
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:489    .text:00000378 $d
                            *COM*:000000dc glChHandleUVCStream
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:497    .text:0000038c $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:499    .text:0000038c CyFxUVCApplnUSBEventCB
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:678    .text:000004ec $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:687    .text:000004fc $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:689    .text:000004fc CyFxUVCApplnUSBSetupCB
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1014   .text:000007c4 $d
                            *COM*:00000001 bmReqType
                            *COM*:00000001 bRequest
                            *COM*:00000002 wValue
                            *COM*:00000002 wIndex
                            *COM*:00000002 wLength
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1030   .text:000007f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1033   .text:000007f0 CyFxGpifCB
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1079   .text:0000082c $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1092   .text:00000858 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1155   .text:000008c8 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1162   .text:000008d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1173   .text:000008f0 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1176   .text:000008f0 I2CCmdHandler
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1330   .text:00000a4c $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1336   .text:00000a58 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1339   .text:00000a58 setIrisauto
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1402   .text:00000ad8 ControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1609   .text:00000c74 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1647   .text:00000d00 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1711   .text:00000d84 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:1747   .text:00000e0c $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3008   .text:000019bc $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3026   .text:000019f8 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3029   .text:000019f8 CTControlHandle
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3197   .text:00001b54 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3210   .text:00001b7c $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3705   .text:0000208c $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3716   .text:000020ac $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3971   .text:00002364 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3984   .text:0000238c $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:3987   .text:0000238c UVCAppEP0Thread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:4049   .text:00002408 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:4057   .text:00002418 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5194   .text:00002d88 $d
                            *COM*:00000004 glInterStaBuffer
                            *COM*:000000a0 glChHandleInterStat
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5222   .text:00002de4 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5225   .text:00002de4 CamDefSet
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5516   .text:0000309c $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5523   .text:000030ac $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5526   .text:000030ac CyFxUVCAddHeader
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5562   .text:000030d8 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5566   .text:000030dc $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5569   .text:000030dc CyFxAppErrorHandler
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5594   .text:000030f8 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5598   .text:000030fc $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:5601   .text:000030fc UVCAppThread_Entry
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:6961   .text:00003bc4 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7020   .text:00003c9c $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7023   .text:00003c9c CyFxApplicationDefine
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7180   .text:00003e14 $d
                            *COM*:00000038 cmdQuMux
                            *COM*:00000038 staQuMux
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7196   .text:00003e48 $a
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7199   .text:00003e48 main
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8793   .data:00000660 CyFxGpifTransition
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8802   .data:0000066c CyFxGpifWavedata
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8877   .data:0000078c CyFxGpifWavedataPosition
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8896   .data:0000079c CyFxGpifRegValue
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7360   .rodata:00000010 CyFxGpifConfig
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8975   .data:000008cc CyFxGpifTransition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8986   .data:000008dc CyFxGpifWavedata_usb2
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9097   .data:00000a8c CyFxGpifWavedataPosition_usb2
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9248   .data:00000b20 CyFxGpifRegValue_usb2
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7373   .rodata:0000002c CyFxGpifConfig_usb2
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8789   .data:0000065f snapButFlag
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9617   .bss:00000298 testSnap
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9538   .bss:00000028 fb
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9542   .bss:0000002a pb
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9546   .bss:0000002c pbc
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9622   .bss:0000029a fbbak
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9626   .bss:0000029c pbbak
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9630   .bss:0000029e pbcbak
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9634   .bss:000002a0 pbcpbak
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9567   .bss:0000003c isUsbConnected
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9579   .bss:00000048 usbSpeed
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9571   .bss:00000040 clearFeatureRqtReceived
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9559   .bss:00000034 streamingStarted
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8700   .data:00000610 glProbeCtrl
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8760   .data:00000648 glProbeStilCtrl
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8730   .data:0000062c glProbeCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8775   .data:00000654 glProbeStilCtrl20
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8355   .data:00000480 glUVCHeader
                            *COM*:000000dc glChHandleStillStream
                            *COM*:00000038 timMux
                            *COM*:00000004 posTick
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7337   .rodata:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7341   .rodata:00000000 ExTime
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7385   .data:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7389   .data:00000000 ExUCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:7712   .data:00000180 CtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8370   .data:0000048c WBMenuCmpArry
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:8377   .data:00000490 CTCtrlParArry
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9326   .rodata.str1.4:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9530   .bss:00000000 $d
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9534   .bss:00000000 glFxUVCEvent
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9550   .bss:0000002e prodCount
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9554   .bss:00000030 consCount
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9563   .bss:00000038 gpif_initialized
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9575   .bss:00000044 hitFV
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9584   .bss:0000004c I2CCMDArry
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9588   .bss:00000058 glEp0Buffer
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9592   .bss:00000078 CamMode
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9597   .bss:0000007c glCommitCtrl
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9601   .bss:0000009c stiflag
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9605   .bss:000000a0 uvcAppThread
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9609   .bss:00000148 uvcAppEP0Thread
C:\Users\wcheng\AppData\Local\Temp\ccDQcxZP.s:9613   .bss:000001f0 i2cAppThread
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_txe_timer_create
_tx_time_get
CyU3PDebugPrint
_tx_thread_sleep
_txe_timer_activate
_txe_thread_relinquish
_txe_event_flags_get
_txe_mutex_get
_txe_mutex_put
SensorSetIrisControl
_txe_timer_change
SensorSetControl
_txe_event_flags_set
CyU3PMemCopy
CyU3PDmaMultiChannelCommitBuffer
CyU3PGpifDisable
CyU3PUsbSetEpNak
CyU3PBusyWait
CyU3PDmaMultiChannelReset
CyU3PUsbFlushEp
CyU3PUsbStall
CyU3PUsbAckSetup
CyU3PDmaMultiChannelSetWrapUp
SensorWrite2B
SensorRead2B
cmdSet
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PGpioSimpleGetValue
CyU3PDmaChannelWaitForCompletion
CyU3PDmaChannelSetupSendBuffer
CyU3PUsbGetSpeed
CyU3PUartInit
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PI2cInit
CyU3PI2cSetConfig
_txe_event_flags_create
CyU3PGpioInit
CyU3PDeviceGpioOverride
CyU3PGpioSetSimpleConfig
CyU3PPibInit
CyU3PGpifRegisterCallback
SensorReset
SensorInit
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbSetDesc
CyU3PSetEpConfig
CyU3PDmaChannelCreate
CyU3PDmaBufferAlloc
CyU3PDmaMultiChannelCreate
CyU3PConnectState
CyU3PDmaMultiChannelSetXfer
CyU3PGpifLoad
CyU3PGpifSMStart
CyU3PGpifSMSwitch
CyFxUSBDeviceDscr
CyFxUSBDeviceDscrSS
CyFxUSBDeviceQualDscr
CyFxUSBBOSDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBSSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
CyU3PMemAlloc
cmdbufCreate
cmdquInit
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
